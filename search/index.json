[{"content":"nfs-client-provisioner 是一个 Kubernetes 的简易 NFS 的外部 provisioner，本文将介绍使用 nfs-client-provisioner 这个应用，利用 NFS Server 给 Kubernetes 作为持久存储的后端，并且动态提供 PV，nfs-client-provisioner 本身不提供 NFS，需要现有的 NFS 服务器提供存储，并且 NFS 服务器与 Kubernetes 的 Slave 节点都能网络连通。\n部署 NFS 服务器 安装并配置 NFS 服务器 # 在 Ubuntu 上安装 NFS 服务器 apt update apt install nfs-kernel-server # 创建共享目录 mkdir /data/nfs # 配置 NFS vim /etc/exports # 在文件中添加以下行 /data/nfs *(rw,sync,no_subtree_check) # 重新加载 NFS 配置 exportfs -a # 启动 NFS 服务 systemctl start nfs-kernel-server systemctl enable nfs-kernel-server # 在centos上安装NFS服务器 yum install nfs-utils -y # 创建共享目录 mkdir /data/nfs # 配置 NFS vim /etc/exports # 在文件中添加以下行 /data/nfs *(rw,sync,no_subtree_check) # 重新加载 NFS 配置 exportfs -a #启动并启用NFS服务 systemctl start nfs-server systemctl enable nfs-server 部署 NFS Client Provisioner 在部署 NFS Client Provisioner 之前，确保 Kubernetes 集群已经配置好，并且具有可用的存储类。本文使用的 kubernetes 版本 V1.23.17。 本文使用到文件来自https://github.com/kubernetes-sigs/nfs-subdir-external-provisioner.git的deploy目录再经过自己的修改而来。\n创建名称空间 apiVersion: v1 kind: Namespace metadata: name: nfs-client-provisioner 2.修改 rbac 文件，修改后如下\napiVersion: v1 kind: ServiceAccount metadata: name: nfs-client-provisioner namespace: nfs-client-provisioner --- kind: ClusterRole apiVersion: rbac.authorization.k8s.io/v1 metadata: name: nfs-client-provisioner-runner rules: - apiGroups: [\u0026#34;\u0026#34;] resources: [\u0026#34;nodes\u0026#34;] verbs: [\u0026#34;get\u0026#34;, \u0026#34;list\u0026#34;, \u0026#34;watch\u0026#34;] - apiGroups: [\u0026#34;\u0026#34;] resources: [\u0026#34;persistentvolumes\u0026#34;] verbs: [\u0026#34;get\u0026#34;, \u0026#34;list\u0026#34;, \u0026#34;watch\u0026#34;, \u0026#34;create\u0026#34;, \u0026#34;delete\u0026#34;] - apiGroups: [\u0026#34;\u0026#34;] resources: [\u0026#34;persistentvolumeclaims\u0026#34;] verbs: [\u0026#34;get\u0026#34;, \u0026#34;list\u0026#34;, \u0026#34;watch\u0026#34;, \u0026#34;update\u0026#34;] - apiGroups: [\u0026#34;storage.k8s.io\u0026#34;] resources: [\u0026#34;storageclasses\u0026#34;] verbs: [\u0026#34;get\u0026#34;, \u0026#34;list\u0026#34;, \u0026#34;watch\u0026#34;] - apiGroups: [\u0026#34;\u0026#34;] resources: [\u0026#34;events\u0026#34;] verbs: [\u0026#34;create\u0026#34;, \u0026#34;update\u0026#34;, \u0026#34;patch\u0026#34;] --- kind: ClusterRoleBinding apiVersion: rbac.authorization.k8s.io/v1 metadata: name: run-nfs-client-provisioner subjects: - kind: ServiceAccount name: nfs-client-provisioner namespace: nfs-client-provisioner roleRef: kind: ClusterRole name: nfs-client-provisioner-runner apiGroup: rbac.authorization.k8s.io --- kind: Role apiVersion: rbac.authorization.k8s.io/v1 metadata: name: leader-locking-nfs-client-provisioner namespace: nfs-client-provisioner rules: - apiGroups: [\u0026#34;\u0026#34;] resources: [\u0026#34;endpoints\u0026#34;] verbs: [\u0026#34;get\u0026#34;, \u0026#34;list\u0026#34;, \u0026#34;watch\u0026#34;, \u0026#34;create\u0026#34;, \u0026#34;update\u0026#34;, \u0026#34;patch\u0026#34;] --- kind: RoleBinding apiVersion: rbac.authorization.k8s.io/v1 metadata: name: leader-locking-nfs-client-provisioner namespace: nfs-client-provisioner subjects: - kind: ServiceAccount name: nfs-client-provisioner namespace: nfs-client-provisioner roleRef: kind: Role name: leader-locking-nfs-client-provisioner apiGroup: rbac.authorization.k8s.io 3.修改 deployment 文件并部署,需要修改的地方只有 NFS 服务器所在的 IP 地址，以及 NFS 服务器共享的路径，两处都需要修改为你实际的 NFS 服务器和共享目录。\napiVersion: apps/v1 kind: Deployment metadata: name: nfs-client-provisioner labels: app: nfs-client-provisioner # replace with namespace where provisioner is deployed namespace: nfs-client-provisioner spec: replicas: 1 strategy: type: Recreate selector: matchLabels: app: nfs-client-provisioner template: metadata: labels: app: nfs-client-provisioner spec: serviceAccountName: nfs-client-provisioner containers: - name: nfs-client-provisioner image: registry.k8s.io/sig-storage/nfs-subdir-external-provisioner:v4.0.2 volumeMounts: - name: nfs-client-root mountPath: /persistentvolumes env: - name: PROVISIONER_NAME value: k8s-sigs.io/nfs-subdir-external-provisioner - name: NFS_SERVER value: 10.100.0.25 - name: NFS_PATH value: /data/nfs volumes: - name: nfs-client-root nfs: server: 10.100.0.25 path: /data/nfs 3.修改 class 文件并部署\napiVersion: storage.k8s.io/v1 kind: StorageClass metadata: name: nfs-client provisioner: k8s-sigs.io/nfs-subdir-external-provisioner # provisioner的值必须与 deployment 文件中env 的PROVISIONER_NAME值保持一致 parameters: archiveOnDelete: \u0026#34;false\u0026#34; reclaimPolicy: Retain # 回收策略 volumeBindingMode: Immediate 4.创建 pvc\nkind: PersistentVolumeClaim apiVersion: v1 metadata: name: test-claim spec: storageClassName: nfs-client accessModes: - ReadWriteMany resources: requests: storage: 100Mi 根据需要，调整存储容量、访问模式等配置。\n5.测试挂载卷，编写 nginx-pod.yaml\napiVersion: v1 kind: Pod metadata: name: nginx labels: name: nginx spec: containers: - name: nginx image: nginx ports: - containerPort: 80 protocol: TCP volumeMounts: - mountPath: /usr/share/nginx/html/ name: data volumes: - name: data persistentVolumeClaim: claimName: test-claim # pvc name 根据需要，调整镜像、测试命令、挂载路径等配置。\n6.验证\n检查 nfs-client-provisioner 部署是否成功\nkubectl get pods -n nfs-client-provisioner 检查 pv 和 pvc\nkubectl get pvc,pv ","date":"2025-01-10T00:00:00Z","image":"https://www.colorfulgz.com/p/250110/index_hu32955b812d1006d3ea7bcb6e13a1ca94_144678_120x120_fill_box_smart1_3.png","permalink":"https://www.colorfulgz.com/p/250110/","title":"NFS动态提供Kubernetes后端存储卷(NFS Client Provisioner)"},{"content":" 安装 bash-completion 系统若已安装工具包则可跳过这一步骤 # centos yum -y install bash-completion source /usr/share/bash-completion/bash_completion # ubuntu apt -y install bash-completion source /usr/share/bash-completion/bash_completion kubectl 自动补全 source \u0026lt;(kubectl completion bash) # 在 bash 中设置当前 shell 的自动补全，要先安装 bash-completion 包 echo \u0026#34;source \u0026lt;(kubectl completion bash)\u0026#34; \u0026gt;\u0026gt; ~/.bashrc # 在你的 bash shell 中永久地添加自动补全 ","date":"2025-01-09T00:00:00Z","image":"https://www.colorfulgz.com/p/250109/index_hu83f0d3e5546af4775fd452b834ce817e_72494_120x120_fill_box_smart1_3.png","permalink":"https://www.colorfulgz.com/p/250109/","title":"1分钟配置Kubectl命令自动补全功能"},{"content":" 创建 namespace apiVersion: v1 kind: Namespace metadata: name: cicd 部署 nfs-server --- kind: Service apiVersion: v1 metadata: namespace: cicd name: nfs-server labels: app: nfs-server spec: type: ClusterIP # use \u0026#34;LoadBalancer\u0026#34; to get a public ip selector: app: nfs-server ports: - name: tcp-2049 port: 2049 protocol: TCP - name: udp-111 port: 111 protocol: UDP --- kind: Deployment apiVersion: apps/v1 metadata: name: nfs-server namespace: cicd spec: replicas: 1 selector: matchLabels: app: nfs-server template: metadata: name: nfs-server labels: app: nfs-server spec: nodeName: c3-master01 # 根据自身情况修改 nodeSelector: \u0026#34;kubernetes.io/os\u0026#34;: linux containers: - name: nfs-server image: itsthenetwork/nfs-server-alpine:latest env: - name: SHARED_DIRECTORY value: \u0026#34;/exports\u0026#34; volumeMounts: - mountPath: /exports name: nfs-vol securityContext: privileged: true ports: - name: tcp-2049 containerPort: 2049 protocol: TCP - name: udp-111 containerPort: 111 protocol: UDP volumes: - name: nfs-vol hostPath: path: /data/nfs # modify this to specify another path to store nfs share data type: DirectoryOrCreate 部署 csi-nfs rbac\n--- apiVersion: v1 kind: ServiceAccount metadata: name: csi-nfs-controller-sa namespace: kube-system --- kind: ClusterRole apiVersion: rbac.authorization.k8s.io/v1 metadata: name: nfs-external-provisioner-role rules: - apiGroups: [\u0026#34;\u0026#34;] resources: [\u0026#34;persistentvolumes\u0026#34;] verbs: [\u0026#34;get\u0026#34;, \u0026#34;list\u0026#34;, \u0026#34;watch\u0026#34;, \u0026#34;create\u0026#34;, \u0026#34;delete\u0026#34;] - apiGroups: [\u0026#34;\u0026#34;] resources: [\u0026#34;persistentvolumeclaims\u0026#34;] verbs: [\u0026#34;get\u0026#34;, \u0026#34;list\u0026#34;, \u0026#34;watch\u0026#34;, \u0026#34;update\u0026#34;] - apiGroups: [\u0026#34;storage.k8s.io\u0026#34;] resources: [\u0026#34;storageclasses\u0026#34;] verbs: [\u0026#34;get\u0026#34;, \u0026#34;list\u0026#34;, \u0026#34;watch\u0026#34;] - apiGroups: [\u0026#34;\u0026#34;] resources: [\u0026#34;events\u0026#34;] verbs: [\u0026#34;get\u0026#34;, \u0026#34;list\u0026#34;, \u0026#34;watch\u0026#34;, \u0026#34;create\u0026#34;, \u0026#34;update\u0026#34;, \u0026#34;patch\u0026#34;] - apiGroups: [\u0026#34;storage.k8s.io\u0026#34;] resources: [\u0026#34;csinodes\u0026#34;] verbs: [\u0026#34;get\u0026#34;, \u0026#34;list\u0026#34;, \u0026#34;watch\u0026#34;] - apiGroups: [\u0026#34;\u0026#34;] resources: [\u0026#34;nodes\u0026#34;] verbs: [\u0026#34;get\u0026#34;, \u0026#34;list\u0026#34;, \u0026#34;watch\u0026#34;] - apiGroups: [\u0026#34;coordination.k8s.io\u0026#34;] resources: [\u0026#34;leases\u0026#34;] verbs: [\u0026#34;get\u0026#34;, \u0026#34;list\u0026#34;, \u0026#34;watch\u0026#34;, \u0026#34;create\u0026#34;, \u0026#34;update\u0026#34;, \u0026#34;patch\u0026#34;] - apiGroups: [\u0026#34;\u0026#34;] resources: [\u0026#34;secrets\u0026#34;] verbs: [\u0026#34;get\u0026#34;] --- kind: ClusterRoleBinding apiVersion: rbac.authorization.k8s.io/v1 metadata: name: nfs-csi-provisioner-binding subjects: - kind: ServiceAccount name: csi-nfs-controller-sa namespace: kube-system roleRef: kind: ClusterRole name: nfs-external-provisioner-role apiGroup: rbac.authorization.k8s.io csi-nfs-controller\n--- kind: Deployment apiVersion: apps/v1 metadata: name: csi-nfs-controller namespace: kube-system spec: replicas: 2 selector: matchLabels: app: csi-nfs-controller template: metadata: labels: app: csi-nfs-controller spec: hostNetwork: true # controller also needs to mount nfs to create dir dnsPolicy: ClusterFirstWithHostNet serviceAccountName: csi-nfs-controller-sa nodeSelector: kubernetes.io/os: linux # add \u0026#34;kubernetes.io/role: master\u0026#34; to run controller on master node priorityClassName: system-cluster-critical tolerations: - key: \u0026#34;node-role.kubernetes.io/master\u0026#34; operator: \u0026#34;Exists\u0026#34; effect: \u0026#34;NoSchedule\u0026#34; - key: \u0026#34;node-role.kubernetes.io/controlplane\u0026#34; operator: \u0026#34;Exists\u0026#34; effect: \u0026#34;NoSchedule\u0026#34; containers: - name: csi-provisioner image: k8s.gcr.io/sig-storage/csi-provisioner:v2.2.2 args: - \u0026#34;-v=2\u0026#34; - \u0026#34;--csi-address=$(ADDRESS)\u0026#34; - \u0026#34;--leader-election\u0026#34; env: - name: ADDRESS value: /csi/csi.sock volumeMounts: - mountPath: /csi name: socket-dir resources: limits: memory: 400Mi requests: cpu: 10m memory: 20Mi - name: liveness-probe image: k8s.gcr.io/sig-storage/livenessprobe:v2.5.0 args: - --csi-address=/csi/csi.sock - --probe-timeout=3s - --health-port=29652 - --v=2 volumeMounts: - name: socket-dir mountPath: /csi resources: limits: memory: 100Mi requests: cpu: 10m memory: 20Mi - name: nfs image: mcr.microsoft.com/k8s/csi/nfs-csi:v3.1.0 securityContext: privileged: true capabilities: add: [\u0026#34;SYS_ADMIN\u0026#34;] allowPrivilegeEscalation: true imagePullPolicy: IfNotPresent args: - \u0026#34;-v=5\u0026#34; - \u0026#34;--nodeid=$(NODE_ID)\u0026#34; - \u0026#34;--endpoint=$(CSI_ENDPOINT)\u0026#34; env: - name: NODE_ID valueFrom: fieldRef: fieldPath: spec.nodeName - name: CSI_ENDPOINT value: unix:///csi/csi.sock ports: - containerPort: 29652 name: healthz protocol: TCP livenessProbe: failureThreshold: 5 httpGet: path: /healthz port: healthz initialDelaySeconds: 30 timeoutSeconds: 10 periodSeconds: 30 volumeMounts: - name: pods-mount-dir mountPath: /var/lib/kubelet/pods mountPropagation: \u0026#34;Bidirectional\u0026#34; - mountPath: /csi name: socket-dir resources: limits: memory: 200Mi requests: cpu: 10m memory: 20Mi volumes: - name: pods-mount-dir hostPath: path: /var/lib/kubelet/pods type: Directory - name: socket-dir emptyDir: {} csi-nfs-driverinfo\n--- apiVersion: storage.k8s.io/v1 kind: CSIDriver metadata: name: nfs.csi.k8s.io spec: attachRequired: false volumeLifecycleModes: - Persistent - Ephemeral csi-nfs-node\n--- # This YAML file contains driver-registrar \u0026amp; csi driver nodeplugin API objects # that are necessary to run CSI nodeplugin for nfs kind: DaemonSet apiVersion: apps/v1 metadata: name: csi-nfs-node namespace: kube-system spec: updateStrategy: rollingUpdate: maxUnavailable: 1 type: RollingUpdate selector: matchLabels: app: csi-nfs-node template: metadata: labels: app: csi-nfs-node spec: hostNetwork: true # original nfs connection would be broken without hostNetwork setting dnsPolicy: ClusterFirstWithHostNet nodeSelector: kubernetes.io/os: linux tolerations: - operator: \u0026#34;Exists\u0026#34; containers: - name: liveness-probe image: k8s.gcr.io/sig-storage/livenessprobe:v2.5.0 args: - --csi-address=/csi/csi.sock - --probe-timeout=3s - --health-port=29653 - --v=2 volumeMounts: - name: socket-dir mountPath: /csi resources: limits: memory: 100Mi requests: cpu: 10m memory: 20Mi - name: node-driver-registrar image: k8s.gcr.io/sig-storage/csi-node-driver-registrar:v2.4.0 args: - --v=2 - --csi-address=/csi/csi.sock - --kubelet-registration-path=$(DRIVER_REG_SOCK_PATH) livenessProbe: exec: command: - /csi-node-driver-registrar - --kubelet-registration-path=$(DRIVER_REG_SOCK_PATH) - --mode=kubelet-registration-probe initialDelaySeconds: 30 timeoutSeconds: 15 env: - name: DRIVER_REG_SOCK_PATH value: /var/lib/kubelet/plugins/csi-nfsplugin/csi.sock - name: KUBE_NODE_NAME valueFrom: fieldRef: fieldPath: spec.nodeName volumeMounts: - name: socket-dir mountPath: /csi - name: registration-dir mountPath: /registration resources: limits: memory: 100Mi requests: cpu: 10m memory: 20Mi - name: nfs securityContext: privileged: true capabilities: add: [\u0026#34;SYS_ADMIN\u0026#34;] allowPrivilegeEscalation: true image: mcr.microsoft.com/k8s/csi/nfs-csi:v3.1.0 args: - \u0026#34;-v=5\u0026#34; - \u0026#34;--nodeid=$(NODE_ID)\u0026#34; - \u0026#34;--endpoint=$(CSI_ENDPOINT)\u0026#34; env: - name: NODE_ID valueFrom: fieldRef: fieldPath: spec.nodeName - name: CSI_ENDPOINT value: unix:///csi/csi.sock ports: - containerPort: 29653 name: healthz protocol: TCP livenessProbe: failureThreshold: 5 httpGet: path: /healthz port: healthz initialDelaySeconds: 30 timeoutSeconds: 10 periodSeconds: 30 imagePullPolicy: \u0026#34;IfNotPresent\u0026#34; volumeMounts: - name: socket-dir mountPath: /csi - name: pods-mount-dir mountPath: /var/lib/kubelet/pods mountPropagation: \u0026#34;Bidirectional\u0026#34; resources: limits: memory: 300Mi requests: cpu: 10m memory: 20Mi volumes: - name: socket-dir hostPath: path: /var/lib/kubelet/plugins/csi-nfsplugin type: DirectoryOrCreate - name: pods-mount-dir hostPath: path: /var/lib/kubelet/pods type: Directory - hostPath: path: /var/lib/kubelet/plugins_registry type: Directory name: registration-dir 创建 StorageClass apiVersion: storage.k8s.io/v1 kind: StorageClass metadata: name: nfs-csi annotations: storageclass.kubernetes.io/is-default-class: \u0026#34;true\u0026#34; provisioner: nfs.csi.k8s.io parameters: server: nfs-server.cicd share: /exports reclaimPolicy: Retain # 回收策略 volumeBindingMode: Immediate 创建 PVC apiVersion: v1 kind: PersistentVolumeClaim metadata: name: gitlab-data-pvc namespace: cicd spec: storageClassName: nfs-csi accessModes: - ReadWriteOnce resources: requests: storage: 100Gi --- apiVersion: v1 kind: PersistentVolumeClaim metadata: name: gitlab-config-pvc namespace: cicd spec: storageClassName: nfs-csi accessModes: - ReadWriteOnce resources: requests: storage: 5Gi deployment apiVersion: apps/v1 kind: Deployment metadata: name: gitlab namespace: cicd spec: selector: matchLabels: app: gitlab replicas: 1 template: metadata: labels: app: gitlab spec: containers: - name: gitlab image: gitlab/gitlab-ce:17.2.1-ce.0 env: - name: GITLAB_SKIP_UNMIGRATED_DATA_CHECK value: \u0026#34;true\u0026#34; - name: GITLAB_OMNIBUS_CONFIG value: | external_url = \u0026#39;http://gitlab.example.com/\u0026#39; prometheus[\u0026#39;enable\u0026#39;] = false alertmanager[\u0026#39;enable\u0026#39;] = false gitlab_rails[\u0026#39;time_zone\u0026#39;] = \u0026#39;Asia/Shanghai\u0026#39; gitlab_rails[\u0026#39;gitlab_email_enabled\u0026#39;] = false gitlab_rails[\u0026#39;smtp_enable\u0026#39;] = false gitlab_rails[\u0026#39;gravatar_plain_url\u0026#39;] = \u0026#39;http://gravatar.loli.net/avatar/%{hash}?s=%{size}\u0026amp;d=identicon\u0026#39; gitlab_rails[\u0026#39;gravatar_ssl_url\u0026#39;] = \u0026#39;https://gravatar.loli.net/avatar/%{hash}?s=%{size}\u0026amp;d=identicon\u0026#39; nginx[\u0026#39;worker_processes\u0026#39;] = 2 postgresql[\u0026#39;max_connections\u0026#39;] = 100 postgresql[\u0026#39;shared_buffers\u0026#39;] = \u0026#34;128MB\u0026#34; ports: - containerPort: 80 name: http - containerPort: 443 name: https - containerPort: 22 name: ssh readinessProbe: exec: command: [\u0026#34;sh\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;curl -s http://127.0.0.1/-/health\u0026#34;] livenessProbe: exec: command: [\u0026#34;sh\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;curl -s http://127.0.0.1/-/health\u0026#34;] timeoutSeconds: 5 failureThreshold: 3 periodSeconds: 60 startupProbe: exec: command: [\u0026#34;sh\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;curl -s http://127.0.0.1/-/health\u0026#34;] failureThreshold: 20 periodSeconds: 120 resources: requests: memory: \u0026#34;4Gi\u0026#34; cpu: \u0026#34;2\u0026#34; limits: memory: \u0026#34;8Gi\u0026#34; cpu: \u0026#34;4\u0026#34; volumeMounts: - name: data mountPath: /var/opt/gitlab - name: config mountPath: /etc/gitlab - name: log mountPath: /var/log/gitlab - mountPath: /dev/shm name: cache-volume volumes: - name: data persistentVolumeClaim: claimName: gitlab-data-pvc - name: config persistentVolumeClaim: claimName: gitlab-config-pvc - name: log emptyDir: {} - name: cache-volume emptyDir: medium: Memory sizeLimit: 256Mi 创建 ingress apiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: gitlab namespace: cicd spec: ingressClassName: nginx rules: - host: gitlab.example.com http: paths: - backend: service: name: gitlab-svc port: number: 80 path: / pathType: Prefix ","date":"2025-01-08T00:00:00Z","image":"https://www.colorfulgz.com/p/250108/index_hub8466684b472b0babce73b9d19dde495_291404_120x120_fill_box_smart1_3.png","permalink":"https://www.colorfulgz.com/p/250108/","title":"kubernetes 部署gitlab"},{"content":" 背景 随着项目数量增加，不同项目对 node 版本有不同要求，基于现有的单 node 版本无法支持多项目多 node 进行研究。\n安装教程\n1.下载脚本并执行\nwget -qO- https://raw.githubusercontent.com/nvm-sh/nvm/v0.40.1/install.sh | bash 2.执行脚本后会在${HOME}/.bashrc 文件中自动添加如下内容\nexport NVM_DIR=\u0026#34;$HOME/.nvm\u0026#34; [ -s \u0026#34;$NVM_DIR/nvm.sh\u0026#34; ] \u0026amp;\u0026amp; \\. \u0026#34;$NVM_DIR/nvm.sh\u0026#34; # This loads nvm [ -s \u0026#34;$NVM_DIR/bash_completion\u0026#34; ] \u0026amp;\u0026amp; \\. \u0026#34;$NVM_DIR/bash_completion\u0026#34; # This loads nvm bash_completion 如果没有添加则手动添加，在以下任一文件中均可 ~/.bash_profile, ~/.zshrc, ~/.profile, or ~/.bashrc,在文件尾部添加 nvm 命令所在路径\nvim ~/.bashrc # nvm执行路径地址 export NVM_DIR=\u0026#34;$([ -z \u0026#34;${XDG_CONFIG_HOME-}\u0026#34; ] \u0026amp;\u0026amp; printf %s \u0026#34;${HOME}/.nvm\u0026#34; || printf %s \u0026#34;${XDG_CONFIG_HOME}/nvm\u0026#34;)\u0026#34; [ -s \u0026#34;$NVM_DIR/nvm.sh\u0026#34; ] \u0026amp;\u0026amp; \\. \u0026#34;$NVM_DIR/nvm.sh\u0026#34; # This loads nvm 3.重新加载配置文件\nsource ~/.bashrc 4.查看 NVM 版本\nroot@master01:~# nvm -v 0.40.1 扩展 注：当上述方式无效时，可用以下方式，进行安装 nvm # 1、 在对应目录中下载nvm对应版本压缩包 wget https://github.com/nvm-sh/nvm/archive/refs/tags/v0.40.1.tar.gz # 2、 解压到nvm目录 tar -zxvf v0.40.1.tar.gz -C ~/.nvm/ # 3、编辑配置环境 ~/.bash_profile, ~/.zshrc, ~/.profile, or ~/.bashrc 任一都行 vim ~/.bashrc # 4、在~/.bashrc的末尾，添加如下语句： export NVM_DIR=\u0026#34;$HOME/.nvm/nvm-0.40.1\u0026#34; [ -s \u0026#34;$NVM_DIR/nvm.sh\u0026#34; ] \u0026amp;\u0026amp; \\. \u0026#34;$NVM_DIR/nvm.sh\u0026#34; # This loads nvm [ -s \u0026#34;$NVM_DIR/bash_completion\u0026#34; ] \u0026amp;\u0026amp; \\. \u0026#34;$NVM_DIR/bash_completion\u0026#34; # This loads nvm bash_completion # 5、重新加载配置 source ~/.bashrc # 6、查看版本 root@master01:~# nvm -v 0.40.1 ","date":"2025-01-07T00:00:00Z","image":"https://www.colorfulgz.com/p/250107/index_hu011e04d91359bdffc933e0152c074e0c_10862_120x120_fill_q75_box_smart1.jpeg","permalink":"https://www.colorfulgz.com/p/250107/","title":"Linux 部署安装nvm"},{"content":"在 Kubernetes 中，CoreDNS 作为默认的 DNS 服务器，负责集群内部的域名解析。要添加域名解析，通常需要修改 CoreDNS 的配置文件，该配置文件实际上是一个存储在 kube-system 命名空间下的 ConfigMap 对象。\n案例：假设要将域名 docker.local.io 解析到 IP 地址 192.168.0.100，以下是详细的操作步骤\n打开 CoreDns 的配置文件 kubectl edit cm coredns -n kube-system 在配置文件中添加域名解析条目 修改之前可以先备份一下原 ConfigMap,以防配置修改错误。\napiVersion: v1 data: Corefile: | .:53 { errors health { lameduck 5s } ready hosts { 192.168.1.100 docker.local.io # 新增 fallthrough } kubernetes cluster.local in-addr.arpa ip6.arpa { pods insecure upstream fallthrough in-addr.arpa ip6.arpa } prometheus :9153 forward . /etc/resolv.conf { max_concurrent 1000 } cache 30 loop reload loadbalance } kind: ConfigMap metadata: name: coredns namespace: kube-system 保存并关闭配置文件，请注意，hosts 插件的配置块必须正确缩进。\n重启 CoreDNS 服务以应用更改 修改 ConfigMap 后，Kubernetes 会自动检测到这些更改并重新加载 CoreDNS 配置，但有时候为了确保更改立即生效，您可能需要手动重启 CoreDNS 的 Pod。这可以通过删除 CoreDNS 的 Pod 来实现，Kubernetes 的 Deployment 控制器会自动创建新的 Pod 来替换它们： kubectl delete pod -n kube-system -l k8s-app=kube-dns 请注意，在某些 Kubernetes 集群中，CoreDNS 的 label 可能不是 k8s-app=kube-dns，而是其他类似的 label，如 k8s-app=coredns。您可以使用下面的命令来检查正确的 label。\nkubectl get pods -n kube-system --show-labels ","date":"2025-01-06T00:00:00Z","image":"https://www.colorfulgz.com/p/250106/index_hu6f81351f3fdcc670c9eb8871fc301ff4_225799_120x120_fill_box_smart1_3.png","permalink":"https://www.colorfulgz.com/p/250106/","title":"Kubernetes修改CoreDNS配置文件解析内部域名"},{"content":"kubernetes hostAliases 的示例:\napiVersion: v1 kind: Pod metadata: name: hostAliases spec: containers: - name: hostAliases image: nginx:latest hostAliases: - ip: \u0026#34;10.10.1.100\u0026#34; hostnames: - \u0026#34;docker.local.io\u0026#34; # 内网域名 - ip: \u0026#34;10.10.1.101\u0026#34; hostnames: - \u0026#34;gitlab.local.io\u0026#34; # 内网域名 - ip: \u0026#34;10.10.1.102\u0026#34; hostnames: - \u0026#34;jenkins.local.io\u0026#34; # 内网域名 ","date":"2025-01-03T00:00:00Z","image":"https://www.colorfulgz.com/p/250103/index_hu277670ebf48d1569abc5f98bf44614ba_48446_120x120_fill_box_smart1_3.png","permalink":"https://www.colorfulgz.com/p/250103/","title":"Kubernetes通过配置 hostAliases 来进行内网域名解析"},{"content":"在 Kubernetes 中进行滚动更新时，避免服务中断是确保应用高可用性的关键。以下是一些最佳实践和策略，可以帮助你实现这一目标:\n使用 Readiness Probes Readiness Probes 用于检测 Pod 是否已经准备好接收流量。只有在 Readiness Probe 返回成功之后，Kubernetes 才会将流量路由到新的 Pod。\napiVersion: v1 kind: Pod metadata: name: nginx spec: containers: - name: nginx image: nginx readinessProbe: httpGet: path: /healthz port: 80 initialDelaySeconds: 5 periodSeconds: 10 使用 PreStop Hook apiVersion: v1 kind: Pod metadata: name: nginx spec: containers: - name: nginx image: nginx lifecycle: preStop: exec: command: [\u0026#34;/bin/sh\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;sleep 10\u0026#34;] 具体执行的命令可根据业务环境来指定\n配置适当的 maxUnavailable 和 maxSurge 在 Deployment 中配置 strategy 字段来控制滚动更新的行为。例如，设置 maxUnavailable 为 0 确保在更新过程中不会有任何 Pod 不可用。\napiVersion: apps/v1 kind: Deployment metadata: name: my-deployment spec: replicas: 3 strategy: type: RollingUpdate rollingUpdate: maxUnavailable: 0 maxSurge: 1 template: metadata: labels: app: nginx spec: containers: - name: nginx image: nginx ","date":"2024-12-28T00:00:00Z","image":"https://www.colorfulgz.com/p/2024122801/index_hu577bcdfe50a970670accc4c7e4653423_55389_120x120_fill_q75_box_smart1.jpg","permalink":"https://www.colorfulgz.com/p/2024122801/","title":"kubernetes 如何避免滚动更新时服务中断"},{"content":"Kubernetes 详细教程 1. Kubernetes 介绍 1.1 应用部署方式演变 在部署应用程序的方式上，主要经历了三个时代：\n传统部署：互联网早期，会直接将应用程序部署在物理机上\n优点：简单，不需要其它技术的参与\n缺点：不能为应用程序定义资源使用边界，很难合理地分配计算资源，而且程序之间容易产生影响\n虚拟化部署：可以在一台物理机上运行多个虚拟机，每个虚拟机都是独立的一个环境\n优点：程序环境不会相互产生影响，提供了一定程度的安全性\n缺点：增加了操作系统，浪费了部分资源\n容器化部署：与虚拟化类似，但是共享了操作系统\n优点：\n可以保证每个容器拥有自己的文件系统、CPU、内存、进程空间等\n运行应用程序所需要的资源都被容器包装，并和底层基础架构解耦\n容器化的应用程序可以跨云服务商、跨 Linux 操作系统发行版进行部署\n容器化部署方式给带来很多的便利，但是也会出现一些问题，比如说：\n一个容器故障停机了，怎么样让另外一个容器立刻启动去替补停机的容器 当并发访问量变大的时候，怎么样做到横向扩展容器数量 这些容器管理的问题统称为容器编排问题，为了解决这些容器编排问题，就产生了一些容器编排的软件：\nSwarm：Docker 自己的容器编排工具 Mesos：Apache 的一个资源统一管控的工具，需要和 Marathon 结合使用 Kubernetes：Google 开源的的容器编排工具 1.2 kubernetes 简介 kubernetes，是一个全新的基于容器技术的分布式架构领先方案，是谷歌严格保密十几年的秘密武器\u0026mdash;-Borg 系统的一个开源版本，于 2014 年 9 月发布第一个版本，2015 年 7 月发布第一个正式版本。\nkubernetes 的本质是一组服务器集群，它可以在集群的每个节点上运行特定的程序，来对节点中的容器进行管理。目的是实现资源管理的自动化，主要提供了如下的主要功能：\n自我修复：一旦某一个容器崩溃，能够在 1 秒中左右迅速启动新的容器 弹性伸缩：可以根据需要，自动对集群中正在运行的容器数量进行调整 服务发现：服务可以通过自动发现的形式找到它所依赖的服务 负载均衡：如果一个服务起动了多个容器，能够自动实现请求的负载均衡 版本回退：如果发现新发布的程序版本有问题，可以立即回退到原来的版本 存储编排：可以根据容器自身的需求自动创建存储卷 1.3 kubernetes 组件 一个 kubernetes 集群主要是由控制节点(master)、工作节点(node)构成，每个节点上都会安装不同的组件。\nmaster：集群的控制平面，负责集群的决策 ( 管理 )\nApiServer : 资源操作的唯一入口，接收用户输入的命令，提供认证、授权、API 注册和发现等机制\nScheduler : 负责集群资源调度，按照预定的调度策略将 Pod 调度到相应的 node 节点上\nControllerManager : 负责维护集群的状态，比如程序部署安排、故障检测、自动扩展、滚动更新等\nEtcd ：负责存储集群中各种资源对象的信息\nnode：集群的数据平面，负责为容器提供运行环境 ( 干活 )\nKubelet : 负责维护容器的生命周期，即通过控制 docker，来创建、更新、销毁容器\nKubeProxy : 负责提供集群内部的服务发现和负载均衡\nDocker : 负责节点上容器的各种操作\n下面，以部署一个 nginx 服务来说明 kubernetes 系统各个组件调用关系：\n首先要明确，一旦 kubernetes 环境启动之后，master 和 node 都会将自身的信息存储到 etcd 数据库中\n一个 nginx 服务的安装请求会首先被发送到 master 节点的 apiServer 组件\napiServer 组件会调用 scheduler 组件来决定到底应该把这个服务安装到哪个 node 节点上\n在此时，它会从 etcd 中读取各个 node 节点的信息，然后按照一定的算法进行选择，并将结果告知 apiServer\napiServer 调用 controller-manager 去调度 Node 节点安装 nginx 服务\nkubelet 接收到指令后，会通知 docker，然后由 docker 来启动一个 nginx 的 pod\npod 是 kubernetes 的最小操作单元，容器必须跑在 pod 中至此，\n一个 nginx 服务就运行了，如果需要访问 nginx，就需要通过 kube-proxy 来对 pod 产生访问的代理\n这样，外界用户就可以访问集群中的 nginx 服务了\n1.4 kubernetes 概念 Master：集群控制节点，每个集群需要至少一个 master 节点负责集群的管控\nNode：工作负载节点，由 master 分配容器到这些 node 工作节点上，然后 node 节点上的 docker 负责容器的运行\nPod：kubernetes 的最小控制单元，容器都是运行在 pod 中的，一个 pod 中可以有 1 个或者多个容器\nController：控制器，通过它来实现对 pod 的管理，比如启动 pod、停止 pod、伸缩 pod 的数量等等\nService：pod 对外服务的统一入口，下面可以维护者同一类的多个 pod\nLabel：标签，用于对 pod 进行分类，同一类 pod 会拥有相同的标签\nNameSpace：命名空间，用来隔离 pod 的运行环境\n2. kubernetes 集群环境搭建 2.1 前置知识点 目前生产部署 Kubernetes 集群主要有两种方式：\nkubeadm\nKubeadm 是一个 K8s 部署工具，提供 kubeadm init 和 kubeadm join，用于快速部署 Kubernetes 集群。\n官方地址：https:/kubernetes.io/docs/reference/setup-tools/kubeadm/kubeadm/\r二进制包\n从 github 下载发行版的二进制包，手动部署每个组件，组成 Kubernetes 集群。\nKubeadm 降低部署门槛，但屏蔽了很多细节，遇到问题很难排查。如果想更容易可控，推荐使用二进制包部署 Kubernetes 集群，虽然手动部署麻烦点，期间可以学习很多工作原理，也利于后期维护。\n2.2 kubeadm 部署方式介绍 kubeadm 是官方社区推出的一个用于快速部署 kubernetes 集群的工具，这个工具能通过两条指令完成一个 kubernetes 集群的部署：\n创建一个 Master 节点 kubeadm init 将 Node 节点加入到当前集群中$ kubeadm join \u0026lt;Master 节点的 IP 和端口\u0026gt; 2.3 安装要求 在开始之前，部署 Kubernetes 集群机器需要满足以下几个条件：\n一台或多台机器，操作系统 CentOS7.x-86_x64 硬件配置：2GB 或更多 RAM，2 个 CPU 或更多 CPU，硬盘 30GB 或更多 集群中所有机器之间网络互通 可以访问外网，需要拉取镜像 禁止 swap 分区 2.4 最终目标 在所有节点上安装 Docker 和 kubeadm 部署 Kubernetes Master 部署容器网络插件 部署 Kubernetes Node，将节点加入 Kubernetes 集群中 部署 Dashboard Web 页面，可视化查看 Kubernetes 资源 2.5 准备环境 角色 IP 地址 组件 master01 192.168.90.100 docker，kubectl，kubeadm，kubelet node01 192.168.90.106 docker，kubectl，kubeadm，kubelet node02 192.168.90.107 docker，kubectl，kubeadm，kubelet 2.6 环境初始化 2.6.1 检查操作系统的版本 # 此方式下安装kubernetes集群要求Centos版本要在7.5或之上 [root@master ~]# cat /etc/redhat-release Centos Linux 7.5.1804 (Core) 2.6.2 主机名解析 为了方便集群节点间的直接调用，在这个配置一下主机名解析，企业中推荐使用内部 DNS 服务器\n# 主机名成解析 编辑三台服务器的/etc/hosts文件，添加下面内容 192.168.90.100 master 192.168.90.106 node1 192.168.90.107 node2 2.6.3 时间同步 kubernetes 要求集群中的节点时间必须精确一直，这里使用 chronyd 服务从网络同步时间\n企业中建议配置内部的会见同步服务器\n# 启动chronyd服务 [root@master ~]# systemctl start chronyd [root@master ~]# systemctl enable chronyd [root@master ~]# date 2.6.4 禁用 iptable 和 firewalld 服务 kubernetes 和 docker 在运行的中会产生大量的 iptables 规则，为了不让系统规则跟它们混淆，直接关闭系统的规则\n# 1 关闭firewalld服务 [root@master ~]# systemctl stop firewalld [root@master ~]# systemctl disable firewalld # 2 关闭iptables服务 [root@master ~]# systemctl stop iptables [root@master ~]# systemctl disable iptables 2.6.5 禁用 selinux selinux 是 linux 系统下的一个安全服务，如果不关闭它，在安装集群中会产生各种各样的奇葩问题\n# 编辑 /etc/selinux/config 文件，修改SELINUX的值为disable # 注意修改完毕之后需要重启linux服务 SELINUX=disabled 2.6.6 禁用 swap 分区 swap 分区指的是虚拟内存分区，它的作用是物理内存使用完，之后将磁盘空间虚拟成内存来使用，启用 swap 设备会对系统的性能产生非常负面的影响，因此 kubernetes 要求每个节点都要禁用 swap 设备，但是如果因为某些原因确实不能关闭 swap 分区，就需要在集群安装过程中通过明确的参数进行配置说明\n# 编辑分区配置文件/etc/fstab，注释掉swap分区一行 # 注意修改完毕之后需要重启linux服务 vim /etc/fstab 注释掉 /dev/mapper/centos-swap swap # /dev/mapper/centos-swap swap 2.6.7 修改 linux 的内核参数 # 修改linux的内核采纳数，添加网桥过滤和地址转发功能 # 编辑/etc/sysctl.d/kubernetes.conf文件，添加如下配置： net.bridge.bridge-nf-call-ip6tables = 1 net.bridge.bridge-nf-call-iptables = 1 net.ipv4.ip_forward = 1 # 重新加载配置 [root@master ~]# sysctl -p # 加载网桥过滤模块 [root@master ~]# modprobe br_netfilter # 查看网桥过滤模块是否加载成功 [root@master ~]# lsmod | grep br_netfilter 2.6.8 配置 ipvs 功能 在 Kubernetes 中 Service 有两种带来模型，一种是基于 iptables 的，一种是基于 ipvs 的两者比较的话，ipvs 的性能明显要高一些，但是如果要使用它，需要手动载入 ipvs 模块\n# 1.安装ipset和ipvsadm [root@master ~]# yum install ipset ipvsadm -y # 2.添加需要加载的模块写入脚本文件 [root@master ~]# cat \u0026lt;\u0026lt;EOF\u0026gt; /etc/sysconfig/modules/ipvs.modules #!/bin/bash modprobe -- ip_vs modprobe -- ip_vs_rr modprobe -- ip_vs_wrr modprobe -- ip_vs_sh modprobe -- nf_conntrack_ipv4 EOF # 3.为脚本添加执行权限 [root@master ~]# chmod +x /etc/sysconfig/modules/ipvs.modules # 4.执行脚本文件 [root@master ~]# /bin/bash /etc/sysconfig/modules/ipvs.modules # 5.查看对应的模块是否加载成功 [root@master ~]# lsmod | grep -e ip_vs -e nf_conntrack_ipv4 2.6.9 安装 docker # 1、切换镜像源 [root@master ~]# wget https:/mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo -O /etc/yum.repos.d/docker-ce.repo # 2、查看当前镜像源中支持的docker版本 [root@master ~]# yum list docker-ce --showduplicates # 3、安装特定版本的docker-ce # 必须制定--setopt=obsoletes=0，否则yum会自动安装更高版本 [root@master ~]# yum install --setopt=obsoletes=0 docker-ce-18.06.3.ce-3.el7 -y # 4、添加一个配置文件 #Docker 在默认情况下使用Vgroup Driver为cgroupfs，而Kubernetes推荐使用systemd来替代cgroupfs [root@master ~]# mkdir /etc/docker [root@master ~]# cat \u0026lt;\u0026lt;EOF\u0026gt; /etc/docker/daemon.json { \u0026#34;exec-opts\u0026#34;: [\u0026#34;native.cgroupdriver=systemd\u0026#34;], \u0026#34;registry-mirrors\u0026#34;: [\u0026#34;https:/kn0t2bca.mirror.aliyuncs.com\u0026#34;] } EOF # 5、启动dokcer [root@master ~]# systemctl restart docker [root@master ~]# systemctl enable docker 2.6.10 安装 Kubernetes 组件 # 1、由于kubernetes的镜像在国外，速度比较慢，这里切换成国内的镜像源 # 2、编辑/etc/yum.repos.d/kubernetes.repo,添加下面的配置 [kubernetes] name=Kubernetes baseurl=http:/mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64 enabled=1 gpgchech=0 repo_gpgcheck=0 gpgkey=http:/mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg http:/mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg # 3、安装kubeadm、kubelet和kubectl [root@master ~]# yum install --setopt=obsoletes=0 kubeadm-1.17.4-0 kubelet-1.17.4-0 kubectl-1.17.4-0 -y # 4、配置kubelet的cgroup #编辑/etc/sysconfig/kubelet, 添加下面的配置 KUBELET_CGROUP_ARGS=\u0026#34;--cgroup-driver=systemd\u0026#34; KUBE_PROXY_MODE=\u0026#34;ipvs\u0026#34; # 5、设置kubelet开机自启 [root@master ~]# systemctl enable kubelet 2.6.11 准备集群镜像 # 在安装kubernetes集群之前，必须要提前准备好集群需要的镜像，所需镜像可以通过下面命令查看 [root@master ~]# kubeadm config /upload list # 下载镜像 # 此镜像kubernetes的仓库中，由于网络原因，无法连接，下面提供了一种替换方案 /upload=( kube-apiserver:v1.17.4 kube-controller-manager:v1.17.4 kube-scheduler:v1.17.4 kube-proxy:v1.17.4 pause:3.1 etcd:3.4.3-0 coredns:1.6.5 ) for imageName in ${/upload[@]};do docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/$imageName docker tag registry.cn-hangzhou.aliyuncs.com/google_containers/$imageName k8s.gcr.io/$imageName docker rmi registry.cn-hangzhou.aliyuncs.com/google_containers/$imageName done 2.6.11 集群初始化 下面的操作只需要在 master 节点上执行即可\n# 创建集群 [root@master ~]# kubeadm init \\ --apiserver-advertise-address=192.168.90.100 \\ --image-repository registry.aliyuncs.com/google_containers \\ --kubernetes-version=v1.17.4 \\ --service-cidr=10.96.0.0/12 \\ --pod-network-cidr=10.244.0.0/16 # 创建必要文件 [root@master ~]# mkdir -p $HOME/.kube [root@master ~]# sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config [root@master ~]# sudo chown $(id -u):$(id -g) $HOME/.kube/config 下面的操作只需要在 node 节点上执行即可\nkubeadm join 192.168.0.100:6443 --token awk15p.t6bamck54w69u4s8 \\ --discovery-token-ca-cert-hash sha256:a94fa09562466d32d29523ab6cff122186f1127599fa4dcd5fa0152694f17117 在 master 上查看节点信息\n[root@master ~]# kubectl get nodes NAME STATUS ROLES AGE VERSION master NotReady master 6m v1.17.4 node1 NotReady \u0026lt;none\u0026gt; 22s v1.17.4 node2 NotReady \u0026lt;none\u0026gt; 19s v1.17.4 2.6.13 安装网络插件，只在 master 节点操作即可 wget https:/raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml 由于外网不好访问，如果出现无法访问的情况，可以直接用下面的 记得文件名是 kube-flannel.yml，位置：/root/kube-flannel.yml 内容：\nhttps:/github.com/flannel-io/flannel/tree/master/Documentation/kube-flannel.yml 也可手动拉取指定版本 docker pull quay.io/coreos/flannel:v0.14.0 #拉取 flannel 网络，三台主机 docker /upload #查看仓库是否拉去下来\n个人笔记 若是集群状态一直是 notready,用下面语句查看原因， journalctl -f -u kubelet.service 若原因是： cni.go:237] Unable to update cni config: no networks found in /etc/cni/net.d mkdir -p /etc/cni/net.d #创建目录给 flannel 做配置文件 vim /etc/cni/net.d/10-flannel.conf #编写配置文件\n{ \u0026#34;name\u0026#34;:\u0026#34;cbr0\u0026#34;, \u0026#34;cniVersion\u0026#34;:\u0026#34;0.3.1\u0026#34;, \u0026#34;type\u0026#34;:\u0026#34;flannel\u0026#34;, \u0026#34;deledate\u0026#34;:{ \u0026#34;hairpinMode\u0026#34;:true, \u0026#34;isDefaultGateway\u0026#34;:true } } 2.6.14 使用 kubeadm reset 重置集群 #在master节点之外的节点进行操作 kubeadm reset systemctl stop kubelet systemctl stop docker rm -rf /var/lib/cni/ rm -rf /var/lib/kubelet/* rm -rf /etc/cni/ ifconfig cni0 down ifconfig flannel.1 down ifconfig docker0 down ip link delete cni0 ip link delete flannel.1 ##重启kubelet systemctl restart kubelet ##重启docker systemctl restart docker 2.6.15 重启 kubelet 和 docker # 重启kubelet systemctl restart kubelet # 重启docker systemctl restart docker 使用配置文件启动 fannel\nkubectl apply -f kube-flannel.yml 等待它安装完毕 发现已经是 集群的状态已经是 Ready\n2.6.16 kubeadm 中的命令 # 生成 新的token [root@master ~]# kubeadm token create --print-join-command 2.7 集群测试 2.7.1 创建一个 nginx 服务 kubectl create deployment nginx --image=nginx:1.14-alpine 2.7.2 暴露端口 kubectl expose deploy nginx --port=80 --target-port=80 --type=NodePort 2.7.3 查看服务 kubectl get pod,svc 2.7.4 查看 pod 浏览器测试结果：\n3. 资源管理 3.1 资源管理介绍 在 kubernetes 中，所有的内容都抽象为资源，用户需要通过操作资源来管理 kubernetes。\nkubernetes 的本质上就是一个集群系统，用户可以在集群中部署各种服务，所谓的部署服务，其实就是在 kubernetes 集群中运行一个个的容器，并将指定的程序跑在容器中。\nkubernetes 的最小管理单元是 pod 而不是容器，所以只能将容器放在Pod中，而 kubernetes 一般也不会直接管理 Pod，而是通过Pod控制器来管理 Pod 的。\nPod 可以提供服务之后，就要考虑如何访问 Pod 中服务，kubernetes 提供了Service资源实现这个功能。\n当然，如果 Pod 中程序的数据需要持久化，kubernetes 还提供了各种存储系统。\n学习 kubernetes 的核心，就是学习如何对集群上的Pod、Pod控制器、Service、存储等各种资源进行操作\n3.2 YAML 语言介绍 YAML 是一个类似 XML、JSON 的标记性语言。它强调以数据为中心，并不是以标识语言为重点。因而 YAML 本身的定义比较简单，号称\u0026quot;一种人性化的数据格式语言\u0026quot;。\n\u0026lt;heima\u0026gt; \u0026lt;age\u0026gt;15\u0026lt;/age\u0026gt; \u0026lt;address\u0026gt;Beijing\u0026lt;/address\u0026gt; \u0026lt;/heima\u0026gt; heima: age: 15 address: Beijing YAML 的语法比较简单，主要有下面几个：\n大小写敏感 使用缩进表示层级关系 缩进不允许使用 tab，只允许空格( 低版本限制 ) 缩进的空格数不重要，只要相同层级的元素左对齐即可 \u0026lsquo;#\u0026lsquo;表示注释 YAML 支持以下几种数据类型：\n纯量：单个的、不可再分的值 对象：键值对的集合，又称为映射（mapping）/ 哈希（hash） / 字典（dictionary） 数组：一组按次序排列的值，又称为序列（sequence） / 列表（list） # 纯量, 就是指的一个简单的值，字符串、布尔值、整数、浮点数、Null、时间、日期 # 1 布尔类型 c1: true (或者True) # 2 整型 c2: 234 # 3 浮点型 c3: 3.14 # 4 null类型 c4: ~ # 使用~表示null # 5 日期类型 c5: 2018-02-17 # 日期必须使用ISO 8601格式，即yyyy-MM-dd # 6 时间类型 c6: 2018-02-17T15:02:31+08:00 # 时间使用ISO 8601格式，时间和日期之间使用T连接，最后使用+代表时区 # 7 字符串类型 c7: heima # 简单写法，直接写值 , 如果字符串中间有特殊字符，必须使用双引号或者单引号包裹 c8: line1 line2 # 字符串过多的情况可以拆成多行，每一行会被转化成一个空格 # 对象 # 形式一(推荐): heima: age: 15 address: Beijing # 形式二(了解): heima: {age: 15,address: Beijing} # 数组 # 形式一(推荐): address: - 顺义 - 昌平 # 形式二(了解): address: [顺义,昌平] 小提示：\n1 书写 yaml 切记: 后面要加一个空格\n2 如果需要将多段 yaml 配置放在一个文件中，中间要使用---分隔\n3 下面是一个 yaml 转 json 的网站，可以通过它验证 yaml 是否书写正确 https:/www.json2yaml.com/convert-yaml-to-json\r3.3 资源管理方式 命令式对象管理：直接使用命令去操作 kubernetes 资源\nkubectl run nginx-pod --image=nginx:1.17.1 --port=80 命令式对象配置：通过命令配置和配置文件去操作 kubernetes 资源\nkubectl create/patch -f nginx-pod.yaml 声明式对象配置：通过 apply 命令和配置文件去操作 kubernetes 资源\nkubectl apply -f nginx-pod.yaml 类型 操作对象 适用环境 优点 缺点 命令式对象管理 对象 测试 简单 只能操作活动对象，无法审计、跟踪 命令式对象配置 文件 开发 可以审计、跟踪 项目大时，配置文件多，操作麻烦 声明式对象配置 目录 开发 支持目录操作 意外情况下难以调试 3.3.1 命令式对象管理 kubectl 命令\nkubectl 是 kubernetes 集群的命令行工具，通过它能够对集群本身进行管理，并能够在集群上进行容器化应用的安装部署。kubectl 命令的语法如下：\nkubectl [command] [type] [name] [flags] comand：指定要对资源执行的操作，例如 create、get、delete\ntype：指定资源类型，比如 deployment、pod、service\nname：指定资源的名称，名称大小写敏感\nflags：指定额外的可选参数\n# 查看所有pod kubectl get pod # 查看某个pod kubectl get pod pod_name # 查看某个pod,以yaml格式展示结果 kubectl get pod pod_name -o yaml 资源类型\nkubernetes 中所有的内容都抽象为资源，可以通过下面的命令进行查看:\nkubectl api-resources 经常使用的资源有下面这些：\n资源分类 资源名称 缩写 资源作用 集群级别资源 nodes no 集群组成部分 namespaces ns 隔离 Pod pod 资源 pods po 装载容器 pod 资源控制器 replicationcontrollers rc 控制 pod 资源 replicasets rs 控制 pod 资源 deployments deploy 控制 pod 资源 daemonsets ds 控制 pod 资源 jobs 控制 pod 资源 cronjobs cj 控制 pod 资源 horizontalpodautoscalers hpa 控制 pod 资源 statefulsets sts 控制 pod 资源 服务发现资源 services svc 统一 pod 对外接口 ingress ing 统一 pod 对外接口 存储资源 volumeattachments 存储 persistentvolumes pv 存储 persistentvolumeclaims pvc 存储 配置资源 configmaps cm 配置 secrets 配置 操作\nkubernetes 允许对资源进行多种操作，可以通过\u0026ndash;help 查看详细的操作命令\nkubectl --help 经常使用的操作有下面这些：\n命令分类 命令 翻译 命令作用 基本命令 create 创建 创建一个资源 edit 编辑 编辑一个资源 get 获取 获取一个资源 patch 更新 更新一个资源 delete 删除 删除一个资源 explain 解释 展示资源文档 运行和调试 run 运行 在集群中运行一个指定的镜像 expose 暴露 暴露资源为 Service describe 描述 显示资源内部信息 logs 日志输出容器在 pod 中的日志 输出容器在 pod 中的日志 attach 缠绕进入运行中的容器 进入运行中的容器 exec 执行容器中的一个命令 执行容器中的一个命令 cp 复制 在 Pod 内外复制文件 rollout 首次展示 管理资源的发布 scale 规模 扩(缩)容 Pod 的数量 autoscale 自动调整 自动调整 Pod 的数量 高级命令 apply rc 通过文件对资源进行配置 label 标签 更新资源上的标签 其他命令 cluster-info 集群信息 显示集群信息 version 版本 显示当前 Server 和 Client 的版本 下面以一个 namespace / pod 的创建和删除简单演示下命令的使用：\n# 创建一个namespace [root@master ~]# kubectl create namespace dev namespace/dev created # 获取namespace [root@master ~]# kubectl get ns NAME STATUS AGE default Active 21h dev Active 21s kube-node-lease Active 21h kube-public Active 21h kube-system Active 21h # 在此namespace下创建并运行一个nginx的Pod [root@master ~]# kubectl run pod --image=nginx:latest -n dev kubectl run --generator=deployment/apps.v1 is DEPRECATED and will be removed in a future version. Use kubectl run --generator=run-pod/v1 or kubectl create instead. deployment.apps/pod created # 查看新创建的pod [root@master ~]# kubectl get pod -n dev NAME READY STATUS RESTARTS AGE pod 1/1 Running 0 21s # 删除指定的pod [root@master ~]# kubectl delete pod pod-864f9875b9-pcw7x pod \u0026#34;pod\u0026#34; deleted # 删除指定的namespace [root@master ~]# kubectl delete ns dev namespace \u0026#34;dev\u0026#34; deleted 3.3.2 命令式对象配置 命令式对象配置就是使用命令配合配置文件一起来操作 kubernetes 资源。\n1） 创建一个 nginxpod.yaml，内容如下：\napiVersion: v1 kind: Namespace metadata: name: dev --- apiVersion: v1 kind: Pod metadata: name: nginxpod namespace: dev spec: containers: - name: nginx-containers image: nginx:latest 2）执行 create 命令，创建资源：\n[root@master ~]# kubectl create -f nginxpod.yaml namespace/dev created pod/nginxpod created 此时发现创建了两个资源对象，分别是 namespace 和 pod\n3）执行 get 命令，查看资源：\n[root@master ~]# kubectl get -f nginxpod.yaml NAME STATUS AGE namespace/dev Active 18s NAME READY STATUS RESTARTS AGE pod/nginxpod 1/1 Running 0 17s 这样就显示了两个资源对象的信息\n4）执行 delete 命令，删除资源：\n[root@master ~]# kubectl delete -f nginxpod.yaml namespace \u0026#34;dev\u0026#34; deleted pod \u0026#34;nginxpod\u0026#34; deleted 此时发现两个资源对象被删除了\n总结: 命令式对象配置的方式操作资源，可以简单的认为：命令 + yaml配置文件（里面是命令需要的各种参数） 3.3.3 声明式对象配置 声明式对象配置跟命令式对象配置很相似，但是它只有一个命令 apply。\n# 首先执行一次kubectl apply -f yaml文件，发现创建了资源 [root@master ~]# kubectl apply -f nginxpod.yaml namespace/dev created pod/nginxpod created # 再次执行一次kubectl apply -f yaml文件，发现说资源没有变动 [root@master ~]# kubectl apply -f nginxpod.yaml namespace/dev unchanged pod/nginxpod unchanged 总结: 其实声明式对象配置就是使用apply描述一个资源最终的状态（在yaml中定义状态） 使用apply操作资源： 如果资源不存在，就创建，相当于 kubectl create 如果资源已存在，就更新，相当于 kubectl patch 扩展：kubectl 可以在 node 节点上运行吗 ?\nkubectl 的运行是需要进行配置的，它的配置文件是$HOME/.kube，如果想要在 node 节点运行此命令，需要将 master 上的.kube 文件复制到 node 节点上，即在 master 节点上执行下面操作：\nscp -r HOME/.kube node1: HOME/ 使用推荐: 三种方式应该怎么用 ?\n创建/更新资源 使用声明式对象配置 kubectl apply -f XXX.yaml\n删除资源 使用命令式对象配置 kubectl delete -f XXX.yaml\n查询资源 使用命令式对象管理 kubectl get(describe) 资源名称\n4. 实战入门 本章节将介绍如何在 kubernetes 集群中部署一个 nginx 服务，并且能够对其进行访问。\n4.1 Namespace Namespace 是 kubernetes 系统中的一种非常重要资源，它的主要作用是用来实现多套环境的资源隔离或者多租户的资源隔离。\n默认情况下，kubernetes 集群中的所有的 Pod 都是可以相互访问的。但是在实际中，可能不想让两个 Pod 之间进行互相的访问，那此时就可以将两个 Pod 划分到不同的 namespace 下。kubernetes 通过将集群内部的资源分配到不同的 Namespace 中，可以形成逻辑上的\u0026quot;组\u0026quot;，以方便不同的组的资源进行隔离使用和管理。\n可以通过 kubernetes 的授权机制，将不同的 namespace 交给不同租户进行管理，这样就实现了多租户的资源隔离。此时还能结合 kubernetes 的资源配额机制，限定不同租户能占用的资源，例如 CPU 使用量、内存使用量等等，来实现租户可用资源的管理。\nkubernetes 在集群启动之后，会默认创建几个 namespace\n[root@master ~]# kubectl get namespace NAME STATUS AGE default Active 45h # 所有未指定Namespace的对象都会被分配在default命名空间 kube-node-lease Active 45h # 集群节点之间的心跳维护，v1.13开始引入 kube-public Active 45h # 此命名空间下的资源可以被所有人访问（包括未认证用户） kube-system Active 45h # 所有由Kubernetes系统创建的资源都处于这个命名空间 下面来看 namespace 资源的具体操作：\n4.1.1 查看 # 1 查看所有的ns 命令：kubectl get ns [root@master ~]# kubectl get ns NAME STATUS AGE default Active 45h kube-node-lease Active 45h kube-public Active 45h kube-system Active 45h # 2 查看指定的ns 命令：kubectl get ns ns名称 [root@master ~]# kubectl get ns default NAME STATUS AGE default Active 45h # 3 指定输出格式 命令：kubectl get ns ns名称 -o 格式参数 # kubernetes支持的格式有很多，比较常见的是wide、json、yaml [root@master ~]# kubectl get ns default -o yaml apiVersion: v1 kind: Namespace metadata: creationTimestamp: \u0026#34;2021-05-08T04:44:16Z\u0026#34; name: default resourceVersion: \u0026#34;151\u0026#34; selfLink: /api/v1/namespaces/default uid: 7405f73a-e486-43d4-9db6-145f1409f090 spec: finalizers: - kubernetes status: phase: Active # 4 查看ns详情 命令：kubectl describe ns ns名称 [root@master ~]# kubectl describe ns default Name: default Labels: \u0026lt;none\u0026gt; Annotations: \u0026lt;none\u0026gt; Status: Active # Active 命名空间正在使用中 Terminating 正在删除命名空间 # ResourceQuota 针对namespace做的资源限制 # LimitRange针对namespace中的每个组件做的资源限制 No resource quota. No LimitRange resource. 4.1.2 创建 # 创建namespace [root@master ~]# kubectl create ns dev namespace/dev created 4.1.3 删除 # 删除namespace [root@master ~]# kubectl delete ns dev namespace \u0026#34;dev\u0026#34; deleted 4.1.4 配置方式 首先准备一个 yaml 文件：ns-dev.yaml\napiVersion: v1 kind: Namespace metadata: name: dev 然后就可以执行对应的创建和删除命令了：\n创建：kubectl create -f ns-dev.yaml\n删除：kubectl delete -f ns-dev.yaml\n4.2 Pod Pod 是 kubernetes 集群进行管理的最小单元，程序要运行必须部署在容器中，而容器必须存在于 Pod 中。\nPod 可以认为是容器的封装，一个 Pod 中可以存在一个或者多个容器。\nkubernetes 在集群启动之后，集群中的各个组件也都是以 Pod 方式运行的。可以通过下面命令查看：\n[root@master ~]# kubectl get pod -n kube-system NAMESPACE NAME READY STATUS RESTARTS AGE kube-system coredns-6955765f44-68g6v 1/1 Running 0 2d1h kube-system coredns-6955765f44-cs5r8 1/1 Running 0 2d1h kube-system etcd-master 1/1 Running 0 2d1h kube-system kube-apiserver-master 1/1 Running 0 2d1h kube-system kube-controller-manager-master 1/1 Running 0 2d1h kube-system kube-flannel-ds-amd64-47r25 1/1 Running 0 2d1h kube-system kube-flannel-ds-amd64-ls5lh 1/1 Running 0 2d1h kube-system kube-proxy-685tk 1/1 Running 0 2d1h kube-system kube-proxy-87spt 1/1 Running 0 2d1h kube-system kube-scheduler-master 1/1 Running 0 2d1h 4.2.1 创建并运行 kubernetes 没有提供单独运行 Pod 的命令，都是通过 Pod 控制器来实现的\n# 命令格式： kubectl run (pod控制器名称) [参数] # --image 指定Pod的镜像 # --port 指定端口 # --namespace 指定namespace [root@master ~]# kubectl run nginx --image=nginx:latest --port=80 --namespace dev deployment.apps/nginx created 4.2.2 查看 pod 信息 # 查看Pod基本信息 [root@master ~]# kubectl get pods -n dev NAME READY STATUS RESTARTS AGE nginx 1/1 Running 0 43s # 查看Pod的详细信息 [root@master ~]# kubectl describe pod nginx -n dev Name: nginx Namespace: dev Priority: 0 Node: node1/192.168.5.4 Start Time: Wed, 08 May 2021 09:29:24 +0800 Labels: pod-template-hash=5ff7956ff6 run=nginx Annotations: \u0026lt;none\u0026gt; Status: Running IP: 10.244.1.23 IPs: IP: 10.244.1.23 Controlled By: ReplicaSet/nginx Containers: nginx: Container ID: docker:/4c62b8c0648d2512380f4ffa5da2c99d16e05634979973449c98e9b829f6253c Image: nginx:latest Image ID: docker-pullable:/nginx@sha256:485b610fefec7ff6c463ced9623314a04ed67e3945b9c08d7e53a47f6d108dc7 Port: 80/TCP Host Port: 0/TCP State: Running Started: Wed, 08 May 2021 09:30:01 +0800 Ready: True Restart Count: 0 Environment: \u0026lt;none\u0026gt; Mounts: /var/run/secrets/kubernetes.io/serviceaccount from default-token-hwvvw (ro) Conditions: Type Status Initialized True Ready True ContainersReady True PodScheduled True Volumes: default-token-hwvvw: Type: Secret (a volume populated by a Secret) SecretName: default-token-hwvvw Optional: false QoS Class: BestEffort Node-Selectors: \u0026lt;none\u0026gt; Tolerations: node.kubernetes.io/not-ready:NoExecute for 300s node.kubernetes.io/unreachable:NoExecute for 300s Events: Type Reason Age From Message ---- ------ ---- ---- ------- Normal Scheduled \u0026lt;unknown\u0026gt; default-scheduler Successfully assigned dev/nginx-5ff7956ff6-fg2db to node1 Normal Pulling 4m11s kubelet, node1 Pulling image \u0026#34;nginx:latest\u0026#34; Normal Pulled 3m36s kubelet, node1 Successfully pulled image \u0026#34;nginx:latest\u0026#34; Normal Created 3m36s kubelet, node1 Created container nginx Normal Started 3m36s kubelet, node1 Started container nginx 4.2.3 访问 Pod # 获取podIP [root@master ~]# kubectl get pods -n dev -o wide NAME READY STATUS RESTARTS AGE IP NODE ... nginx 1/1 Running 0 190s 10.244.1.23 node1 ... #访问POD [root@master ~]# curl http:/10.244.1.23:80 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Welcome to nginx!\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;\u0026lt;em\u0026gt;Thank you for using nginx.\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 4.2.4 删除指定 Pod # 删除指定Pod [root@master ~]# kubectl delete pod nginx -n dev pod \u0026#34;nginx\u0026#34; deleted # 此时，显示删除Pod成功，但是再查询，发现又新产生了一个 [root@master ~]# kubectl get pods -n dev NAME READY STATUS RESTARTS AGE nginx 1/1 Running 0 21s # 这是因为当前Pod是由Pod控制器创建的，控制器会监控Pod状况，一旦发现Pod死亡，会立即重建 # 此时要想删除Pod，必须删除Pod控制器 # 先来查询一下当前namespace下的Pod控制器 [root@master ~]# kubectl get deploy -n dev NAME READY UP-TO-DATE AVAILABLE AGE nginx 1/1 1 1 9m7s # 接下来，删除此PodPod控制器 [root@master ~]# kubectl delete deploy nginx -n dev deployment.apps \u0026#34;nginx\u0026#34; deleted # 稍等片刻，再查询Pod，发现Pod被删除了 [root@master ~]# kubectl get pods -n dev No resources found in dev namespace. 4.2.5 配置操作 创建一个 pod-nginx.yaml，内容如下：\napiVersion: v1 kind: Pod metadata: name: nginx namespace: dev spec: containers: - image: nginx:latest name: pod ports: - name: nginx-port containerPort: 80 protocol: TCP 然后就可以执行对应的创建和删除命令了：\n创建：kubectl create -f pod-nginx.yaml\n删除：kubectl delete -f pod-nginx.yaml\n4.3 Label Label 是 kubernetes 系统中的一个重要概念。它的作用就是在资源上添加标识，用来对它们进行区分和选择。\nLabel 的特点：\n一个 Label 会以 key/value 键值对的形式附加到各种对象上，如 Node、Pod、Service 等等 一个资源对象可以定义任意数量的 Label ，同一个 Label 也可以被添加到任意数量的资源对象上去 Label 通常在资源对象定义时确定，当然也可以在对象创建后动态添加或者删除 可以通过 Label 实现资源的多维度分组，以便灵活、方便地进行资源分配、调度、配置、部署等管理工作。\n一些常用的 Label 示例如下：\n版本标签：\u0026ldquo;version\u0026rdquo;:\u0026ldquo;release\u0026rdquo;, \u0026ldquo;version\u0026rdquo;:\u0026ldquo;stable\u0026rdquo;\u0026hellip;\u0026hellip; 环境标签：\u0026ldquo;environment\u0026rdquo;:\u0026ldquo;dev\u0026rdquo;，\u0026ldquo;environment\u0026rdquo;:\u0026ldquo;test\u0026rdquo;，\u0026ldquo;environment\u0026rdquo;:\u0026ldquo;pro\u0026rdquo; 架构标签：\u0026ldquo;tier\u0026rdquo;:\u0026ldquo;frontend\u0026rdquo;，\u0026ldquo;tier\u0026rdquo;:\u0026ldquo;backend\u0026rdquo; 标签定义完毕之后，还要考虑到标签的选择，这就要使用到 Label Selector，即：\nLabel 用于给某个资源对象定义标识\nLabel Selector 用于查询和筛选拥有某些标签的资源对象\n当前有两种 Label Selector：\n基于等式的 Label Selector\nname = slave: 选择所有包含 Label 中 key=\u0026ldquo;name\u0026quot;且 value=\u0026ldquo;slave\u0026quot;的对象\nenv != production: 选择所有包括 Label 中的 key=\u0026ldquo;env\u0026quot;且 value 不等于\u0026quot;production\u0026quot;的对象\n基于集合的 Label Selector\nname in (master, slave): 选择所有包含 Label 中的 key=\u0026ldquo;name\u0026quot;且 value=\u0026ldquo;master\u0026quot;或\u0026quot;slave\u0026quot;的对象\nname not in (frontend): 选择所有包含 Label 中的 key=\u0026ldquo;name\u0026quot;且 value 不等于\u0026quot;frontend\u0026quot;的对象\n标签的选择条件可以使用多个，此时将多个 Label Selector 进行组合，使用逗号\u0026rdquo;,\u0026ldquo;进行分隔即可。例如：\nname=slave，env!=production\nname not in (frontend)，env!=production\n4.3.1 命令方式 # 为pod资源打标签 [root@master ~]# kubectl label pod nginx-pod version=1.0 -n dev pod/nginx-pod labeled # 为pod资源更新标签 [root@master ~]# kubectl label pod nginx-pod version=2.0 -n dev --overwrite pod/nginx-pod labeled # 查看标签 [root@master ~]# kubectl get pod nginx-pod -n dev --show-labels NAME READY STATUS RESTARTS AGE LABELS nginx-pod 1/1 Running 0 10m version=2.0 # 筛选标签 [root@master ~]# kubectl get pod -n dev -l version=2.0 --show-labels NAME READY STATUS RESTARTS AGE LABELS nginx-pod 1/1 Running 0 17m version=2.0 [root@master ~]# kubectl get pod -n dev -l version!=2.0 --show-labels No resources found in dev namespace. #删除标签 [root@master ~]# kubectl label pod nginx-pod -n dev tier- pod/nginx unlabeled 4.3.2 配置方式 apiVersion: v1 kind: Pod metadata: name: nginx namespace: dev labels: version: \u0026#34;3.0\u0026#34; env: \u0026#34;test\u0026#34; spec: containers: - image: nginx:latest name: pod ports: - name: nginx-port containerPort: 80 protocol: TCP 然后就可以执行对应的更新命令了：kubectl apply -f pod-nginx.yaml\n4.4 Deployment 在 kubernetes 中，Pod 是最小的控制单元，但是 kubernetes 很少直接控制 Pod，一般都是通过 Pod 控制器来完成的。Pod 控制器用于 pod 的管理，确保 pod 资源符合预期的状态，当 pod 的资源出现故障时，会尝试进行重启或重建 pod。\n在 kubernetes 中 Pod 控制器的种类有很多，本章节只介绍一种：Deployment。\n4.4.1 命令操作 # 命令格式: kubectl create deployment 名称 [参数] # --image 指定pod的镜像 # --port 指定端口 # --replicas 指定创建pod数量 # --namespace 指定namespace [root@master ~]# kubectl run nginx --image=nginx:latest --port=80 --replicas=3 -n dev deployment.apps/nginx created # 查看创建的Pod [root@master ~]# kubectl get pods -n dev NAME READY STATUS RESTARTS AGE nginx-5ff7956ff6-6k8cb 1/1 Running 0 19s nginx-5ff7956ff6-jxfjt 1/1 Running 0 19s nginx-5ff7956ff6-v6jqw 1/1 Running 0 19s # 查看deployment的信息 [root@master ~]# kubectl get deploy -n dev NAME READY UP-TO-DATE AVAILABLE AGE nginx 3/3 3 3 2m42s # UP-TO-DATE：成功升级的副本数量 # AVAILABLE：可用副本的数量 [root@master ~]# kubectl get deploy -n dev -o wide NAME READY UP-TO-DATE AVAILABLE AGE CONTAINERS IMAGES SELECTOR nginx 3/3 3 3 2m51s nginx nginx:latest run=nginx # 查看deployment的详细信息 [root@master ~]# kubectl describe deploy nginx -n dev Name: nginx Namespace: dev CreationTimestamp: Wed, 08 May 2021 11:14:14 +0800 Labels: run=nginx Annotations: deployment.kubernetes.io/revision: 1 Selector: run=nginx Replicas: 3 desired | 3 updated | 3 total | 3 available | 0 unavailable StrategyType: RollingUpdate MinReadySeconds: 0 RollingUpdateStrategy: 25% max unavailable, 25% max 违规词汇 Pod Template: Labels: run=nginx Containers: nginx: Image: nginx:latest Port: 80/TCP Host Port: 0/TCP Environment: \u0026lt;none\u0026gt; Mounts: \u0026lt;none\u0026gt; Volumes: \u0026lt;none\u0026gt; Conditions: Type Status Reason ---- ------ ------ Available True MinimumReplicasAvailable Progressing True NewReplicaSetAvailable OldReplicaSets: \u0026lt;none\u0026gt; NewReplicaSet: nginx-5ff7956ff6 (3/3 replicas created) Events: Type Reason Age From Message ---- ------ ---- ---- ------- Normal ScalingReplicaSet 5m43s deployment-controller Scaled up replicaset nginx-5ff7956ff6 to 3 # 删除 [root@master ~]# kubectl delete deploy nginx -n dev deployment.apps \u0026#34;nginx\u0026#34; deleted 4.4.2 配置操作 创建一个 deploy-nginx.yaml，内容如下：\napiVersion: apps/v1 kind: Deployment metadata: name: nginx namespace: dev spec: replicas: 3 selector: matchLabels: run: nginx template: metadata: labels: run: nginx spec: containers: - image: nginx:latest name: nginx ports: - containerPort: 80 protocol: TCP 然后就可以执行对应的创建和删除命令了：\n创建：kubectl create -f deploy-nginx.yaml\n删除：kubectl delete -f deploy-nginx.yaml\n4.5 Service 通过上节课的学习，已经能够利用 Deployment 来创建一组 Pod 来提供具有高可用性的服务。\n虽然每个 Pod 都会分配一个单独的 Pod IP，然而却存在如下两问题：\nPod IP 会随着 Pod 的重建产生变化 Pod IP 仅仅是集群内可见的虚拟 IP，外部无法访问 这样对于访问这个服务带来了难度。因此，kubernetes 设计了 Service 来解决这个问题。\nService 可以看作是一组同类 Pod 对外的访问接口。借助 Service，应用可以方便地实现服务发现和负载均衡。\n4.5.1 创建集群内部可访问的 Service # 暴露Service [root@master ~]# kubectl expose deploy nginx --name=svc-nginx1 --type=ClusterIP --port=80 --target-port=80 -n dev service/svc-nginx1 exposed # 查看service [root@master ~]# kubectl get svc svc-nginx1 -n dev -o wide NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE SELECTOR svc-nginx1 ClusterIP 10.109.179.231 \u0026lt;none\u0026gt; 80/TCP 3m51s run=nginx # 这里产生了一个CLUSTER-IP，这就是service的IP，在Service的生命周期中，这个地址是不会变动的 # 可以通过这个IP访问当前service对应的POD [root@master ~]# curl 10.109.179.231:80 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Welcome to nginx!\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Welcome to nginx!\u0026lt;/h1\u0026gt; ....... \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 4.5.2 创建集群外部也可访问的 Service # 上面创建的Service的type类型为ClusterIP，这个ip地址只用集群内部可访问 # 如果需要创建外部也可以访问的Service，需要修改type为NodePort [root@master ~]# kubectl expose deploy nginx --name=svc-nginx2 --type=NodePort --port=80 --target-port=80 -n dev service/svc-nginx2 exposed # 此时查看，会发现出现了NodePort类型的Service，而且有一对Port（80:31928/TC） [root@master ~]# kubectl get svc svc-nginx2 -n dev -o wide NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE SELECTOR svc-nginx2 NodePort 10.100.94.0 \u0026lt;none\u0026gt; 80:31928/TCP 9s run=nginx # 接下来就可以通过集群外的主机访问 节点IP:31928访问服务了 # 例如在的电脑主机上通过浏览器访问下面的地址 http:/192.168.90.100:31928/ 4.5.3 删除 Service [root@master ~]# kubectl delete svc svc-nginx-1 -n dev service \u0026#34;svc-nginx-1\u0026#34; deleted 4.5.4 配置方式 创建一个 svc-nginx.yaml，内容如下：\napiVersion: v1 kind: Service metadata: name: svc-nginx namespace: dev spec: clusterIP: 10.109.179.231 #固定svc的内网ip ports: - port: 80 protocol: TCP targetPort: 80 selector: run: nginx type: ClusterIP 然后就可以执行对应的创建和删除命令了：\n创建：kubectl create -f svc-nginx.yaml\n删除：kubectl delete -f svc-nginx.yaml\n小结\n至此，已经掌握了 Namespace、Pod、Deployment、Service 资源的基本操作，有了这些操作，就可以在 kubernetes 集群中实现一个服务的简单部署和访问了，但是如果想要更好的使用 kubernetes，就需要深入学习这几种资源的细节和原理。\n5. Pod 详解 5.1 Pod 介绍 5.1.1 Pod 结构 每个 Pod 中都可以包含一个或者多个容器，这些容器可以分为两类：\n用户程序所在的容器，数量可多可少\nPause 容器，这是每个 Pod 都会有的一个根容器，它的作用有两个：\n可以以它为依据，评估整个 Pod 的健康状态\n可以在根容器上设置 Ip 地址，其它容器都此 Ip（Pod IP），以实现 Pod 内部的网路通信\n这里是Pod内部的通讯，Pod的之间的通讯采用虚拟二层网络技术来实现，我们当前环境用的是Flannel 5.1.2 Pod 定义 下面是 Pod 的资源清单：\napiVersion: v1 #必选，版本号，例如v1 kind: Pod #必选，资源类型，例如 Pod metadata: #必选，元数据 name: string #必选，Pod名称 namespace: string #Pod所属的命名空间,默认为\u0026#34;default\u0026#34; labels: #自定义标签列表 - name: string spec: #必选，Pod中容器的详细定义 containers: #必选，Pod中容器列表 - name: string #必选，容器名称 image: string #必选，容器的镜像名称 imagePullPolicy: [ Always|Never|IfNotPresent ] #获取镜像的策略 command: [string] #容器的启动命令列表，如不指定，使用打包时使用的启动命令 args: [string] #容器的启动命令参数列表 workingDir: string #容器的工作目录 volumeMounts: #挂载到容器内部的存储卷配置 - name: string #引用pod定义的共享存储卷的名称，需用volumes[]部分定义的的卷名 mountPath: string #存储卷在容器内mount的绝对路径，应少于512字符 readOnly: boolean #是否为只读模式 ports: #需要暴露的端口库号列表 - name: string #端口的名称 containerPort: int #容器需要监听的端口号 hostPort: int #容器所在主机需要监听的端口号，默认与Container相同 protocol: string #端口协议，支持TCP和UDP，默认TCP env: #容器运行前需设置的环境变量列表 - name: string #环境变量名称 value: string #环境变量的值 resources: #资源限制和请求的设置 limits: #资源限制的设置 cpu: string #Cpu的限制，单位为core数，将用于docker run --cpu-shares参数 memory: string #内存限制，单位可以为Mib/Gib，将用于docker run --memory参数 requests: #资源请求的设置 cpu: string #Cpu请求，容器启动的初始可用数量 memory: string #内存请求,容器启动的初始可用数量 lifecycle: #生命周期钩子 postStart: #容器启动后立即执行此钩子,如果执行失败,会根据重启策略进行重启 preStop: #容器终止前执行此钩子,无论结果如何,容器都会终止 livenessProbe: #对Pod内各容器健康检查的设置，当探测无响应几次后将自动重启该容器 exec: #对Pod容器内检查方式设置为exec方式 command: [string] #exec方式需要制定的命令或脚本 httpGet: #对Pod内个容器健康检查方法设置为HttpGet，需要制定Path、port path: string port: number host: string scheme: string HttpHeaders: - name: string value: string tcpSocket: #对Pod内个容器健康检查方式设置为tcpSocket方式 port: number initialDelaySeconds: 0 #容器启动完成后首次探测的时间，单位为秒 timeoutSeconds: 0 #对容器健康检查探测等待响应的超时时间，单位秒，默认1秒 periodSeconds: 0 #对容器监控检查的定期探测时间设置，单位秒，默认10秒一次 successThreshold: 0 failureThreshold: 0 securityContext: privileged: false restartPolicy: [Always | Never | OnFailure] #Pod的重启策略 nodeName: \u0026lt;string\u0026gt; #设置NodeName表示将该Pod调度到指定到名称的node节点上 nodeSelector: obeject #设置NodeSelector表示将该Pod调度到包含这个label的node上 imagePullSecrets: #Pull镜像时使用的secret名称，以key：secretkey格式指定 - name: string hostNetwork: false #是否使用主机网络模式，默认为false，如果设置为true，表示使用宿主机网络 volumes: #在该pod上定义共享存储卷列表 - name: string #共享存储卷名称 （volumes类型有很多种） emptyDir: {} #类型为emtyDir的存储卷，与Pod同生命周期的一个临时目录。为空值 hostPath: string #类型为hostPath的存储卷，表示挂载Pod所在宿主机的目录 path: string #Pod所在宿主机的目录，将被用于同期中mount的目录 secret: #类型为secret的存储卷，挂载集群与定义的secret对象到容器内部 scretname: string items: - key: string path: string configMap: #类型为configMap的存储卷，挂载预定义的configMap对象到容器内部 name: string items: - key: string path: string #小提示： # 在这里，可通过一个命令来查看每种资源的可配置项 # kubectl explain 资源类型 查看某种资源可以配置的一级属性 # kubectl explain 资源类型.属性 查看属性的子属性 [root@k8s-master01 ~]# kubectl explain pod KIND: Pod VERSION: v1 FIELDS: apiVersion \u0026lt;string\u0026gt; kind \u0026lt;string\u0026gt; metadata \u0026lt;Object\u0026gt; spec \u0026lt;Object\u0026gt; status \u0026lt;Object\u0026gt; [root@k8s-master01 ~]# kubectl explain pod.metadata KIND: Pod VERSION: v1 RESOURCE: metadata \u0026lt;Object\u0026gt; FIELDS: annotations \u0026lt;map[string]string\u0026gt; clusterName \u0026lt;string\u0026gt; creationTimestamp \u0026lt;string\u0026gt; deletionGracePeriodSeconds \u0026lt;integer\u0026gt; deletionTimestamp \u0026lt;string\u0026gt; finalizers \u0026lt;[]string\u0026gt; generateName \u0026lt;string\u0026gt; generation \u0026lt;integer\u0026gt; labels \u0026lt;map[string]string\u0026gt; managedFields \u0026lt;[]Object\u0026gt; name \u0026lt;string\u0026gt; namespace \u0026lt;string\u0026gt; ownerReferences \u0026lt;[]Object\u0026gt; resourceVersion \u0026lt;string\u0026gt; selfLink \u0026lt;string\u0026gt; uid \u0026lt;string\u0026gt; 在 kubernetes 中基本所有资源的一级属性都是一样的，主要包含 5 部分：\n- apiVersion \u0026lt;string\u0026gt; 版本，由kubernetes内部定义，版本号必须可以用 kubectl api-versions 查询到 - kind \u0026lt;string\u0026gt; 类型，由kubernetes内部定义，版本号必须可以用 kubectl api-resources 查询到 - metadata \u0026lt;Object\u0026gt; 元数据，主要是资源标识和说明，常用的有name、namespace、labels等 - spec \u0026lt;Object\u0026gt; 描述，这是配置中最重要的一部分，里面是对各种资源配置的详细描述 - status \u0026lt;Object\u0026gt; 状态信息，里面的内容不需要定义，由kubernetes自动生成 在上面的属性中，spec 是接下来研究的重点，继续看下它的常见子属性:\n- containers \u0026lt;[]Object\u0026gt; 容器列表，用于定义容器的详细信息 - nodeName \u0026lt;String\u0026gt; 根据nodeName的值将pod调度到指定的Node节点上 - nodeSelector \u0026lt;map[]\u0026gt; 根据NodeSelector中定义的信息选择将该Pod调度到包含这些label的Node 上 - hostNetwork \u0026lt;boolean\u0026gt; 是否使用主机网络模式，默认为false，如果设置为true，表示使用宿主机网络 - volumes \u0026lt;[]Object\u0026gt; 存储卷，用于定义Pod上面挂在的存储信息 - restartPolicy \u0026lt;string\u0026gt; 重启策略，表示Pod在遇到故障的时候的处理策略 5.2 Pod 配置 本小节主要来研究pod.spec.containers属性，这也是 pod 配置中最为关键的一项配置。\n[root@k8s-master01 ~]# kubectl explain pod.spec.containers KIND: Pod VERSION: v1 RESOURCE: containers \u0026lt;[]Object\u0026gt; # 数组，代表可以有多个容器 FIELDS: name \u0026lt;string\u0026gt; # 容器名称 image \u0026lt;string\u0026gt; # 容器需要的镜像地址 imagePullPolicy \u0026lt;string\u0026gt; # 镜像拉取策略 command \u0026lt;[]string\u0026gt; # 容器的启动命令列表，如不指定，使用打包时使用的启动命令 args \u0026lt;[]string\u0026gt; # 容器的启动命令需要的参数列表 env \u0026lt;[]Object\u0026gt; # 容器环境变量的配置 ports \u0026lt;[]Object\u0026gt; # 容器需要暴露的端口号列表 resources \u0026lt;Object\u0026gt; # 资源限制和资源请求的设置 5.2.1 基本配置 创建 pod-base.yaml 文件，内容如下：\napiVersion: v1 kind: Pod metadata: name: pod-base namespace: dev labels: user: heima spec: containers: - name: nginx image: nginx:1.17.1 - name: busybox image: busybox:1.30 上面定义了一个比较简单 Pod 的配置，里面有两个容器：\nnginx：用 1.17.1 版本的 nginx 镜像创建，（nginx 是一个轻量级 web 容器） busybox：用 1.30 版本的 busybox 镜像创建，（busybox 是一个小巧的 linux 命令集合） # 创建Pod [root@k8s-master01 pod]# kubectl apply -f pod-base.yaml pod/pod-base created # 查看Pod状况 # READY 1/2 : 表示当前Pod中有2个容器，其中1个准备就绪，1个未就绪 # RESTARTS : 重启次数，因为有1个容器故障了，Pod一直在重启试图恢复它 [root@k8s-master01 pod]# kubectl get pod -n dev NAME READY STATUS RESTARTS AGE pod-base 1/2 Running 4 95s # 可以通过describe查看内部的详情 # 此时已经运行起来了一个基本的Pod，虽然它暂时有问题 [root@k8s-master01 pod]# kubectl describe pod pod-base -n dev 5.2.2 镜像拉取 创建 pod-imagepullpolicy.yaml 文件，内容如下：\napiVersion: v1 kind: Pod metadata: name: pod-imagepullpolicy namespace: dev spec: containers: - name: nginx image: nginx:1.17.1 imagePullPolicy: Never # 用于设置镜像拉取策略 - name: busybox image: busybox:1.30 imagePullPolicy，用于设置镜像拉取策略，kubernetes 支持配置三种拉取策略：\nAlways：总是从远程仓库拉取镜像（一直远程下载） IfNotPresent：本地有则使用本地镜像，本地没有则从远程仓库拉取镜像（本地有就本地 本地没远程下载） Never：只使用本地镜像，从不去远程仓库拉取，本地没有就报错 （一直使用本地） 默认值说明：\n如果镜像 tag 为具体版本号， 默认策略是：IfNotPresent\n如果镜像 tag 为：latest（最终版本） ，默认策略是 always\n# 创建Pod [root@k8s-master01 pod]# kubectl create -f pod-imagepullpolicy.yaml pod/pod-imagepullpolicy created # 查看Pod详情 # 此时明显可以看到nginx镜像有一步Pulling image \u0026#34;nginx:1.17.1\u0026#34;的过程 [root@k8s-master01 pod]# kubectl describe pod pod-imagepullpolicy -n dev ...... Events: Type Reason Age From Message ---- ------ ---- ---- ------- Normal Scheduled \u0026lt;unknown\u0026gt; default-scheduler Successfully assigned dev/pod-imagePullPolicy to node1 Normal Pulling 32s kubelet, node1 Pulling image \u0026#34;nginx:1.17.1\u0026#34; Normal Pulled 26s kubelet, node1 Successfully pulled image \u0026#34;nginx:1.17.1\u0026#34; Normal Created 26s kubelet, node1 Created container nginx Normal Started 25s kubelet, node1 Started container nginx Normal Pulled 7s (x3 over 25s) kubelet, node1 Container image \u0026#34;busybox:1.30\u0026#34; already present on machine Normal Created 7s (x3 over 25s) kubelet, node1 Created container busybox Normal Started 7s (x3 over 25s) kubelet, node1 Started container busybox 5.2.3 启动命令 在前面的案例中，一直有一个问题没有解决，就是的 busybox 容器一直没有成功运行，那么到底是什么原因导致这个容器的故障呢？\n原来 busybox 并不是一个程序，而是类似于一个工具类的集合，kubernetes 集群启动管理后，它会自动关闭。解决方法就是让其一直在运行，这就用到了 command 配置。\n创建 pod-command.yaml 文件，内容如下：\napiVersion: v1 kind: Pod metadata: name: pod-command namespace: dev spec: containers: - name: nginx image: nginx:1.17.1 - name: busybox image: busybox:1.30 command: [ \u0026#34;/bin/sh\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;touch /tmp/hello.txt;while true;do /bin/echo $(date +%T) \u0026gt;\u0026gt; /tmp/hello.txt; sleep 3; done;\u0026#34;, ] command，用于在 pod 中的容器初始化完毕之后运行一个命令。\n稍微解释下上面命令的意思：\n\u0026ldquo;/bin/sh\u0026rdquo;,\u0026quot;-c\u0026rdquo;, 使用 sh 执行命令\ntouch /tmp/hello.txt; 创建一个/tmp/hello.txt 文件\nwhile true;do /bin/echo $(date +%T) \u0026raquo; /tmp/hello.txt; sleep 3; done; 每隔 3 秒向文件中写入当前时间\n# 创建Pod [root@k8s-master01 pod]# kubectl create -f pod-command.yaml pod/pod-command created # 查看Pod状态 # 此时发现两个pod都正常运行了 [root@k8s-master01 pod]# kubectl get pods pod-command -n dev NAME READY STATUS RESTARTS AGE pod-command 2/2 Runing 0 2s # 进入pod中的busybox容器，查看文件内容 # 补充一个命令: kubectl exec pod名称 -n 命名空间 -it -c 容器名称 /bin/sh 在容器内部执行命令 # 使用这个命令就可以进入某个容器的内部，然后进行相关操作了 # 比如，可以查看txt文件的内容 [root@k8s-master01 pod]# kubectl exec pod-command -n dev -it -c busybox /bin/sh / # tail -f /tmp/hello.txt 14:44:19 14:44:22 14:44:25 特别说明： 通过上面发现command已经可以完成启动命令和传递参数的功能，为什么这里还要提供一个args选项，用于传递参数呢?这其实跟docker有点关系，kubernetes中的command、args两项其实是实现覆盖Dockerfile中ENTRYPOINT的功能。 1 如果command和args均没有写，那么用Dockerfile的配置。 2 如果command写了，但args没有写，那么Dockerfile默认的配置会被忽略，执行输入的command 3 如果command没写，但args写了，那么Dockerfile中配置的ENTRYPOINT的命令会被执行，使用当前args的参数 4 如果command和args都写了，那么Dockerfile的配置被忽略，执行command并追加上args参数 5.2.4 环境变量 创建 pod-env.yaml 文件，内容如下：\napiVersion: v1 kind: Pod metadata: name: pod-env namespace: dev spec: containers: - name: busybox image: busybox:1.30 command: [\u0026#34;/bin/sh\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;while true;do /bin/echo $(date +%T);sleep 60; done;\u0026#34;] env: # 设置环境变量列表 - name: \u0026#34;username\u0026#34; value: \u0026#34;admin\u0026#34; - name: \u0026#34;password\u0026#34; value: \u0026#34;123456\u0026#34; env，环境变量，用于在 pod 中的容器设置环境变量。\n# 创建Pod [root@k8s-master01 ~]# kubectl create -f pod-env.yaml pod/pod-env created # 进入容器，输出环境变量 [root@k8s-master01 ~]# kubectl exec pod-env -n dev -c busybox -it /bin/sh / # echo $username admin / # echo $password 123456 这种方式不是很推荐，推荐将这些配置单独存储在配置文件中，这种方式将在后面介绍。\n5.2.5 端口设置 本小节来介绍容器的端口设置，也就是 containers 的 ports 选项。\n首先看下 ports 支持的子选项：\n[root@k8s-master01 ~]# kubectl explain pod.spec.containers.ports KIND: Pod VERSION: v1 RESOURCE: ports \u0026lt;[]Object\u0026gt; FIELDS: name \u0026lt;string\u0026gt; # 端口名称，如果指定，必须保证name在pod中是唯一的 containerPort\u0026lt;integer\u0026gt; # 容器要监听的端口(0\u0026lt;x\u0026lt;65536) hostPort \u0026lt;integer\u0026gt; # 容器要在主机上公开的端口，如果设置，主机上只能运行容器的一个副本(一般省略) hostIP \u0026lt;string\u0026gt; # 要将外部端口绑定到的主机IP(一般省略) protocol \u0026lt;string\u0026gt; # 端口协议。必须是UDP、TCP或SCTP。默认为“TCP”。 接下来，编写一个测试案例，创建 pod-ports.yaml\napiVersion: v1 kind: Pod metadata: name: pod-ports namespace: dev spec: containers: - name: nginx image: nginx:1.17.1 ports: # 设置容器暴露的端口列表 - name: nginx-port containerPort: 80 protocol: TCP # 创建Pod [root@k8s-master01 ~]# kubectl create -f pod-ports.yaml pod/pod-ports created # 查看pod # 在下面可以明显看到配置信息 [root@k8s-master01 ~]# kubectl get pod pod-ports -n dev -o yaml ...... spec: containers: - image: nginx:1.17.1 imagePullPolicy: IfNotPresent name: nginx ports: - containerPort: 80 name: nginx-port protocol: TCP ...... 访问容器中的程序需要使用的是Podip:containerPort\n5.2.6 资源配额 容器中的程序要运行，肯定是要占用一定资源的，比如 cpu 和内存等，如果不对某个容器的资源做限制，那么它就可能吃掉大量资源，导致其它容器无法运行。针对这种情况，kubernetes 提供了对内存和 cpu 的资源进行配额的机制，这种机制主要通过 resources 选项实现，他有两个子选项：\nlimits：用于限制运行时容器的最大占用资源，当容器占用资源超过 limits 时会被终止，并进行重启 requests ：用于设置容器需要的最小资源，如果环境资源不够，容器将无法启动 可以通过上面两个选项设置资源的上下限。\n接下来，编写一个测试案例，创建 pod-resources.yaml\napiVersion: v1 kind: Pod metadata: name: pod-resources namespace: dev spec: containers: - name: nginx image: nginx:1.17.1 resources: # 资源配额 limits: # 限制资源（上限） cpu: \u0026#34;2\u0026#34; # CPU限制，单位是core数 memory: \u0026#34;10Gi\u0026#34; # 内存限制 requests: # 请求资源（下限） cpu: \u0026#34;1\u0026#34; # CPU限制，单位是core数 memory: \u0026#34;10Mi\u0026#34; # 内存限制 在这对 cpu 和 memory 的单位做一个说明：\ncpu：core 数，可以为整数或小数 memory： 内存大小，可以使用 Gi、Mi、G、M 等形式 # 运行Pod [root@k8s-master01 ~]# kubectl create -f pod-resources.yaml pod/pod-resources created # 查看发现pod运行正常 [root@k8s-master01 ~]# kubectl get pod pod-resources -n dev NAME READY STATUS RESTARTS AGE pod-resources 1/1 Running 0 39s # 接下来，停止Pod [root@k8s-master01 ~]# kubectl delete -f pod-resources.yaml pod \u0026#34;pod-resources\u0026#34; deleted # 编辑pod，修改resources.requests.memory的值为10Gi [root@k8s-master01 ~]# vim pod-resources.yaml # 再次启动pod [root@k8s-master01 ~]# kubectl create -f pod-resources.yaml pod/pod-resources created # 查看Pod状态，发现Pod启动失败 [root@k8s-master01 ~]# kubectl get pod pod-resources -n dev -o wide NAME READY STATUS RESTARTS AGE pod-resources 0/1 Pending 0 20s # 查看pod详情会发现，如下提示 [root@k8s-master01 ~]# kubectl describe pod pod-resources -n dev ...... Warning FailedScheduling 35s default-scheduler 0/3 nodes are available: 1 node(s) had taint {node-role.kubernetes.io/master: }, that the pod didn\u0026#39;t tolerate, 2 Insufficient memory.(内存不足) 5.3 Pod 生命周期 我们一般将 pod 对象从创建至终的这段时间范围称为 pod 的生命周期，它主要包含下面的过程：\npod 创建过程 运行初始化容器（init container）过程 运行主容器（main container） 容器启动后钩子（post start）、容器终止前钩子（pre stop） 容器的存活性探测（liveness probe）、就绪性探测（readiness probe） pod 终止过程 在整个生命周期中，Pod 会出现 5 种状态（相位），分别如下：\n挂起（Pending）：apiserver 已经创建了 pod 资源对象，但它尚未被调度完成或者仍处于下载镜像的过程中 运行中（Running）：pod 已经被调度至某节点，并且所有容器都已经被 kubelet 创建完成 成功（Succeeded）：pod 中的所有容器都已经成功终止并且不会被重启 失败（Failed）：所有容器都已经终止，但至少有一个容器终止失败，即容器返回了非 0 值的退出状态 未知（Unknown）：apiserver 无法正常获取到 pod 对象的状态信息，通常由网络通信失败所导致 5.3.1 创建和终止 pod 的创建过程\n用户通过 kubectl 或其他 api 客户端提交需要创建的 pod 信息给 apiServer\napiServer 开始生成 pod 对象的信息，并将信息存入 etcd，然后返回确认信息至客户端\napiServer 开始反映 etcd 中的 pod 对象的变化，其它组件使用 watch 机制来跟踪检查 apiServer 上的变动\nscheduler 发现有新的 pod 对象要创建，开始为 Pod 分配主机并将结果信息更新至 apiServer\nnode 节点上的 kubelet 发现有 pod 调度过来，尝试调用 docker 启动容器，并将结果回送至 apiServer\napiServer 将接收到的 pod 状态信息存入 etcd 中\npod 的终止过程\n用户向 apiServer 发送删除 pod 对象的命令 apiServcer 中的 pod 对象信息会随着时间的推移而更新，在宽限期内（默认 30s），pod 被视为 dead 将 pod 标记为 terminating 状态 kubelet 在监控到 pod 对象转为 terminating 状态的同时启动 pod 关闭过程 端点控制器监控到 pod 对象的关闭行为时将其从所有匹配到此端点的 service 资源的端点列表中移除 如果当前 pod 对象定义了 preStop 钩子处理器，则在其标记为 terminating 后即会以同步的方式启动执行 pod 对象中的容器进程收到停止信号 宽限期结束后，若 pod 中还存在仍在运行的进程，那么 pod 对象会收到立即终止的信号 kubelet 请求 apiServer 将此 pod 资源的宽限期设置为 0 从而完成删除操作，此时 pod 对于用户已不可见 5.3.2 初始化容器 初始化容器是在 pod 的主容器启动之前要运行的容器，主要是做一些主容器的前置工作，它具有两大特征：\n初始化容器必须运行完成直至结束，若某初始化容器运行失败，那么 kubernetes 需要重启它直到成功完成 初始化容器必须按照定义的顺序执行，当且仅当前一个成功之后，后面的一个才能运行 初始化容器有很多的应用场景，下面列出的是最常见的几个：\n提供主容器镜像中不具备的工具程序或自定义代码 初始化容器要先于应用容器串行启动并运行完成，因此可用于延后应用容器的启动直至其依赖的条件得到满足 接下来做一个案例，模拟下面这个需求：\n假设要以主容器来运行 nginx，但是要求在运行 nginx 之前先要能够连接上 mysql 和 redis 所在服务器\n为了简化测试，事先规定好 mysql(192.168.90.14)和 redis(192.168.90.15)服务器的地址\n创建 pod-initcontainer.yaml，内容如下：\napiVersion: v1 kind: Pod metadata: name: pod-initcontainer namespace: dev spec: containers: - name: main-container image: nginx:1.17.1 ports: - name: nginx-port containerPort: 80 initContainers: - name: test-mysql image: busybox:1.30 command: [ \u0026#34;sh\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;until ping 192.168.90.14 -c 1 ; do echo waiting for mysql...; sleep 2; done;\u0026#34;, ] - name: test-redis image: busybox:1.30 command: [ \u0026#34;sh\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;until ping 192.168.90.15 -c 1 ; do echo waiting for reids...; sleep 2; done;\u0026#34;, ] # 创建pod [root@k8s-master01 ~]# kubectl create -f pod-initcontainer.yaml pod/pod-initcontainer created # 查看pod状态 # 发现pod卡在启动第一个初始化容器过程中，后面的容器不会运行 root@k8s-master01 ~]# kubectl describe pod pod-initcontainer -n dev ........ Events: Type Reason Age From Message ---- ------ ---- ---- ------- Normal Scheduled 49s default-scheduler Successfully assigned dev/pod-initcontainer to node1 Normal Pulled 48s kubelet, node1 Container image \u0026#34;busybox:1.30\u0026#34; already present on machine Normal Created 48s kubelet, node1 Created container test-mysql Normal Started 48s kubelet, node1 Started container test-mysql # 动态查看pod [root@k8s-master01 ~]# kubectl get pods pod-initcontainer -n dev -w NAME READY STATUS RESTARTS AGE pod-initcontainer 0/1 Init:0/2 0 15s pod-initcontainer 0/1 Init:1/2 0 52s pod-initcontainer 0/1 Init:1/2 0 53s pod-initcontainer 0/1 PodInitializing 0 89s pod-initcontainer 1/1 Running 0 90s # 接下来新开一个shell，为当前服务器新增两个ip，观察pod的变化 [root@k8s-master01 ~]# ifconfig ens33:1 192.168.90.14 netmask 255.255.255.0 up [root@k8s-master01 ~]# ifconfig ens33:2 192.168.90.15 netmask 255.255.255.0 up 5.3.3 钩子函数 钩子函数能够感知自身生命周期中的事件，并在相应的时刻到来时运行用户指定的程序代码。\nkubernetes 在主容器的启动之后和停止之前提供了两个钩子函数：\npost start：容器创建之后执行，如果失败了会重启容器 pre stop ：容器终止之前执行，执行完成之后容器将成功终止，在其完成之前会阻塞删除容器的操作 钩子处理器支持使用下面三种方式定义动作：\nExec 命令：在容器内执行一次命令\n…… lifecycle: postStart: exec: command: - cat - /tmp/healthy …… TCPSocket：在当前容器尝试访问指定的 socket\n…… lifecycle: postStart: tcpSocket: port: 8080 …… HTTPGet：在当前容器中向某 url 发起 http 请求\n…… lifecycle: postStart: httpGet: path: / #URI地址 port: 80 #端口号 host: 192.168.5.3 #主机地址 scheme: HTTP #支持的协议，http或者https …… 接下来，以 exec 方式为例，演示下钩子函数的使用，创建 pod-hook-exec.yaml 文件，内容如下：\napiVersion: v1 kind: Pod metadata: name: pod-hook-exec namespace: dev spec: containers: - name: main-container image: nginx:1.17.1 ports: - name: nginx-port containerPort: 80 lifecycle: postStart: exec: # 在容器启动的时候执行一个命令，修改掉nginx的默认首页内容 command: [ \u0026#34;/bin/sh\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;echo postStart... \u0026gt; /usr/share/nginx/html/index.html\u0026#34;, ] preStop: exec: # 在容器停止之前停止nginx服务 command: [\u0026#34;/usr/sbin/nginx\u0026#34;, \u0026#34;-s\u0026#34;, \u0026#34;quit\u0026#34;] # 创建pod [root@k8s-master01 ~]# kubectl create -f pod-hook-exec.yaml pod/pod-hook-exec created # 查看pod [root@k8s-master01 ~]# kubectl get pods pod-hook-exec -n dev -o wide NAME READY STATUS RESTARTS AGE IP NODE pod-hook-exec 1/1 Running 0 29s 10.244.2.48 node2 # 访问pod [root@k8s-master01 ~]# curl 10.244.2.48 postStart... 5.3.4 容器探测 容器探测用于检测容器中的应用实例是否正常工作，是保障业务可用性的一种传统机制。如果经过探测，实例的状态不符合预期，那么 kubernetes 就会把该问题实例\u0026rdquo; 摘除 \u0026ldquo;，不承担业务流量。kubernetes 提供了两种探针来实现容器探测，分别是：\nliveness probes：存活性探针，用于检测应用实例当前是否处于正常运行状态，如果不是，k8s 会重启容器 readiness probes：就绪性探针，用于检测应用实例当前是否可以接收请求，如果不能，k8s 不会转发流量 livenessProbe 决定是否重启容器，readinessProbe 决定是否将请求转发给容器。\n上面两种探针目前均支持三种探测方式：\nExec 命令：在容器内执行一次命令，如果命令执行的退出码为 0，则认为程序正常，否则不正常\n…… livenessProbe: exec: command: - cat - /tmp/healthy …… TCPSocket：将会尝试访问一个用户容器的端口，如果能够建立这条连接，则认为程序正常，否则不正常\n…… livenessProbe: tcpSocket: port: 8080 …… HTTPGet：调用容器内 Web 应用的 URL，如果返回的状态码在 200 和 399 之间，则认为程序正常，否则不正常\n…… livenessProbe: httpGet: path: / #URI地址 port: 80 #端口号 host: 127.0.0.1 #主机地址 scheme: HTTP #支持的协议，http或者https …… 下面以 liveness probes 为例，做几个演示：\n方式一：Exec\n创建 pod-liveness-exec.yaml\napiVersion: v1 kind: Pod metadata: name: pod-liveness-exec namespace: dev spec: containers: - name: nginx image: nginx:1.17.1 ports: - name: nginx-port containerPort: 80 livenessProbe: exec: command: [\u0026#34;/bin/cat\u0026#34;, \u0026#34;/tmp/hello.txt\u0026#34;] # 执行一个查看文件的命令 创建 pod，观察效果\n# 创建Pod [root@k8s-master01 ~]# kubectl create -f pod-liveness-exec.yaml pod/pod-liveness-exec created # 查看Pod详情 [root@k8s-master01 ~]# kubectl describe pods pod-liveness-exec -n dev ...... Normal Created 20s (x2 over 50s) kubelet, node1 Created container nginx Normal Started 20s (x2 over 50s) kubelet, node1 Started container nginx Normal Killing 20s kubelet, node1 Container nginx failed liveness probe, will be restarted Warning Unhealthy 0s (x5 over 40s) kubelet, node1 Liveness probe failed: cat: can\u0026#39;t open \u0026#39;/tmp/hello11.txt\u0026#39;: No such file or directory # 观察上面的信息就会发现nginx容器启动之后就进行了健康检查 # 检查失败之后，容器被kill掉，然后尝试进行重启（这是重启策略的作用，后面讲解） # 稍等一会之后，再观察pod信息，就可以看到RESTARTS不再是0，而是一直增长 [root@k8s-master01 ~]# kubectl get pods pod-liveness-exec -n dev NAME READY STATUS RESTARTS AGE pod-liveness-exec 0/1 CrashLoopBackOff 2 3m19s # 当然接下来，可以修改成一个存在的文件，比如/tmp/hello.txt，再试，结果就正常了...... 方式二：TCPSocket\n创建 pod-liveness-tcpsocket.yaml\napiVersion: v1 kind: Pod metadata: name: pod-liveness-tcpsocket namespace: dev spec: containers: - name: nginx image: nginx:1.17.1 ports: - name: nginx-port containerPort: 80 livenessProbe: tcpSocket: port: 8080 # 尝试访问8080端口 创建 pod，观察效果\n# 创建Pod [root@k8s-master01 ~]# kubectl create -f pod-liveness-tcpsocket.yaml pod/pod-liveness-tcpsocket created # 查看Pod详情 [root@k8s-master01 ~]# kubectl describe pods pod-liveness-tcpsocket -n dev ...... Normal Scheduled 31s default-scheduler Successfully assigned dev/pod-liveness-tcpsocket to node2 Normal Pulled \u0026lt;invalid\u0026gt; kubelet, node2 Container image \u0026#34;nginx:1.17.1\u0026#34; already present on machine Normal Created \u0026lt;invalid\u0026gt; kubelet, node2 Created container nginx Normal Started \u0026lt;invalid\u0026gt; kubelet, node2 Started container nginx Warning Unhealthy \u0026lt;invalid\u0026gt; (x2 over \u0026lt;invalid\u0026gt;) kubelet, node2 Liveness probe failed: dial tcp 10.244.2.44:8080: connect: connection refused # 观察上面的信息，发现尝试访问8080端口,但是失败了 # 稍等一会之后，再观察pod信息，就可以看到RESTARTS不再是0，而是一直增长 [root@k8s-master01 ~]# kubectl get pods pod-liveness-tcpsocket -n dev NAME READY STATUS RESTARTS AGE pod-liveness-tcpsocket 0/1 CrashLoopBackOff 2 3m19s # 当然接下来，可以修改成一个可以访问的端口，比如80，再试，结果就正常了...... 方式三：HTTPGet\n创建 pod-liveness-httpget.yaml\napiVersion: v1 kind: Pod metadata: name: pod-liveness-httpget namespace: dev spec: containers: - name: nginx image: nginx:1.17.1 ports: - name: nginx-port containerPort: 80 livenessProbe: httpGet: # 其实就是访问http:/127.0.0.1:80/hello scheme: HTTP #支持的协议，http或者https port: 80 #端口号 path: /hello #URI地址 创建 pod，观察效果\n# 创建Pod [root@k8s-master01 ~]# kubectl create -f pod-liveness-httpget.yaml pod/pod-liveness-httpget created # 查看Pod详情 [root@k8s-master01 ~]# kubectl describe pod pod-liveness-httpget -n dev ....... Normal Pulled 6s (x3 over 64s) kubelet, node1 Container image \u0026#34;nginx:1.17.1\u0026#34; already present on machine Normal Created 6s (x3 over 64s) kubelet, node1 Created container nginx Normal Started 6s (x3 over 63s) kubelet, node1 Started container nginx Warning Unhealthy 6s (x6 over 56s) kubelet, node1 Liveness probe failed: HTTP probe failed with statuscode: 404 Normal Killing 6s (x2 over 36s) kubelet, node1 Container nginx failed liveness probe, will be restarted # 观察上面信息，尝试访问路径，但是未找到,出现404错误 # 稍等一会之后，再观察pod信息，就可以看到RESTARTS不再是0，而是一直增长 [root@k8s-master01 ~]# kubectl get pod pod-liveness-httpget -n dev NAME READY STATUS RESTARTS AGE pod-liveness-httpget 1/1 Running 5 3m17s # 当然接下来，可以修改成一个可以访问的路径path，比如/，再试，结果就正常了...... 至此，已经使用 liveness Probe 演示了三种探测方式，但是查看 livenessProbe 的子属性，会发现除了这三种方式，还有一些其他的配置，在这里一并解释下：\n[root@k8s-master01 ~]# kubectl explain pod.spec.containers.livenessProbe FIELDS: exec \u0026lt;Object\u0026gt; tcpSocket \u0026lt;Object\u0026gt; httpGet \u0026lt;Object\u0026gt; initialDelaySeconds \u0026lt;integer\u0026gt; # 容器启动后等待多少秒执行第一次探测 timeoutSeconds \u0026lt;integer\u0026gt; # 探测超时时间。默认1秒，最小1秒 periodSeconds \u0026lt;integer\u0026gt; # 执行探测的频率。默认是10秒，最小1秒 failureThreshold \u0026lt;integer\u0026gt; # 连续探测失败多少次才被认定为失败。默认是3。最小值是1 successThreshold \u0026lt;integer\u0026gt; # 连续探测成功多少次才被认定为成功。默认是1 下面稍微配置两个，演示下效果即可：\n[root@k8s-master01 ~]# more pod-liveness-httpget.yaml apiVersion: v1 kind: Pod metadata: name: pod-liveness-httpget namespace: dev spec: containers: - name: nginx image: nginx:1.17.1 ports: - name: nginx-port containerPort: 80 livenessProbe: httpGet: scheme: HTTP port: 80 path: / initialDelaySeconds: 30 # 容器启动后30s开始探测 timeoutSeconds: 5 # 探测超时时间为5s 5.3.5 重启策略 在上一节中，一旦容器探测出现了问题，kubernetes 就会对容器所在的 Pod 进行重启，其实这是由 pod 的重启策略决定的，pod 的重启策略有 3 种，分别如下：\nAlways ：容器失效时，自动重启该容器，这也是默认值。 OnFailure ： 容器终止运行且退出码不为 0 时重启 Never ： 不论状态为何，都不重启该容器 重启策略适用于 pod 对象中的所有容器，首次需要重启的容器，将在其需要时立即进行重启，随后再次需要重启的操作将由 kubelet 延迟一段时间后进行，且反复的重启操作的延迟时长以此为 10s、20s、40s、80s、160s 和 300s，300s 是最大延迟时长。\n创建 pod-restartpolicy.yaml：\napiVersion: v1 kind: Pod metadata: name: pod-restartpolicy namespace: dev spec: containers: - name: nginx image: nginx:1.17.1 ports: - name: nginx-port containerPort: 80 livenessProbe: httpGet: scheme: HTTP port: 80 path: /hello restartPolicy: Never # 设置重启策略为Never 运行 Pod 测试\n# 创建Pod [root@k8s-master01 ~]# kubectl create -f pod-restartpolicy.yaml pod/pod-restartpolicy created # 查看Pod详情，发现nginx容器失败 [root@k8s-master01 ~]# kubectl describe pods pod-restartpolicy -n dev ...... Warning Unhealthy 15s (x3 over 35s) kubelet, node1 Liveness probe failed: HTTP probe failed with statuscode: 404 Normal Killing 15s kubelet, node1 Container nginx failed liveness probe # 多等一会，再观察pod的重启次数，发现一直是0，并未重启 [root@k8s-master01 ~]# kubectl get pods pod-restartpolicy -n dev NAME READY STATUS RESTARTS AGE pod-restartpolicy 0/1 Running 0 5min42s 5.4 Pod 调度 在默认情况下，一个 Pod 在哪个 Node 节点上运行，是由 Scheduler 组件采用相应的算法计算出来的，这个过程是不受人工控制的。但是在实际使用中，这并不满足的需求，因为很多情况下，我们想控制某些 Pod 到达某些节点上，那么应该怎么做呢？这就要求了解 kubernetes 对 Pod 的调度规则，kubernetes 提供了四大类调度方式：\n自动调度：运行在哪个节点上完全由 Scheduler 经过一系列的算法计算得出 定向调度：NodeName、NodeSelector 亲和性调度：NodeAffinity、PodAffinity、PodAntiAffinity 污点（容忍）调度：Taints、Toleration 5.4.1 定向调度 定向调度，指的是利用在 pod 上声明 nodeName 或者 nodeSelector，以此将 Pod 调度到期望的 node 节点上。注意，这里的调度是强制的，这就意味着即使要调度的目标 Node 不存在，也会向上面进行调度，只不过 pod 运行失败而已。\nNodeName\nNodeName 用于强制约束将 Pod 调度到指定的 Name 的 Node 节点上。这种方式，其实是直接跳过 Scheduler 的调度逻辑，直接将 Pod 调度到指定名称的节点。\n接下来，实验一下：创建一个 pod-nodename.yaml 文件\napiVersion: v1 kind: Pod metadata: name: pod-nodename namespace: dev spec: containers: - name: nginx image: nginx:1.17.1 nodeName: node1 # 指定调度到node1节点上 #创建Pod [root@k8s-master01 ~]# kubectl create -f pod-nodename.yaml pod/pod-nodename created #查看Pod调度到NODE属性，确实是调度到了node1节点上 [root@k8s-master01 ~]# kubectl get pods pod-nodename -n dev -o wide NAME READY STATUS RESTARTS AGE IP NODE ...... pod-nodename 1/1 Running 0 56s 10.244.1.87 node1 ...... # 接下来，删除pod，修改nodeName的值为node3（并没有node3节点） [root@k8s-master01 ~]# kubectl delete -f pod-nodename.yaml pod \u0026#34;pod-nodename\u0026#34; deleted [root@k8s-master01 ~]# vim pod-nodename.yaml [root@k8s-master01 ~]# kubectl create -f pod-nodename.yaml pod/pod-nodename created #再次查看，发现已经向Node3节点调度，但是由于不存在node3节点，所以pod无法正常运行 [root@k8s-master01 ~]# kubectl get pods pod-nodename -n dev -o wide NAME READY STATUS RESTARTS AGE IP NODE ...... pod-nodename 0/1 Pending 0 6s \u0026lt;none\u0026gt; node3 ...... NodeSelector\nNodeSelector 用于将 pod 调度到添加了指定标签的 node 节点上。它是通过 kubernetes 的 label-selector 机制实现的，也就是说，在 pod 创建之前，会由 scheduler 使用 MatchNodeSelector 调度策略进行 label 匹配，找出目标 node，然后将 pod 调度到目标节点，该匹配规则是强制约束。\n接下来，实验一下：\n1 首先分别为 node 节点添加标签\n[root@k8s-master01 ~]# kubectl label nodes node1 nodeenv=pro node/node2 labeled [root@k8s-master01 ~]# kubectl label nodes node2 nodeenv=test node/node2 labeled 2 创建一个 pod-nodeselector.yaml 文件，并使用它创建 Pod\napiVersion: v1 kind: Pod metadata: name: pod-nodeselector namespace: dev spec: containers: - name: nginx image: nginx:1.17.1 nodeSelector: nodeenv: pro # 指定调度到具有nodeenv=pro标签的节点上 #创建Pod [root@k8s-master01 ~]# kubectl create -f pod-nodeselector.yaml pod/pod-nodeselector created #查看Pod调度到NODE属性，确实是调度到了node1节点上 [root@k8s-master01 ~]# kubectl get pods pod-nodeselector -n dev -o wide NAME READY STATUS RESTARTS AGE IP NODE ...... pod-nodeselector 1/1 Running 0 47s 10.244.1.87 node1 ...... # 接下来，删除pod，修改nodeSelector的值为nodeenv: xxxx（不存在打有此标签的节点） [root@k8s-master01 ~]# kubectl delete -f pod-nodeselector.yaml pod \u0026#34;pod-nodeselector\u0026#34; deleted [root@k8s-master01 ~]# vim pod-nodeselector.yaml [root@k8s-master01 ~]# kubectl create -f pod-nodeselector.yaml pod/pod-nodeselector created #再次查看，发现pod无法正常运行,Node的值为none [root@k8s-master01 ~]# kubectl get pods -n dev -o wide NAME READY STATUS RESTARTS AGE IP NODE pod-nodeselector 0/1 Pending 0 2m20s \u0026lt;none\u0026gt; \u0026lt;none\u0026gt; # 查看详情,发现node selector匹配失败的提示 [root@k8s-master01 ~]# kubectl describe pods pod-nodeselector -n dev ....... Events: Type Reason Age From Message ---- ------ ---- ---- ------- Warning FailedScheduling \u0026lt;unknown\u0026gt; default-scheduler 0/3 nodes are available: 3 node(s) didn\u0026#39;t match node selector. 5.4.2 亲和性调度 上一节，介绍了两种定向调度的方式，使用起来非常方便，但是也有一定的问题，那就是如果没有满足条件的 Node，那么 Pod 将不会被运行，即使在集群中还有可用 Node 列表也不行，这就限制了它的使用场景。\n基于上面的问题，kubernetes 还提供了一种亲和性调度（Affinity）。它在 NodeSelector 的基础之上的进行了扩展，可以通过配置的形式，实现优先选择满足条件的 Node 进行调度，如果没有，也可以调度到不满足条件的节点上，使调度更加灵活。\nAffinity 主要分为三类：\nnodeAffinity(node 亲和性）: 以 node 为目标，解决 pod 可以调度到哪些 node 的问题 podAffinity(pod 亲和性) : 以 pod 为目标，解决 pod 可以和哪些已存在的 pod 部署在同一个拓扑域中的问题 podAntiAffinity(pod 反亲和性) : 以 pod 为目标，解决 pod 不能和哪些已存在 pod 部署在同一个拓扑域中的问题 关于亲和性(反亲和性)使用场景的说明：\n亲和性：如果两个应用频繁交互，那就有必要利用亲和性让两个应用的尽可能的靠近，这样可以减少因网络通信而带来的性能损耗。\n反亲和性：当应用的采用多副本部署时，有必要采用反亲和性让各个应用实例打散分布在各个 node 上，这样可以提高服务的高可用性。\nNodeAffinity\n首先来看一下NodeAffinity的可配置项：\npod.spec.affinity.nodeAffinity requiredDuringSchedulingIgnoredDuringExecution Node 节点必须满足指定的所有规则才可以，相当于硬限制 nodeSelectorTerms 节点选择列表 matchFields 按节点字段列出的节点选择器要求列表 matchExpressions 按节点标签列出的节点选择器要求列表(推荐) key 键 values 值 operat or 关系符 支持 Exists, DoesNotExist, In, NotIn, Gt, Lt preferredDuringSchedulingIgnoredDuringExecution 优先调度到满足指定的规则的 Node，相当于软限制 (倾向) preference 一个节点选择器项，与相应的权重相关联 matchFields 按节点字段列出的节点选择器要求列表 matchExpressions 按节点标签列出的节点选择器要求列表(推荐) key 键 values 值 operator 关系符 支持 In, NotIn, Exists, DoesNotExist, Gt, Lt weight 倾向权重，在范围 1-100。 关系符的使用说明: - matchExpressions: - key: nodeenv # 匹配存在标签的key为nodeenv的节点 operator: Exists - key: nodeenv # 匹配标签的key为nodeenv,且value是\u0026#34;xxx\u0026#34;或\u0026#34;yyy\u0026#34;的节点 operator: In values: [\u0026#34;xxx\u0026#34;,\u0026#34;yyy\u0026#34;] - key: nodeenv # 匹配标签的key为nodeenv,且value大于\u0026#34;xxx\u0026#34;的节点 operator: Gt values: \u0026#34;xxx\u0026#34; 接下来首先演示一下requiredDuringSchedulingIgnoredDuringExecution ,\n创建 pod-nodeaffinity-required.yaml\napiVersion: v1 kind: Pod metadata: name: pod-nodeaffinity-required namespace: dev spec: containers: - name: nginx image: nginx:1.17.1 affinity: #亲和性设置 nodeAffinity: #设置node亲和性 requiredDuringSchedulingIgnoredDuringExecution: # 硬限制 nodeSelectorTerms: - matchExpressions: # 匹配env的值在[\u0026#34;xxx\u0026#34;,\u0026#34;yyy\u0026#34;]中的标签 - key: nodeenv operator: In values: [\u0026#34;xxx\u0026#34;, \u0026#34;yyy\u0026#34;] # 创建pod [root@k8s-master01 ~]# kubectl create -f pod-nodeaffinity-required.yaml pod/pod-nodeaffinity-required created # 查看pod状态 （运行失败） [root@k8s-master01 ~]# kubectl get pods pod-nodeaffinity-required -n dev -o wide NAME READY STATUS RESTARTS AGE IP NODE ...... pod-nodeaffinity-required 0/1 Pending 0 16s \u0026lt;none\u0026gt; \u0026lt;none\u0026gt; ...... # 查看Pod的详情 # 发现调度失败，提示node选择失败 [root@k8s-master01 ~]# kubectl describe pod pod-nodeaffinity-required -n dev ...... Warning FailedScheduling \u0026lt;unknown\u0026gt; default-scheduler 0/3 nodes are available: 3 node(s) didn\u0026#39;t match node selector. Warning FailedScheduling \u0026lt;unknown\u0026gt; default-scheduler 0/3 nodes are available: 3 node(s) didn\u0026#39;t match node selector. #接下来，停止pod [root@k8s-master01 ~]# kubectl delete -f pod-nodeaffinity-required.yaml pod \u0026#34;pod-nodeaffinity-required\u0026#34; deleted # 修改文件，将values: [\u0026#34;xxx\u0026#34;,\u0026#34;yyy\u0026#34;]------\u0026gt; [\u0026#34;pro\u0026#34;,\u0026#34;yyy\u0026#34;] [root@k8s-master01 ~]# vim pod-nodeaffinity-required.yaml # 再次启动 [root@k8s-master01 ~]# kubectl create -f pod-nodeaffinity-required.yaml pod/pod-nodeaffinity-required created # 此时查看，发现调度成功，已经将pod调度到了node1上 [root@k8s-master01 ~]# kubectl get pods pod-nodeaffinity-required -n dev -o wide NAME READY STATUS RESTARTS AGE IP NODE ...... pod-nodeaffinity-required 1/1 Running 0 11s 10.244.1.89 node1 ...... 接下来再演示一下requiredDuringSchedulingIgnoredDuringExecution ,\n创建 pod-nodeaffinity-preferred.yaml\napiVersion: v1 kind: Pod metadata: name: pod-nodeaffinity-preferred namespace: dev spec: containers: - name: nginx image: nginx:1.17.1 affinity: #亲和性设置 nodeAffinity: #设置node亲和性 preferredDuringSchedulingIgnoredDuringExecution: # 软限制 - weight: 1 preference: matchExpressions: # 匹配env的值在[\u0026#34;xxx\u0026#34;,\u0026#34;yyy\u0026#34;]中的标签(当前环境没有) - key: nodeenv operator: In values: [\u0026#34;xxx\u0026#34;, \u0026#34;yyy\u0026#34;] # 创建pod [root@k8s-master01 ~]# kubectl create -f pod-nodeaffinity-preferred.yaml pod/pod-nodeaffinity-preferred created # 查看pod状态 （运行成功） [root@k8s-master01 ~]# kubectl get pod pod-nodeaffinity-preferred -n dev NAME READY STATUS RESTARTS AGE pod-nodeaffinity-preferred 1/1 Running 0 40s NodeAffinity规则设置的注意事项： 1 如果同时定义了nodeSelector和nodeAffinity，那么必须两个条件都得到满足，Pod才能运行在指定的Node上 2 如果nodeAffinity指定了多个nodeSelectorTerms，那么只需要其中一个能够匹配成功即可 3 如果一个nodeSelectorTerms中有多个matchExpressions ，则一个节点必须满足所有的才能匹配成功 4 如果一个pod所在的Node在Pod运行期间其标签发生了改变，不再符合该Pod的节点亲和性需求，则系统将忽略此变化 PodAffinity\nPodAffinity 主要实现以运行的 Pod 为参照，实现让新创建的 Pod 跟参照 pod 在一个区域的功能。\n首先来看一下PodAffinity的可配置项：\npod.spec.affinity.podAffinity requiredDuringSchedulingIgnoredDuringExecution 硬限制 namespaces 指定参照 pod 的 namespace topologyKey 指定调度作用域 labelSelector 标签选择器 matchExpressions 按节点标签列出的节点选择器要求列表(推荐) key 键 values 值 operator 关系符 支持 In, NotIn, Exists, DoesNotExist. matchLabels 指多个 matchExpressions 映射的内容 preferredDuringSchedulingIgnoredDuringExecution 软限制 podAffinityTerm 选项 namespaces topologyKey labelSelector matchExpressions key 键 values 值 operator matchLabels weight 倾向权重，在范围 1-100 topologyKey 用于指定调度时作用域,例如: 如果指定为 kubernetes.io/hostname，那就是以 Node 节点为区分范围 如果指定为 beta.kubernetes.io/os,则以 Node 节点的操作系统类型来区分 接下来，演示下requiredDuringSchedulingIgnoredDuringExecution,\n1）首先创建一个参照 Pod，pod-podaffinity-target.yaml：\napiVersion: v1 kind: Pod metadata: name: pod-podaffinity-target namespace: dev labels: podenv: pro #设置标签 spec: containers: - name: nginx image: nginx:1.17.1 nodeName: node1 # 将目标pod名确指定到node1上 # 启动目标pod [root@k8s-master01 ~]# kubectl create -f pod-podaffinity-target.yaml pod/pod-podaffinity-target created # 查看pod状况 [root@k8s-master01 ~]# kubectl get pods pod-podaffinity-target -n dev NAME READY STATUS RESTARTS AGE pod-podaffinity-target 1/1 Running 0 4s 2）创建 pod-podaffinity-required.yaml，内容如下：\napiVersion: v1 kind: Pod metadata: name: pod-podaffinity-required namespace: dev spec: containers: - name: nginx image: nginx:1.17.1 affinity: #亲和性设置 podAffinity: #设置pod亲和性 requiredDuringSchedulingIgnoredDuringExecution: # 硬限制 - labelSelector: matchExpressions: # 匹配env的值在[\u0026#34;xxx\u0026#34;,\u0026#34;yyy\u0026#34;]中的标签 - key: podenv operator: In values: [\u0026#34;xxx\u0026#34;, \u0026#34;yyy\u0026#34;] topologyKey: kubernetes.io/hostname 上面配置表达的意思是：新 Pod 必须要与拥有标签 nodeenv=xxx 或者 nodeenv=yyy 的 pod 在同一 Node 上，显然现在没有这样 pod，接下来，运行测试一下。\n# 启动pod [root@k8s-master01 ~]# kubectl create -f pod-podaffinity-required.yaml pod/pod-podaffinity-required created # 查看pod状态，发现未运行 [root@k8s-master01 ~]# kubectl get pods pod-podaffinity-required -n dev NAME READY STATUS RESTARTS AGE pod-podaffinity-required 0/1 Pending 0 9s # 查看详细信息 [root@k8s-master01 ~]# kubectl describe pods pod-podaffinity-required -n dev ...... Events: Type Reason Age From Message ---- ------ ---- ---- ------- Warning FailedScheduling \u0026lt;unknown\u0026gt; default-scheduler 0/3 nodes are available: 2 node(s) didn\u0026#39;t match pod affinity rules, 1 node(s) had taints that the pod didn\u0026#39;t tolerate. # 接下来修改 values: [\u0026#34;xxx\u0026#34;,\u0026#34;yyy\u0026#34;]-----\u0026gt;values:[\u0026#34;pro\u0026#34;,\u0026#34;yyy\u0026#34;] # 意思是：新Pod必须要与拥有标签nodeenv=xxx或者nodeenv=yyy的pod在同一Node上 [root@k8s-master01 ~]# vim pod-podaffinity-required.yaml # 然后重新创建pod，查看效果 [root@k8s-master01 ~]# kubectl delete -f pod-podaffinity-required.yaml pod \u0026#34;pod-podaffinity-required\u0026#34; de leted [root@k8s-master01 ~]# kubectl create -f pod-podaffinity-required.yaml pod/pod-podaffinity-required created # 发现此时Pod运行正常 [root@k8s-master01 ~]# kubectl get pods pod-podaffinity-required -n dev NAME READY STATUS RESTARTS AGE LABELS pod-podaffinity-required 1/1 Running 0 6s \u0026lt;none\u0026gt; 关于PodAffinity的 preferredDuringSchedulingIgnoredDuringExecution，这里不再演示。\nPodAntiAffinity\nPodAntiAffinity 主要实现以运行的 Pod 为参照，让新创建的 Pod 跟参照 pod 不在一个区域中的功能。\n它的配置方式和选项跟 PodAffinty 是一样的，这里不再做详细解释，直接做一个测试案例。\n1）继续使用上个案例中目标 pod\n[root@k8s-master01 ~]# kubectl get pods -n dev -o wide --show-labels NAME READY STATUS RESTARTS AGE IP NODE LABELS pod-podaffinity-required 1/1 Running 0 3m29s 10.244.1.38 node1 \u0026lt;none\u0026gt; pod-podaffinity-target 1/1 Running 0 9m25s 10.244.1.37 node1 podenv=pro 2）创建 pod-podantiaffinity-required.yaml，内容如下：\napiVersion: v1 kind: Pod metadata: name: pod-podantiaffinity-required namespace: dev spec: containers: - name: nginx image: nginx:1.17.1 affinity: #亲和性设置 podAntiAffinity: #设置pod亲和性 requiredDuringSchedulingIgnoredDuringExecution: # 硬限制 - labelSelector: matchExpressions: # 匹配podenv的值在[\u0026#34;pro\u0026#34;]中的标签 - key: podenv operator: In values: [\u0026#34;pro\u0026#34;] topologyKey: kubernetes.io/hostname 上面配置表达的意思是：新 Pod 必须要与拥有标签 nodeenv=pro 的 pod 不在同一 Node 上，运行测试一下。\n# 创建pod [root@k8s-master01 ~]# kubectl create -f pod-podantiaffinity-required.yaml pod/pod-podantiaffinity-required created # 查看pod # 发现调度到了node2上 [root@k8s-master01 ~]# kubectl get pods pod-podantiaffinity-required -n dev -o wide NAME READY STATUS RESTARTS AGE IP NODE .. pod-podantiaffinity-required 1/1 Running 0 30s 10.244.1.96 node2 .. 5.4.3 污点和容忍 污点（Taints）\n前面的调度方式都是站在 Pod 的角度上，通过在 Pod 上添加属性，来确定 Pod 是否要调度到指定的 Node 上，其实我们也可以站在 Node 的角度上，通过在 Node 上添加污点属性，来决定是否允许 Pod 调度过来。\nNode 被设置上污点之后就和 Pod 之间存在了一种相斥的关系，进而拒绝 Pod 调度进来，甚至可以将已经存在的 Pod 驱逐出去。\n污点的格式为：key=value:effect, key 和 value 是污点的标签，effect 描述污点的作用，支持如下三个选项：\nPreferNoSchedule：kubernetes 将尽量避免把 Pod 调度到具有该污点的 Node 上，除非没有其他节点可调度 NoSchedule：kubernetes 将不会把 Pod 调度到具有该污点的 Node 上，但不会影响当前 Node 上已存在的 Pod NoExecute：kubernetes 将不会把 Pod 调度到具有该污点的 Node 上，同时也会将 Node 上已存在的 Pod 驱离 使用 kubectl 设置和去除污点的命令示例如下：\n# 设置污点 kubectl taint nodes node1 key=value:effect # 去除污点 kubectl taint nodes node1 key:effect- # 去除所有污点 kubectl taint nodes node1 key- 接下来，演示下污点的效果：\n准备节点 node1（为了演示效果更加明显，暂时停止 node2 节点） 为 node1 节点设置一个污点: tag=heima:PreferNoSchedule；然后创建 pod1( pod1 可以 ) 修改为 node1 节点设置一个污点: tag=heima:NoSchedule；然后创建 pod2( pod1 正常 pod2 失败 ) 修改为 node1 节点设置一个污点: tag=heima:NoExecute；然后创建 pod3 ( 3 个 pod 都失败 ) # 为node1设置污点(PreferNoSchedule) [root@k8s-master01 ~]# kubectl taint nodes node1 tag=heima:PreferNoSchedule # 创建pod1 [root@k8s-master01 ~]# kubectl run taint1 --image=nginx:1.17.1 -n dev [root@k8s-master01 ~]# kubectl get pods -n dev -o wide NAME READY STATUS RESTARTS AGE IP NODE taint1-7665f7fd85-574h4 1/1 Running 0 2m24s 10.244.1.59 node1 # 为node1设置污点(取消PreferNoSchedule，设置NoSchedule) [root@k8s-master01 ~]# kubectl taint nodes node1 tag:PreferNoSchedule- [root@k8s-master01 ~]# kubectl taint nodes node1 tag=heima:NoSchedule # 创建pod2 [root@k8s-master01 ~]# kubectl run taint2 --image=nginx:1.17.1 -n dev [root@k8s-master01 ~]# kubectl get pods taint2 -n dev -o wide NAME READY STATUS RESTARTS AGE IP NODE taint1-7665f7fd85-574h4 1/1 Running 0 2m24s 10.244.1.59 node1 taint2-544694789-6zmlf 0/1 Pending 0 21s \u0026lt;none\u0026gt; \u0026lt;none\u0026gt; # 为node1设置污点(取消NoSchedule，设置NoExecute) [root@k8s-master01 ~]# kubectl taint nodes node1 tag:NoSchedule- [root@k8s-master01 ~]# kubectl taint nodes node1 tag=heima:NoExecute # 创建pod3 [root@k8s-master01 ~]# kubectl run taint3 --image=nginx:1.17.1 -n dev [root@k8s-master01 ~]# kubectl get pods -n dev -o wide NAME READY STATUS RESTARTS AGE IP NODE NOMINATED taint1-7665f7fd85-htkmp 0/1 Pending 0 35s \u0026lt;none\u0026gt; \u0026lt;none\u0026gt; \u0026lt;none\u0026gt; taint2-544694789-bn7wb 0/1 Pending 0 35s \u0026lt;none\u0026gt; \u0026lt;none\u0026gt; \u0026lt;none\u0026gt; taint3-6d78dbd749-tktkq 0/1 Pending 0 6s \u0026lt;none\u0026gt; \u0026lt;none\u0026gt; \u0026lt;none\u0026gt; 小提示： 使用kubeadm搭建的集群，默认就会给master节点添加一个污点标记,所以pod就不会调度到master节点上. 容忍（Toleration）\n上面介绍了污点的作用，我们可以在 node 上添加污点用于拒绝 pod 调度上来，但是如果就是想将一个 pod 调度到一个有污点的 node 上去，这时候应该怎么做呢？这就要使用到容忍。\n污点就是拒绝，容忍就是忽略，Node 通过污点拒绝 pod 调度上去，Pod 通过容忍忽略拒绝\n下面先通过一个案例看下效果：\n上一小节，已经在 node1 节点上打上了NoExecute的污点，此时 pod 是调度不上去的 本小节，可以通过给 pod 添加容忍，然后将其调度上去 创建 pod-toleration.yaml,内容如下\napiVersion: v1 kind: Pod metadata: name: pod-toleration namespace: dev spec: containers: - name: nginx image: nginx:1.17.1 tolerations: # 添加容忍 - key: \u0026#34;tag\u0026#34; # 要容忍的污点的key operator: \u0026#34;Equal\u0026#34; # 操作符 value: \u0026#34;heima\u0026#34; # 容忍的污点的value effect: \u0026#34;NoExecute\u0026#34; # 添加容忍的规则，这里必须和标记的污点规则相同 # 添加容忍之前的pod [root@k8s-master01 ~]# kubectl get pods -n dev -o wide NAME READY STATUS RESTARTS AGE IP NODE NOMINATED pod-toleration 0/1 Pending 0 3s \u0026lt;none\u0026gt; \u0026lt;none\u0026gt; \u0026lt;none\u0026gt; # 添加容忍之后的pod [root@k8s-master01 ~]# kubectl get pods -n dev -o wide NAME READY STATUS RESTARTS AGE IP NODE NOMINATED pod-toleration 1/1 Running 0 3s 10.244.1.62 node1 \u0026lt;none\u0026gt; 下面看一下容忍的详细配置:\n[root@k8s-master01 ~]# kubectl explain pod.spec.tolerations ...... FIELDS: key # 对应着要容忍的污点的键，空意味着匹配所有的键 value # 对应着要容忍的污点的值 operator # key-value的运算符，支持Equal和Exists（默认） effect # 对应污点的effect，空意味着匹配所有影响 tolerationSeconds # 容忍时间, 当effect为NoExecute时生效，表示pod在Node上的停留时间 6. Pod 控制器详解 6.1 Pod 控制器介绍 Pod 是 kubernetes 的最小管理单元，在 kubernetes 中，按照 pod 的创建方式可以将其分为两类：\n自主式 pod：kubernetes 直接创建出来的 Pod，这种 pod 删除后就没有了，也不会重建 控制器创建的 pod：kubernetes 通过控制器创建的 pod，这种 pod 删除了之后还会自动重建 什么是Pod控制器\nPod 控制器是管理 pod 的中间层，使用 Pod 控制器之后，只需要告诉 Pod 控制器，想要多少个什么样的 Pod 就可以了，它会创建出满足条件的 Pod 并确保每一个 Pod 资源处于用户期望的目标状态。如果 Pod 资源在运行中出现故障，它会基于指定策略重新编排 Pod。\n在 kubernetes 中，有很多类型的 pod 控制器，每种都有自己的适合的场景，常见的有下面这些：\nReplicationController：比较原始的 pod 控制器，已经被废弃，由 ReplicaSet 替代 ReplicaSet：保证副本数量一直维持在期望值，并支持 pod 数量扩缩容，镜像版本升级 Deployment：通过控制 ReplicaSet 来控制 Pod，并支持滚动升级、回退版本 Horizontal Pod Autoscaler：可以根据集群负载自动水平调整 Pod 的数量，实现削峰填谷 DaemonSet：在集群中的指定 Node 上运行且仅运行一个副本，一般用于守护进程类的任务 Job：它创建出来的 pod 只要完成任务就立即退出，不需要重启或重建，用于执行一次性任务 Cronjob：它创建的 Pod 负责周期性任务控制，不需要持续后台运行 StatefulSet：管理有状态应用 6.2 ReplicaSet(RS) ReplicaSet 的主要作用是保证一定数量的 pod 正常运行，它会持续监听这些 Pod 的运行状态，一旦 Pod 发生故障，就会重启或重建。同时它还支持对 pod 数量的扩缩容和镜像版本的升降级。\nReplicaSet 的资源清单文件：\napiVersion: apps/v1 # 版本号 kind: ReplicaSet # 类型 metadata: # 元数据 name: # rs名称 namespace: # 所属命名空间 labels: #标签 controller: rs spec: # 详情描述 replicas: 3 # 副本数量 selector: # 选择器，通过它指定该控制器管理哪些pod matchLabels: # Labels匹配规则 app: nginx-pod matchExpressions: # Expressions匹配规则 - { key: app, operator: In, values: [nginx-pod] } template: # 模板，当副本数量不足时，会根据下面的模板创建pod副本 metadata: labels: app: nginx-pod spec: containers: - name: nginx image: nginx:1.17.1 ports: - containerPort: 80 在这里面，需要新了解的配置项就是spec下面几个选项：\nreplicas：指定副本数量，其实就是当前 rs 创建出来的 pod 的数量，默认为 1\nselector：选择器，它的作用是建立 pod 控制器和 pod 之间的关联关系，采用的 Label Selector 机制\n在 pod 模板上定义 label，在控制器上定义选择器，就可以表明当前控制器能管理哪些 pod 了\ntemplate：模板，就是当前控制器创建 pod 所使用的模板板，里面其实就是前一章学过的 pod 的定义\n创建 ReplicaSet\n创建 pc-replicaset.yaml 文件，内容如下：\napiVersion: apps/v1 kind: ReplicaSet metadata: name: pc-replicaset namespace: dev spec: replicas: 3 selector: matchLabels: app: nginx-pod template: metadata: labels: app: nginx-pod spec: containers: - name: nginx image: nginx:1.17.1 # 创建rs [root@k8s-master01 ~]# kubectl create -f pc-replicaset.yaml replicaset.apps/pc-replicaset created # 查看rs # DESIRED:期望副本数量 # CURRENT:当前副本数量 # READY:已经准备好提供服务的副本数量 [root@k8s-master01 ~]# kubectl get rs pc-replicaset -n dev -o wide NAME DESIRED CURRENT READY AGE CONTAINERS IMAGES SELECTOR pc-replicaset 3 3 3 22s nginx nginx:1.17.1 app=nginx-pod # 查看当前控制器创建出来的pod # 这里发现控制器创建出来的pod的名称是在控制器名称后面拼接了-xxxxx随机码 [root@k8s-master01 ~]# kubectl get pod -n dev NAME READY STATUS RESTARTS AGE pc-replicaset-6vmvt 1/1 Running 0 54s pc-replicaset-fmb8f 1/1 Running 0 54s pc-replicaset-snrk2 1/1 Running 0 54s 扩缩容\n# 编辑rs的副本数量，修改spec:replicas: 6即可 [root@k8s-master01 ~]# kubectl edit rs pc-replicaset -n dev replicaset.apps/pc-replicaset edited # 查看pod [root@k8s-master01 ~]# kubectl get pods -n dev NAME READY STATUS RESTARTS AGE pc-replicaset-6vmvt 1/1 Running 0 114m pc-replicaset-cftnp 1/1 Running 0 10s pc-replicaset-fjlm6 1/1 Running 0 10s pc-replicaset-fmb8f 1/1 Running 0 114m pc-replicaset-s2whj 1/1 Running 0 10s pc-replicaset-snrk2 1/1 Running 0 114m # 当然也可以直接使用命令实现 # 使用scale命令实现扩缩容， 后面--replicas=n直接指定目标数量即可 [root@k8s-master01 ~]# kubectl scale rs pc-replicaset --replicas=2 -n dev replicaset.apps/pc-replicaset scaled # 命令运行完毕，立即查看，发现已经有4个开始准备退出了 [root@k8s-master01 ~]# kubectl get pods -n dev NAME READY STATUS RESTARTS AGE pc-replicaset-6vmvt 0/1 Terminating 0 118m pc-replicaset-cftnp 0/1 Terminating 0 4m17s pc-replicaset-fjlm6 0/1 Terminating 0 4m17s pc-replicaset-fmb8f 1/1 Running 0 118m pc-replicaset-s2whj 0/1 Terminating 0 4m17s pc-replicaset-snrk2 1/1 Running 0 118m #稍等片刻，就只剩下2个了 [root@k8s-master01 ~]# kubectl get pods -n dev NAME READY STATUS RESTARTS AGE pc-replicaset-fmb8f 1/1 Running 0 119m pc-replicaset-snrk2 1/1 Running 0 119m 镜像升级\n# 编辑rs的容器镜像 - image: nginx:1.17.2 [root@k8s-master01 ~]# kubectl edit rs pc-replicaset -n dev replicaset.apps/pc-replicaset edited # 再次查看，发现镜像版本已经变更了 [root@k8s-master01 ~]# kubectl get rs -n dev -o wide NAME DESIRED CURRENT READY AGE CONTAINERS IMAGES ... pc-replicaset 2 2 2 140m nginx nginx:1.17.2 ... # 同样的道理，也可以使用命令完成这个工作 # kubectl set image rs rs名称 容器=镜像版本 -n namespace [root@k8s-master01 ~]# kubectl set image rs pc-replicaset nginx=nginx:1.17.1 -n dev replicaset.apps/pc-replicaset image updated # 再次查看，发现镜像版本已经变更了 [root@k8s-master01 ~]# kubectl get rs -n dev -o wide NAME DESIRED CURRENT READY AGE CONTAINERS IMAGES ... pc-replicaset 2 2 2 145m nginx nginx:1.17.1 ... 删除 ReplicaSet\n# 使用kubectl delete命令会删除此RS以及它管理的Pod # 在kubernetes删除RS前，会将RS的replicasclear调整为0，等待所有的Pod被删除后，在执行RS对象的删除 [root@k8s-master01 ~]# kubectl delete rs pc-replicaset -n dev replicaset.apps \u0026#34;pc-replicaset\u0026#34; deleted [root@k8s-master01 ~]# kubectl get pod -n dev -o wide No resources found in dev namespace. # 如果希望仅仅删除RS对象（保留Pod），可以使用kubectl delete命令时添加--cascade=false选项（不推荐）。 [root@k8s-master01 ~]# kubectl delete rs pc-replicaset -n dev --cascade=false replicaset.apps \u0026#34;pc-replicaset\u0026#34; deleted [root@k8s-master01 ~]# kubectl get pods -n dev NAME READY STATUS RESTARTS AGE pc-replicaset-cl82j 1/1 Running 0 75s pc-replicaset-dslhb 1/1 Running 0 75s # 也可以使用yaml直接删除(推荐) [root@k8s-master01 ~]# kubectl delete -f pc-replicaset.yaml replicaset.apps \u0026#34;pc-replicaset\u0026#34; deleted 6.3 Deployment(Deploy) 为了更好的解决服务编排的问题，kubernetes 在 V1.2 版本开始，引入了 Deployment 控制器。值得一提的是，这种控制器并不直接管理 pod，而是通过管理 ReplicaSet 来简介管理 Pod，即：Deployment 管理 ReplicaSet，ReplicaSet 管理 Pod。所以 Deployment 比 ReplicaSet 功能更加强大。\nDeployment 主要功能有下面几个：\n支持 ReplicaSet 的所有功能 支持发布的停止、继续 支持滚动升级和回滚版本 Deployment 的资源清单文件：\napiVersion: apps/v1 # 版本号 kind: Deployment # 类型 metadata: # 元数据 name: # rs名称 namespace: # 所属命名空间 labels: #标签 controller: deploy spec: # 详情描述 replicas: 3 # 副本数量 revisionHistoryLimit: 3 # 保留历史版本 paused: false # 暂停部署，默认是false progressDeadlineSeconds: 600 # 部署超时时间（s），默认是600 strategy: # 策略 type: RollingUpdate # 滚动更新策略 rollingUpdate: # 滚动更新 max违规词汇: 30% # 最大额外可以存在的副本数，可以为百分比，也可以为整数 maxUnavailable: 30% # 最大不可用状态的 Pod 的最大值，可以为百分比，也可以为整数 selector: # 选择器，通过它指定该控制器管理哪些pod matchLabels: # Labels匹配规则 app: nginx-pod matchExpressions: # Expressions匹配规则 - { key: app, operator: In, values: [nginx-pod] } template: # 模板，当副本数量不足时，会根据下面的模板创建pod副本 metadata: labels: app: nginx-pod spec: containers: - name: nginx image: nginx:1.17.1 ports: - containerPort: 80 6.3.1 创建 deployment 创建 pc-deployment.yaml，内容如下：\napiVersion: apps/v1 kind: Deployment metadata: name: pc-deployment namespace: dev spec: replicas: 3 selector: matchLabels: app: nginx-pod template: metadata: labels: app: nginx-pod spec: containers: - name: nginx image: nginx:1.17.1 # 创建deployment [root@k8s-master01 ~]# kubectl create -f pc-deployment.yaml --record=true deployment.apps/pc-deployment created # 查看deployment # UP-TO-DATE 最新版本的pod的数量 # AVAILABLE 当前可用的pod的数量 [root@k8s-master01 ~]# kubectl get deploy pc-deployment -n dev NAME READY UP-TO-DATE AVAILABLE AGE pc-deployment 3/3 3 3 15s # 查看rs # 发现rs的名称是在原来deployment的名字后面添加了一个10位数的随机串 [root@k8s-master01 ~]# kubectl get rs -n dev NAME DESIRED CURRENT READY AGE pc-deployment-6696798b78 3 3 3 23s # 查看pod [root@k8s-master01 ~]# kubectl get pods -n dev NAME READY STATUS RESTARTS AGE pc-deployment-6696798b78-d2c8n 1/1 Running 0 107s pc-deployment-6696798b78-smpvp 1/1 Running 0 107s pc-deployment-6696798b78-wvjd8 1/1 Running 0 107s 6.3.2 扩缩容 # 变更副本数量为5个 [root@k8s-master01 ~]# kubectl scale deploy pc-deployment --replicas=5 -n dev deployment.apps/pc-deployment scaled # 查看deployment [root@k8s-master01 ~]# kubectl get deploy pc-deployment -n dev NAME READY UP-TO-DATE AVAILABLE AGE pc-deployment 5/5 5 5 2m # 查看pod [root@k8s-master01 ~]# kubectl get pods -n dev NAME READY STATUS RESTARTS AGE pc-deployment-6696798b78-d2c8n 1/1 Running 0 4m19s pc-deployment-6696798b78-jxmdq 1/1 Running 0 94s pc-deployment-6696798b78-mktqv 1/1 Running 0 93s pc-deployment-6696798b78-smpvp 1/1 Running 0 4m19s pc-deployment-6696798b78-wvjd8 1/1 Running 0 4m19s # 编辑deployment的副本数量，修改spec:replicas: 4即可 [root@k8s-master01 ~]# kubectl edit deploy pc-deployment -n dev deployment.apps/pc-deployment edited # 查看pod [root@k8s-master01 ~]# kubectl get pods -n dev NAME READY STATUS RESTARTS AGE pc-deployment-6696798b78-d2c8n 1/1 Running 0 5m23s pc-deployment-6696798b78-jxmdq 1/1 Running 0 2m38s pc-deployment-6696798b78-smpvp 1/1 Running 0 5m23s pc-deployment-6696798b78-wvjd8 1/1 Running 0 5m23s 镜像更新\ndeployment 支持两种更新策略:重建更新和滚动更新,可以通过strategy指定策略类型,支持两个属性:\nstrategy：指定新的 Pod 替换旧的 Pod 的策略， 支持两个属性： type：指定策略类型，支持两种策略 Recreate：在创建出新的 Pod 之前会先杀掉所有已存在的 Pod RollingUpdate：滚动更新，就是杀死一部分，就启动一部分，在更新过程中，存在两个版本 Pod rollingUpdate：当 type 为 RollingUpdate 时生效，用于为 RollingUpdate 设置参数，支持两个属性： maxUnavailable：用来指定在升级过程中不可用 Pod 的最大数量，默认为 25%。 max 违规词汇： 用来指定在升级过程中可以超过期望的 Pod 的最大数量，默认为 25%。 重建更新\n编辑 pc-deployment.yaml,在 spec 节点下添加更新策略 spec: strategy: # 策略 type: Recreate # 重建更新 创建 deploy 进行验证\n# 变更镜像 [root@k8s-master01 ~]# kubectl set image deployment pc-deployment nginx=nginx:1.17.2 -n dev deployment.apps/pc-deployment image updated # 观察升级过程 [root@k8s-master01 ~]# kubectl get pods -n dev -w NAME READY STATUS RESTARTS AGE pc-deployment-5d89bdfbf9-65qcw 1/1 Running 0 31s pc-deployment-5d89bdfbf9-w5nzv 1/1 Running 0 31s pc-deployment-5d89bdfbf9-xpt7w 1/1 Running 0 31s pc-deployment-5d89bdfbf9-xpt7w 1/1 Terminating 0 41s pc-deployment-5d89bdfbf9-65qcw 1/1 Terminating 0 41s pc-deployment-5d89bdfbf9-w5nzv 1/1 Terminating 0 41s pc-deployment-675d469f8b-grn8z 0/1 Pending 0 0s pc-deployment-675d469f8b-hbl4v 0/1 Pending 0 0s pc-deployment-675d469f8b-67nz2 0/1 Pending 0 0s pc-deployment-675d469f8b-grn8z 0/1 ContainerCreating 0 0s pc-deployment-675d469f8b-hbl4v 0/1 ContainerCreating 0 0s pc-deployment-675d469f8b-67nz2 0/1 ContainerCreating 0 0s pc-deployment-675d469f8b-grn8z 1/1 Running 0 1s pc-deployment-675d469f8b-67nz2 1/1 Running 0 1s pc-deployment-675d469f8b-hbl4v 1/1 Running 0 2s 滚动更新\n编辑 pc-deployment.yaml,在 spec 节点下添加更新策略 spec: strategy: # 策略 type: RollingUpdate # 滚动更新策略 rollingUpdate: max违规词汇: 25% maxUnavailable: 25% 创建 deploy 进行验证\n# 变更镜像 [root@k8s-master01 ~]# kubectl set image deployment pc-deployment nginx=nginx:1.17.3 -n dev deployment.apps/pc-deployment image updated # 观察升级过程 [root@k8s-master01 ~]# kubectl get pods -n dev -w NAME READY STATUS RESTARTS AGE pc-deployment-c848d767-8rbzt 1/1 Running 0 31m pc-deployment-c848d767-h4p68 1/1 Running 0 31m pc-deployment-c848d767-hlmz4 1/1 Running 0 31m pc-deployment-c848d767-rrqcn 1/1 Running 0 31m pc-deployment-966bf7f44-226rx 0/1 Pending 0 0s pc-deployment-966bf7f44-226rx 0/1 ContainerCreating 0 0s pc-deployment-966bf7f44-226rx 1/1 Running 0 1s pc-deployment-c848d767-h4p68 0/1 Terminating 0 34m pc-deployment-966bf7f44-cnd44 0/1 Pending 0 0s pc-deployment-966bf7f44-cnd44 0/1 ContainerCreating 0 0s pc-deployment-966bf7f44-cnd44 1/1 Running 0 2s pc-deployment-c848d767-hlmz4 0/1 Terminating 0 34m pc-deployment-966bf7f44-px48p 0/1 Pending 0 0s pc-deployment-966bf7f44-px48p 0/1 ContainerCreating 0 0s pc-deployment-966bf7f44-px48p 1/1 Running 0 0s pc-deployment-c848d767-8rbzt 0/1 Terminating 0 34m pc-deployment-966bf7f44-dkmqp 0/1 Pending 0 0s pc-deployment-966bf7f44-dkmqp 0/1 ContainerCreating 0 0s pc-deployment-966bf7f44-dkmqp 1/1 Running 0 2s pc-deployment-c848d767-rrqcn 0/1 Terminating 0 34m # 至此，新版本的pod创建完毕，就版本的pod销毁完毕 # 中间过程是滚动进行的，也就是边销毁边创建 滚动更新的过程：\n镜像更新中 rs 的变化\n# 查看rs,发现原来的rs的依旧存在，只是pod数量变为了0，而后又新产生了一个rs，pod数量为4 # 其实这就是deployment能够进行版本回退的奥妙所在，后面会详细解释 [root@k8s-master01 ~]# kubectl get rs -n dev NAME DESIRED CURRENT READY AGE pc-deployment-6696798b78 0 0 0 7m37s pc-deployment-6696798b11 0 0 0 5m37s pc-deployment-c848d76789 4 4 4 72s 6.3.3 版本回退 deployment 支持版本升级过程中的暂停、继续功能以及版本回退等诸多功能，下面具体来看.\nkubectl rollout： 版本升级相关功能，支持下面的选项：\nstatus 显示当前升级状态 history 显示 升级历史记录 pause 暂停版本升级过程 resume 继续已经暂停的版本升级过程 restart 重启版本升级过程 undo 回滚到上一级版本（可以使用\u0026ndash;to-revision 回滚到指定版本） # 查看当前升级版本的状态 [root@k8s-master01 ~]# kubectl rollout status deploy pc-deployment -n dev deployment \u0026#34;pc-deployment\u0026#34; successfully rolled out # 查看升级历史记录 [root@k8s-master01 ~]# kubectl rollout history deploy pc-deployment -n dev deployment.apps/pc-deployment REVISION CHANGE-CAUSE 1 kubectl create --filename=pc-deployment.yaml --record=true 2 kubectl create --filename=pc-deployment.yaml --record=true 3 kubectl create --filename=pc-deployment.yaml --record=true # 可以发现有三次版本记录，说明完成过两次升级 # 版本回滚 # 这里直接使用--to-revision=1回滚到了1版本， 如果省略这个选项，就是回退到上个版本，就是2版本 [root@k8s-master01 ~]# kubectl rollout undo deployment pc-deployment --to-revision=1 -n dev deployment.apps/pc-deployment rolled back # 查看发现，通过nginx镜像版本可以发现到了第一版 [root@k8s-master01 ~]# kubectl get deploy -n dev -o wide NAME READY UP-TO-DATE AVAILABLE AGE CONTAINERS IMAGES pc-deployment 4/4 4 4 74m nginx nginx:1.17.1 # 查看rs，发现第一个rs中有4个pod运行，后面两个版本的rs中pod为运行 # 其实deployment之所以可是实现版本的回滚，就是通过记录下历史rs来实现的， # 一旦想回滚到哪个版本，只需要将当前版本pod数量降为0，然后将回滚版本的pod提升为目标数量就可以了 [root@k8s-master01 ~]# kubectl get rs -n dev NAME DESIRED CURRENT READY AGE pc-deployment-6696798b78 4 4 4 78m pc-deployment-966bf7f44 0 0 0 37m pc-deployment-c848d767 0 0 0 71m 6.3.4 金丝雀发布 Deployment 控制器支持控制更新过程中的控制，如“暂停(pause)”或“继续(resume)”更新操作。\n比如有一批新的 Pod 资源创建完成后立即暂停更新过程，此时，仅存在一部分新版本的应用，主体部分还是旧的版本。然后，再筛选一小部分的用户请求路由到新版本的 Pod 应用，继续观察能否稳定地按期望的方式运行。确定没问题之后再继续完成余下的 Pod 资源滚动更新，否则立即回滚更新操作。这就是所谓的金丝雀发布。\n# 更新deployment的版本，并配置暂停deployment [root@k8s-master01 ~]# kubectl set image deploy pc-deployment nginx=nginx:1.17.4 -n dev \u0026amp;\u0026amp; kubectl rollout pause deployment pc-deployment -n dev deployment.apps/pc-deployment image updated deployment.apps/pc-deployment paused #观察更新状态 [root@k8s-master01 ~]# kubectl rollout status deploy pc-deployment -n dev　Waiting for deployment \u0026#34;pc-deployment\u0026#34; rollout to finish: 2 out of 4 new replicas have been updated... # 监控更新的过程，可以看到已经新增了一个资源，但是并未按照预期的状态去删除一个旧的资源，就是因为使用了pause暂停命令 [root@k8s-master01 ~]# kubectl get rs -n dev -o wide NAME DESIRED CURRENT READY AGE CONTAINERS IMAGES pc-deployment-5d89bdfbf9 3 3 3 19m nginx nginx:1.17.1 pc-deployment-675d469f8b 0 0 0 14m nginx nginx:1.17.2 pc-deployment-6c9f56fcfb 2 2 2 3m16s nginx nginx:1.17.4 [root@k8s-master01 ~]# kubectl get pods -n dev NAME READY STATUS RESTARTS AGE pc-deployment-5d89bdfbf9-rj8sq 1/1 Running 0 7m33s pc-deployment-5d89bdfbf9-ttwgg 1/1 Running 0 7m35s pc-deployment-5d89bdfbf9-v4wvc 1/1 Running 0 7m34s pc-deployment-6c9f56fcfb-996rt 1/1 Running 0 3m31s pc-deployment-6c9f56fcfb-j2gtj 1/1 Running 0 3m31s # 确保更新的pod没问题了，继续更新 [root@k8s-master01 ~]# kubectl rollout resume deploy pc-deployment -n dev deployment.apps/pc-deployment resumed # 查看最后的更新情况 [root@k8s-master01 ~]# kubectl get rs -n dev -o wide NAME DESIRED CURRENT READY AGE CONTAINERS IMAGES pc-deployment-5d89bdfbf9 0 0 0 21m nginx nginx:1.17.1 pc-deployment-675d469f8b 0 0 0 16m nginx nginx:1.17.2 pc-deployment-6c9f56fcfb 4 4 4 5m11s nginx nginx:1.17.4 [root@k8s-master01 ~]# kubectl get pods -n dev NAME READY STATUS RESTARTS AGE pc-deployment-6c9f56fcfb-7bfwh 1/1 Running 0 37s pc-deployment-6c9f56fcfb-996rt 1/1 Running 0 5m27s pc-deployment-6c9f56fcfb-j2gtj 1/1 Running 0 5m27s pc-deployment-6c9f56fcfb-rf84v 1/1 Running 0 37s 删除 Deployment\n# 删除deployment，其下的rs和pod也将被删除 [root@k8s-master01 ~]# kubectl delete -f pc-deployment.yaml deployment.apps \u0026#34;pc-deployment\u0026#34; deleted 6.4 Horizontal Pod Autoscaler(HPA) 在前面的课程中，我们已经可以实现通过手工执行kubectl scale命令实现 Pod 扩容或缩容，但是这显然不符合 Kubernetes 的定位目标\u0026ndash;自动化、智能化。 Kubernetes 期望可以实现通过监测 Pod 的使用情况，实现 pod 数量的自动调整，于是就产生了 Horizontal Pod Autoscaler（HPA）这种控制器。\nHPA 可以获取每个 Pod 利用率，然后和 HPA 中定义的指标进行对比，同时计算出需要伸缩的具体值，最后实现 Pod 的数量的调整。其实 HPA 与之前的 Deployment 一样，也属于一种 Kubernetes 资源对象，它通过追踪分析 RC 控制的所有目标 Pod 的负载变化情况，来确定是否需要针对性地调整目标 Pod 的副本数，这是 HPA 的实现原理。\n接下来，我们来做一个实验\n6.4.1 安装 metrics-server metrics-server 可以用来收集集群中的资源使用情况\n# 安装git [root@k8s-master01 ~]# yum install git -y # 获取metrics-server, 注意使用的版本 [root@k8s-master01 ~]# git clone -b v0.3.6 https:/github.com/kubernetes-incubator/metrics-server # 修改deployment, 注意修改的是镜像和初始化参数 [root@k8s-master01 ~]# cd /root/metrics-server/deploy/1.8+/ [root@k8s-master01 1.8+]# vim metrics-server-deployment.yaml 按图中添加下面选项 hostNetwork: true image: registry.cn-hangzhou.aliyuncs.com/google_containers/metrics-server-amd64:v0.3.6 args: - --kubelet-insecure-tls - --kubelet-preferred-address-types=InternalIP,Hostname,InternalDNS,ExternalDNS,ExternalIP # 安装metrics-server [root@k8s-master01 1.8+]# kubectl apply -f ./ # 查看pod运行情况 [root@k8s-master01 1.8+]# kubectl get pod -n kube-system metrics-server-6b976979db-2xwbj 1/1 Running 0 90s # 使用kubectl top node 查看资源使用情况 [root@k8s-master01 1.8+]# kubectl top node NAME CPU(cores) CPU% MEMORY(bytes) MEMORY% k8s-master01 289m 14% 1582Mi 54% k8s-node01 81m 4% 1195Mi 40% k8s-node02 72m 3% 1211Mi 41% [root@k8s-master01 1.8+]# kubectl top pod -n kube-system NAME CPU(cores) MEMORY(bytes) coredns-6955765f44-7ptsb 3m 9Mi coredns-6955765f44-vcwr5 3m 8Mi etcd-master 14m 145Mi ... # 至此,metrics-server安装完成 6.4.2 准备 deployment 和 servie 创建 pc-hpa-pod.yaml 文件，内容如下：\napiVersion: apps/v1 kind: Deployment metadata: name: nginx namespace: dev spec: strategy: # 策略 type: RollingUpdate # 滚动更新策略 replicas: 1 selector: matchLabels: app: nginx-pod template: metadata: labels: app: nginx-pod spec: containers: - name: nginx image: nginx:1.17.1 resources: # 资源配额 limits: # 限制资源（上限） cpu: \u0026#34;1\u0026#34; # CPU限制，单位是core数 requests: # 请求资源（下限） cpu: \u0026#34;100m\u0026#34; # CPU限制，单位是core数 # 创建deployment [root@k8s-master01 1.8+]# kubectl run nginx --image=nginx:1.17.1 --requests=cpu=100m -n dev # 创建service [root@k8s-master01 1.8+]# kubectl expose deployment nginx --type=NodePort --port=80 -n dev # 查看 [root@k8s-master01 1.8+]# kubectl get deployment,pod,svc -n dev NAME READY UP-TO-DATE AVAILABLE AGE deployment.apps/nginx 1/1 1 1 47s NAME READY STATUS RESTARTS AGE pod/nginx-7df9756ccc-bh8dr 1/1 Running 0 47s NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE service/nginx NodePort 10.101.18.29 \u0026lt;none\u0026gt; 80:31830/TCP 35s 6.4.3 部署 HPA 创建 pc-hpa.yaml 文件，内容如下：\napiVersion: autoscaling/v1 kind: HorizontalPodAutoscaler metadata: name: pc-hpa namespace: dev spec: minReplicas: 1 #最小pod数量 maxReplicas: 10 #最大pod数量 targetCPUUtilizationPercentage: 3 # CPU使用率指标 scaleTargetRef: # 指定要控制的nginx信息 apiVersion: /v1 kind: Deployment name: nginx # 创建hpa [root@k8s-master01 1.8+]# kubectl create -f pc-hpa.yaml horizontalpodautoscaler.autoscaling/pc-hpa created # 查看hpa [root@k8s-master01 1.8+]# kubectl get hpa -n dev NAME REFERENCE TARGETS MINPODS MAXPODS REPLICAS AGE pc-hpa Deployment/nginx 0%/3% 1 10 1 62s 6.4.4 测试 使用压测工具对 service 地址192.168.5.4:31830进行压测，然后通过控制台查看 hpa 和 pod 的变化\nhpa 变化\n[root@k8s-master01 ~]# kubectl get hpa -n dev -w NAME REFERENCE TARGETS MINPODS MAXPODS REPLICAS AGE pc-hpa Deployment/nginx 0%/3% 1 10 1 4m11s pc-hpa Deployment/nginx 0%/3% 1 10 1 5m19s pc-hpa Deployment/nginx 22%/3% 1 10 1 6m50s pc-hpa Deployment/nginx 22%/3% 1 10 4 7m5s pc-hpa Deployment/nginx 22%/3% 1 10 8 7m21s pc-hpa Deployment/nginx 6%/3% 1 10 8 7m51s pc-hpa Deployment/nginx 0%/3% 1 10 8 9m6s pc-hpa Deployment/nginx 0%/3% 1 10 8 13m pc-hpa Deployment/nginx 0%/3% 1 10 1 14m deployment 变化\n[root@k8s-master01 ~]# kubectl get deployment -n dev -w NAME READY UP-TO-DATE AVAILABLE AGE nginx 1/1 1 1 11m nginx 1/4 1 1 13m nginx 1/4 1 1 13m nginx 1/4 1 1 13m nginx 1/4 4 1 13m nginx 1/8 4 1 14m nginx 1/8 4 1 14m nginx 1/8 4 1 14m nginx 1/8 8 1 14m nginx 2/8 8 2 14m nginx 3/8 8 3 14m nginx 4/8 8 4 14m nginx 5/8 8 5 14m nginx 6/8 8 6 14m nginx 7/8 8 7 14m nginx 8/8 8 8 15m nginx 8/1 8 8 20m nginx 8/1 8 8 20m nginx 1/1 1 1 20m pod 变化\n[root@k8s-master01 ~]# kubectl get pods -n dev -w NAME READY STATUS RESTARTS AGE nginx-7df9756ccc-bh8dr 1/1 Running 0 11m nginx-7df9756ccc-cpgrv 0/1 Pending 0 0s nginx-7df9756ccc-8zhwk 0/1 Pending 0 0s nginx-7df9756ccc-rr9bn 0/1 Pending 0 0s nginx-7df9756ccc-cpgrv 0/1 ContainerCreating 0 0s nginx-7df9756ccc-8zhwk 0/1 ContainerCreating 0 0s nginx-7df9756ccc-rr9bn 0/1 ContainerCreating 0 0s nginx-7df9756ccc-m9gsj 0/1 Pending 0 0s nginx-7df9756ccc-g56qb 0/1 Pending 0 0s nginx-7df9756ccc-sl9c6 0/1 Pending 0 0s nginx-7df9756ccc-fgst7 0/1 Pending 0 0s nginx-7df9756ccc-g56qb 0/1 ContainerCreating 0 0s nginx-7df9756ccc-m9gsj 0/1 ContainerCreating 0 0s nginx-7df9756ccc-sl9c6 0/1 ContainerCreating 0 0s nginx-7df9756ccc-fgst7 0/1 ContainerCreating 0 0s nginx-7df9756ccc-8zhwk 1/1 Running 0 19s nginx-7df9756ccc-rr9bn 1/1 Running 0 30s nginx-7df9756ccc-m9gsj 1/1 Running 0 21s nginx-7df9756ccc-cpgrv 1/1 Running 0 47s nginx-7df9756ccc-sl9c6 1/1 Running 0 33s nginx-7df9756ccc-g56qb 1/1 Running 0 48s nginx-7df9756ccc-fgst7 1/1 Running 0 66s nginx-7df9756ccc-fgst7 1/1 Terminating 0 6m50s nginx-7df9756ccc-8zhwk 1/1 Terminating 0 7m5s nginx-7df9756ccc-cpgrv 1/1 Terminating 0 7m5s nginx-7df9756ccc-g56qb 1/1 Terminating 0 6m50s nginx-7df9756ccc-rr9bn 1/1 Terminating 0 7m5s nginx-7df9756ccc-m9gsj 1/1 Terminating 0 6m50s nginx-7df9756ccc-sl9c6 1/1 Terminating 0 6m50s 6.5 DaemonSet(DS) DaemonSet 类型的控制器可以保证在集群中的每一台（或指定）节点上都运行一个副本。一般适用于日志收集、节点监控等场景。也就是说，如果一个 Pod 提供的功能是节点级别的（每个节点都需要且只需要一个），那么这类 Pod 就适合使用 DaemonSet 类型的控制器创建。\nDaemonSet 控制器的特点：\n每当向集群中添加一个节点时，指定的 Pod 副本也将添加到该节点上 当节点从集群中移除时，Pod 也就被垃圾回收了 下面先来看下 DaemonSet 的资源清单文件\napiVersion: apps/v1 # 版本号 kind: DaemonSet # 类型 metadata: # 元数据 name: # rs名称 namespace: # 所属命名空间 labels: #标签 controller: daemonset spec: # 详情描述 revisionHistoryLimit: 3 # 保留历史版本 updateStrategy: # 更新策略 type: RollingUpdate # 滚动更新策略 rollingUpdate: # 滚动更新 maxUnavailable: 1 # 最大不可用状态的 Pod 的最大值，可以为百分比，也可以为整数 selector: # 选择器，通过它指定该控制器管理哪些pod matchLabels: # Labels匹配规则 app: nginx-pod matchExpressions: # Expressions匹配规则 - { key: app, operator: In, values: [nginx-pod] } template: # 模板，当副本数量不足时，会根据下面的模板创建pod副本 metadata: labels: app: nginx-pod spec: containers: - name: nginx image: nginx:1.17.1 ports: - containerPort: 80 创建 pc-daemonset.yaml，内容如下：\napiVersion: apps/v1 kind: DaemonSet metadata: name: pc-daemonset namespace: dev spec: selector: matchLabels: app: nginx-pod template: metadata: labels: app: nginx-pod spec: containers: - name: nginx image: nginx:1.17.1 # 创建daemonset [root@k8s-master01 ~]# kubectl create -f pc-daemonset.yaml daemonset.apps/pc-daemonset created # 查看daemonset [root@k8s-master01 ~]# kubectl get ds -n dev -o wide NAME DESIRED CURRENT READY UP-TO-DATE AVAILABLE AGE CONTAINERS IMAGES pc-daemonset 2 2 2 2 2 24s nginx nginx:1.17.1 # 查看pod,发现在每个Node上都运行一个pod [root@k8s-master01 ~]# kubectl get pods -n dev -o wide NAME READY STATUS RESTARTS AGE IP NODE pc-daemonset-9bck8 1/1 Running 0 37s 10.244.1.43 node1 pc-daemonset-k224w 1/1 Running 0 37s 10.244.2.74 node2 # 删除daemonset [root@k8s-master01 ~]# kubectl delete -f pc-daemonset.yaml daemonset.apps \u0026#34;pc-daemonset\u0026#34; deleted 6.6 Job Job，主要用于负责批量处理(一次要处理指定数量任务)短暂的一次性(每个任务仅运行一次就结束)任务。Job 特点如下：\n当 Job 创建的 pod 执行成功结束时，Job 将记录成功结束的 pod 数量 当成功结束的 pod 达到指定的数量时，Job 将完成执行 Job 的资源清单文件：\napiVersion: batch/v1 # 版本号 kind: Job # 类型 metadata: # 元数据 name: # rs名称 namespace: # 所属命名空间 labels: #标签 controller: job spec: # 详情描述 completions: 1 # 指定job需要成功运行Pods的次数。默认值: 1 parallelism: 1 # 指定job在任一时刻应该并发运行Pods的数量。默认值: 1 activeDeadlineSeconds: 30 # 指定job可运行的时间期限，超过时间还未结束，系统将会尝试进行终止。 backoffLimit: 6 # 指定job失败后进行重试的次数。默认是6 manualSelector: true # 是否可以使用selector选择器选择pod，默认是false selector: # 选择器，通过它指定该控制器管理哪些pod matchLabels: # Labels匹配规则 app: counter-pod matchExpressions: # Expressions匹配规则 - { key: app, operator: In, values: [counter-pod] } template: # 模板，当副本数量不足时，会根据下面的模板创建pod副本 metadata: labels: app: counter-pod spec: restartPolicy: Never # 重启策略只能设置为Never或者OnFailure containers: - name: counter image: busybox:1.30 command: [ \u0026#34;bin/sh\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;for i in 9 8 7 6 5 4 3 2 1; do echo $i;sleep 2;done\u0026#34;, ] 关于重启策略设置的说明： 如果指定为 OnFailure，则 job 会在 pod 出现故障时重启容器，而不是创建 pod，failed 次数不变 如果指定为 Never，则 job 会在 pod 出现故障时创建新的 pod，并且故障 pod 不会消失，也不会重启，failed 次数加 1 如果指定为 Always 的话，就意味着一直重启，意味着 job 任务会重复去执行了，当然不对，所以不能设置为 Always 创建 pc-job.yaml，内容如下：\napiVersion: batch/v1 kind: Job metadata: name: pc-job namespace: dev spec: manualSelector: true selector: matchLabels: app: counter-pod template: metadata: labels: app: counter-pod spec: restartPolicy: Never containers: - name: counter image: busybox:1.30 command: [ \u0026#34;bin/sh\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;for i in 9 8 7 6 5 4 3 2 1; do echo $i;sleep 3;done\u0026#34;, ] # 创建job [root@k8s-master01 ~]# kubectl create -f pc-job.yaml job.batch/pc-job created # 查看job [root@k8s-master01 ~]# kubectl get job -n dev -o wide -w NAME COMPLETIONS DURATION AGE CONTAINERS IMAGES SELECTOR pc-job 0/1 21s 21s counter busybox:1.30 app=counter-pod pc-job 1/1 31s 79s counter busybox:1.30 app=counter-pod # 通过观察pod状态可以看到，pod在运行完毕任务后，就会变成Completed状态 [root@k8s-master01 ~]# kubectl get pods -n dev -w NAME READY STATUS RESTARTS AGE pc-job-rxg96 1/1 Running 0 29s pc-job-rxg96 0/1 Completed 0 33s # 接下来，调整下pod运行的总数量和并行数量 即：在spec下设置下面两个选项 # completions: 6 # 指定job需要成功运行Pods的次数为6 # parallelism: 3 # 指定job并发运行Pods的数量为3 # 然后重新运行job，观察效果，此时会发现，job会每次运行3个pod，总共执行了6个pod [root@k8s-master01 ~]# kubectl get pods -n dev -w NAME READY STATUS RESTARTS AGE pc-job-684ft 1/1 Running 0 5s pc-job-jhj49 1/1 Running 0 5s pc-job-pfcvh 1/1 Running 0 5s pc-job-684ft 0/1 Completed 0 11s pc-job-v7rhr 0/1 Pending 0 0s pc-job-v7rhr 0/1 Pending 0 0s pc-job-v7rhr 0/1 ContainerCreating 0 0s pc-job-jhj49 0/1 Completed 0 11s pc-job-fhwf7 0/1 Pending 0 0s pc-job-fhwf7 0/1 Pending 0 0s pc-job-pfcvh 0/1 Completed 0 11s pc-job-5vg2j 0/1 Pending 0 0s pc-job-fhwf7 0/1 ContainerCreating 0 0s pc-job-5vg2j 0/1 Pending 0 0s pc-job-5vg2j 0/1 ContainerCreating 0 0s pc-job-fhwf7 1/1 Running 0 2s pc-job-v7rhr 1/1 Running 0 2s pc-job-5vg2j 1/1 Running 0 3s pc-job-fhwf7 0/1 Completed 0 12s pc-job-v7rhr 0/1 Completed 0 12s pc-job-5vg2j 0/1 Completed 0 12s # 删除job [root@k8s-master01 ~]# kubectl delete -f pc-job.yaml job.batch \u0026#34;pc-job\u0026#34; deleted 6.7 CronJob(CJ) CronJob 控制器以 Job 控制器资源为其管控对象，并借助它管理 pod 资源对象，Job 控制器定义的作业任务在其控制器资源创建之后便会立即执行，但 CronJob 可以以类似于 Linux 操作系统的周期性任务作业计划的方式控制其运行时间点及重复运行的方式。也就是说，CronJob 可以在特定的时间点(反复的)去运行 job 任务。\nCronJob 的资源清单文件：\napiVersion: batch/v1beta1 # 版本号 kind: CronJob # 类型 metadata: # 元数据 name: # rs名称 namespace: # 所属命名空间 labels: #标签 controller: cronjob spec: # 详情描述 schedule: # cron格式的作业调度运行时间点,用于控制任务在什么时间执行 concurrencyPolicy: # 并发执行策略，用于定义前一次作业运行尚未完成时是否以及如何运行后一次的作业 failedJobHistoryLimit: # 为失败的任务执行保留的历史记录数，默认为1 successfulJobHistoryLimit: # 为成功的任务执行保留的历史记录数，默认为3 startingDeadlineSeconds: # 启动作业错误的超时时长 jobTemplate: # job控制器模板，用于为cronjob控制器生成job对象;下面其实就是job的定义 metadata: spec: completions: 1 parallelism: 1 activeDeadlineSeconds: 30 backoffLimit: 6 manualSelector: true selector: matchLabels: app: counter-pod matchExpressions: 规则 - {key: app, operator: In, values: [counter-pod]} template: metadata: labels: app: counter-pod spec: restartPolicy: Never containers: - name: counter image: busybox:1.30 command: [\u0026#34;bin/sh\u0026#34;,\u0026#34;-c\u0026#34;,\u0026#34;for i in 9 8 7 6 5 4 3 2 1; do echo $i;sleep 20;done\u0026#34;] 需要重点解释的几个选项： schedule: cron 表达式，用于指定任务的执行时间 _/1 _ \\* \\* \\* \u0026lt;分钟\u0026gt; \u0026lt;小时\u0026gt; \u0026lt;日\u0026gt; \u0026lt;月份\u0026gt; \u0026lt;星期\u0026gt; 分钟 值从 0 到 59. 小时 值从 0 到 23. 日 值从 1 到 31. 月 值从 1 到 12. 星期 值从 0 到 6, 0 代表星期日 多个时间可以用逗号隔开； 范围可以用连字符给出；*可以作为通配符； /表示每... concurrencyPolicy: Allow: 允许 Jobs 并发运行(默认) Forbid: 禁止并发运行，如果上一次运行尚未完成，则跳过下一次运行 Replace: 替换，取消当前正在运行的作业并用新作业替换它 创建 pc-cronjob.yaml，内容如下：\napiVersion: batch/v1beta1 kind: CronJob metadata: name: pc-cronjob namespace: dev labels: controller: cronjob spec: schedule: \u0026#34;*/1 * * * *\u0026#34; jobTemplate: metadata: spec: template: spec: restartPolicy: Never containers: - name: counter image: busybox:1.30 command: [ \u0026#34;bin/sh\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;for i in 9 8 7 6 5 4 3 2 1; do echo $i;sleep 3;done\u0026#34;, ] # 创建cronjob [root@k8s-master01 ~]# kubectl create -f pc-cronjob.yaml cronjob.batch/pc-cronjob created # 查看cronjob [root@k8s-master01 ~]# kubectl get cronjobs -n dev NAME SCHEDULE SUSPEND ACTIVE LAST SCHEDULE AGE pc-cronjob */1 * * * * False 0 \u0026lt;none\u0026gt; 6s # 查看job [root@k8s-master01 ~]# kubectl get jobs -n dev NAME COMPLETIONS DURATION AGE pc-cronjob-1592587800 1/1 28s 3m26s pc-cronjob-1592587860 1/1 28s 2m26s pc-cronjob-1592587920 1/1 28s 86s # 查看pod [root@k8s-master01 ~]# kubectl get pods -n dev pc-cronjob-1592587800-x4tsm 0/1 Completed 0 2m24s pc-cronjob-1592587860-r5gv4 0/1 Completed 0 84s pc-cronjob-1592587920-9dxxq 1/1 Running 0 24s # 删除cronjob [root@k8s-master01 ~]# kubectl delete -f pc-cronjob.yaml cronjob.batch \u0026#34;pc-cronjob\u0026#34; deleted 7. Service 详解 7.1 Service 介绍 在 kubernetes 中，pod 是应用程序的载体，我们可以通过 pod 的 ip 来访问应用程序，但是 pod 的 ip 地址不是固定的，这也就意味着不方便直接采用 pod 的 ip 对服务进行访问。\n为了解决这个问题，kubernetes 提供了 Service 资源，Service 会对提供同一个服务的多个 pod 进行聚合，并且提供一个统一的入口地址。通过访问 Service 的入口地址就能访问到后面的 pod 服务。\nService 在很多情况下只是一个概念，真正起作用的其实是 kube-proxy 服务进程，每个 Node 节点上都运行着一个 kube-proxy 服务进程。当创建 Service 的时候会通过 api-server 向 etcd 写入创建的 service 的信息，而 kube-proxy 会基于监听的机制发现这种 Service 的变动，然后它会将最新的 Service 信息转换成对应的访问规则。\n# 10.97.97.97:80 是service提供的访问入口 # 当访问这个入口的时候，可以发现后面有三个pod的服务在等待调用， # kube-proxy会基于rr（轮询）的策略，将请求分发到其中一个pod上去 # 这个规则会同时在集群内的所有节点上都生成，所以在任何一个节点上，都可以访问。 [root@node1 ~]# ipvsadm -Ln IP Virtual Server version 1.2.1 (size=4096) Prot LocalAddress:Port Scheduler Flags -\u0026gt; RemoteAddress:Port Forward Weight ActiveConn InActConn TCP 10.97.97.97:80 rr -\u0026gt; 10.244.1.39:80 Masq 1 0 0 -\u0026gt; 10.244.1.40:80 Masq 1 0 0 -\u0026gt; 10.244.2.33:80 Masq 1 0 0 kube-proxy 目前支持三种工作模式:\n7.1.1 userspace 模式 userspace 模式下，kube-proxy 会为每一个 Service 创建一个监听端口，发向 Cluster IP 的请求被 Iptables 规则重定向到 kube-proxy 监听的端口上，kube-proxy 根据 LB 算法选择一个提供服务的 Pod 并和其建立链接，以将请求转发到 Pod 上。 该模式下，kube-proxy 充当了一个四层负责均衡器的角色。由于 kube-proxy 运行在 userspace 中，在进行转发处理时会增加内核和用户空间之间的数据拷贝，虽然比较稳定，但是效率比较低。\n7.1.2 iptables 模式 iptables 模式下，kube-proxy 为 service 后端的每个 Pod 创建对应的 iptables 规则，直接将发向 Cluster IP 的请求重定向到一个 Pod IP。 该模式下 kube-proxy 不承担四层负责均衡器的角色，只负责创建 iptables 规则。该模式的优点是较 userspace 模式效率更高，但不能提供灵活的 LB 策略，当后端 Pod 不可用时也无法进行重试。\n7.1.3 ipvs 模式 ipvs 模式和 iptables 类似，kube-proxy 监控 Pod 的变化并创建相应的 ipvs 规则。ipvs 相对 iptables 转发效率更高。除此以外，ipvs 支持更多的 LB 算法。\n# 此模式必须安装ipvs内核模块，否则会降级为iptables # 开启ipvs [root@k8s-master01 ~]# kubectl edit cm kube-proxy -n kube-system # 修改mode: \u0026#34;ipvs\u0026#34; [root@k8s-master01 ~]# kubectl delete pod -l k8s-app=kube-proxy -n kube-system [root@node1 ~]# ipvsadm -Ln IP Virtual Server version 1.2.1 (size=4096) Prot LocalAddress:Port Scheduler Flags -\u0026gt; RemoteAddress:Port Forward Weight ActiveConn InActConn TCP 10.97.97.97:80 rr -\u0026gt; 10.244.1.39:80 Masq 1 0 0 -\u0026gt; 10.244.1.40:80 Masq 1 0 0 -\u0026gt; 10.244.2.33:80 Masq 1 0 0 7.2 Service 类型 Service 的资源清单文件：\nkind: Service # 资源类型 apiVersion: v1 # 资源版本 metadata: # 元数据 name: service # 资源名称 namespace: dev # 命名空间 spec: # 描述 selector: # 标签选择器，用于确定当前service代理哪些pod app: nginx type: # Service类型，指定service的访问方式 clusterIP: # 虚拟服务的ip地址 sessionAffinity: # session亲和性，支持ClientIP、None两个选项 ports: # 端口信息 - protocol: TCP port: 3017 # service端口 targetPort: 5003 # pod端口 nodePort: 31122 # 主机端口 ClusterIP：默认值，它是 Kubernetes 系统自动分配的虚拟 IP，只能在集群内部访问 NodePort：将 Service 通过指定的 Node 上的端口暴露给外部，通过此方法，就可以在集群外部访问服务 LoadBalancer：使用外接负载均衡器完成到服务的负载分发，注意此模式需要外部云环境支持 ExternalName： 把集群外部的服务引入集群内部，直接使用 7.3 Service 使用 7.3.1 实验环境准备 在使用 service 之前，首先利用 Deployment 创建出 3 个 pod，注意要为 pod 设置app=nginx-pod的标签\n创建 deployment.yaml，内容如下：\napiVersion: apps/v1 kind: Deployment metadata: name: pc-deployment namespace: dev spec: replicas: 3 selector: matchLabels: app: nginx-pod template: metadata: labels: app: nginx-pod spec: containers: - name: nginx image: nginx:1.17.1 ports: - containerPort: 80 [root@k8s-master01 ~]# kubectl create -f deployment.yaml deployment.apps/pc-deployment created # 查看pod详情 [root@k8s-master01 ~]# kubectl get pods -n dev -o wide --show-labels NAME READY STATUS IP NODE LABELS pc-deployment-66cb59b984-8p84h 1/1 Running 10.244.1.39 node1 app=nginx-pod pc-deployment-66cb59b984-vx8vx 1/1 Running 10.244.2.33 node2 app=nginx-pod pc-deployment-66cb59b984-wnncx 1/1 Running 10.244.1.40 node1 app=nginx-pod # 为了方便后面的测试，修改下三台nginx的index.html页面（三台修改的IP地址不一致） # kubectl exec -it pc-deployment-66cb59b984-8p84h -n dev /bin/sh # echo \u0026#34;10.244.1.39\u0026#34; \u0026gt; /usr/share/nginx/html/index.html #修改完毕之后，访问测试 [root@k8s-master01 ~]# curl 10.244.1.39 10.244.1.39 [root@k8s-master01 ~]# curl 10.244.2.33 10.244.2.33 [root@k8s-master01 ~]# curl 10.244.1.40 10.244.1.40 7.3.2 ClusterIP 类型的 Service 创建 service-clusterip.yaml 文件\napiVersion: v1 kind: Service metadata: name: service-clusterip namespace: dev spec: selector: app: nginx-pod clusterIP: 10.97.97.97 # service的ip地址，如果不写，默认会生成一个 type: ClusterIP ports: - port: 80 # Service端口 targetPort: 80 # pod端口 # 创建service [root@k8s-master01 ~]# kubectl create -f service-clusterip.yaml service/service-clusterip created # 查看service [root@k8s-master01 ~]# kubectl get svc -n dev -o wide NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE SELECTOR service-clusterip ClusterIP 10.97.97.97 \u0026lt;none\u0026gt; 80/TCP 13s app=nginx-pod # 查看service的详细信息 # 在这里有一个Endpoints列表，里面就是当前service可以负载到的服务入口 [root@k8s-master01 ~]# kubectl describe svc service-clusterip -n dev Name: service-clusterip Namespace: dev Labels: \u0026lt;none\u0026gt; Annotations: \u0026lt;none\u0026gt; Selector: app=nginx-pod Type: ClusterIP IP: 10.97.97.97 Port: \u0026lt;unset\u0026gt; 80/TCP TargetPort: 80/TCP Endpoints: 10.244.1.39:80,10.244.1.40:80,10.244.2.33:80 Session Affinity: None Events: \u0026lt;none\u0026gt; # 查看ipvs的映射规则 [root@k8s-master01 ~]# ipvsadm -Ln TCP 10.97.97.97:80 rr -\u0026gt; 10.244.1.39:80 Masq 1 0 0 -\u0026gt; 10.244.1.40:80 Masq 1 0 0 -\u0026gt; 10.244.2.33:80 Masq 1 0 0 # 访问10.97.97.97:80观察效果 [root@k8s-master01 ~]# curl 10.97.97.97:80 10.244.2.33 7.3.3 Endpoint Endpoint 是 kubernetes 中的一个资源对象，存储在 etcd 中，用来记录一个 service 对应的所有 pod 的访问地址，它是根据 service 配置文件中 selector 描述产生的。\n一个 Service 由一组 Pod 组成，这些 Pod 通过 Endpoints 暴露出来，Endpoints 是实现实际服务的端点集合。换句话说，service 和 pod 之间的联系是通过 endpoints 实现的。\n负载分发策略\n对 Service 的访问被分发到了后端的 Pod 上去，目前 kubernetes 提供了两种负载分发策略：\n如果不定义，默认使用 kube-proxy 的策略，比如随机、轮询\n基于客户端地址的会话保持模式，即来自同一个客户端发起的所有请求都会转发到固定的一个 Pod 上\n此模式可以使在 spec 中添加sessionAffinity:ClientIP选项\n# 查看ipvs的映射规则【rr 轮询】 [root@k8s-master01 ~]# ipvsadm -Ln TCP 10.97.97.97:80 rr -\u0026gt; 10.244.1.39:80 Masq 1 0 0 -\u0026gt; 10.244.1.40:80 Masq 1 0 0 -\u0026gt; 10.244.2.33:80 Masq 1 0 0 # 循环访问测试 [root@k8s-master01 ~]# while true;do curl 10.97.97.97:80; sleep 5; done; 10.244.1.40 10.244.1.39 10.244.2.33 10.244.1.40 10.244.1.39 10.244.2.33 # 修改分发策略----sessionAffinity:ClientIP # 查看ipvs规则【persistent 代表持久】 [root@k8s-master01 ~]# ipvsadm -Ln TCP 10.97.97.97:80 rr persistent 10800 -\u0026gt; 10.244.1.39:80 Masq 1 0 0 -\u0026gt; 10.244.1.40:80 Masq 1 0 0 -\u0026gt; 10.244.2.33:80 Masq 1 0 0 # 循环访问测试 [root@k8s-master01 ~]# while true;do curl 10.97.97.97; sleep 5; done; 10.244.2.33 10.244.2.33 10.244.2.33 # 删除service [root@k8s-master01 ~]# kubectl delete -f service-clusterip.yaml service \u0026#34;service-clusterip\u0026#34; deleted 7.3.4 HeadLiness 类型的 Service 在某些场景中，开发人员可能不想使用 Service 提供的负载均衡功能，而希望自己来控制负载均衡策略，针对这种情况，kubernetes 提供了 HeadLiness Service，这类 Service 不会分配 Cluster IP，如果想要访问 service，只能通过 service 的域名进行查询。\n创建 service-headliness.yaml\napiVersion: v1 kind: Service metadata: name: service-headliness namespace: dev spec: selector: app: nginx-pod clusterIP: None # 将clusterIP设置为None，即可创建headliness Service type: ClusterIP ports: - port: 80 targetPort: 80 # 创建service [root@k8s-master01 ~]# kubectl create -f service-headliness.yaml service/service-headliness created # 获取service， 发现CLUSTER-IP未分配 [root@k8s-master01 ~]# kubectl get svc service-headliness -n dev -o wide NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE SELECTOR service-headliness ClusterIP None \u0026lt;none\u0026gt; 80/TCP 11s app=nginx-pod # 查看service详情 [root@k8s-master01 ~]# kubectl describe svc service-headliness -n dev Name: service-headliness Namespace: dev Labels: \u0026lt;none\u0026gt; Annotations: \u0026lt;none\u0026gt; Selector: app=nginx-pod Type: ClusterIP IP: None Port: \u0026lt;unset\u0026gt; 80/TCP TargetPort: 80/TCP Endpoints: 10.244.1.39:80,10.244.1.40:80,10.244.2.33:80 Session Affinity: None Events: \u0026lt;none\u0026gt; # 查看域名的解析情况 [root@k8s-master01 ~]# kubectl exec -it pc-deployment-66cb59b984-8p84h -n dev /bin/sh / # cat /etc/resolv.conf nameserver 10.96.0.10 search dev.svc.cluster.local svc.cluster.local cluster.local [root@k8s-master01 ~]# dig @10.96.0.10 service-headliness.dev.svc.cluster.local service-headliness.dev.svc.cluster.local. 30 IN A 10.244.1.40 service-headliness.dev.svc.cluster.local. 30 IN A 10.244.1.39 service-headliness.dev.svc.cluster.local. 30 IN A 10.244.2.33 7.3.5 NodePort 类型的 Service 在之前的样例中，创建的 Service 的 ip 地址只有集群内部才可以访问，如果希望将 Service 暴露给集群外部使用，那么就要使用到另外一种类型的 Service，称为 NodePort 类型。NodePort 的工作原理其实就是将 service 的端口映射到 Node 的一个端口上，然后就可以通过NodeIp:NodePort来访问 service 了。\n创建 service-nodeport.yaml\napiVersion: v1 kind: Service metadata: name: service-nodeport namespace: dev spec: selector: app: nginx-pod type: NodePort # service类型 ports: - port: 80 nodePort: 30002 # 指定绑定的node的端口(默认的取值范围是：30000-32767), 如果不指定，会默认分配 targetPort: 80 # 创建service [root@k8s-master01 ~]# kubectl create -f service-nodeport.yaml service/service-nodeport created # 查看service [root@k8s-master01 ~]# kubectl get svc -n dev -o wide NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) SELECTOR service-nodeport NodePort 10.105.64.191 \u0026lt;none\u0026gt; 80:30002/TCP app=nginx-pod # 接下来可以通过电脑主机的浏览器去访问集群中任意一个nodeip的30002端口，即可访问到pod 7.3.6 LoadBalancer 类型的 Service LoadBalancer 和 NodePort 很相似，目的都是向外部暴露一个端口，区别在于 LoadBalancer 会在集群的外部再来做一个负载均衡设备，而这个设备需要外部环境支持的，外部服务发送到这个设备上的请求，会被设备负载之后转发到集群中。\n7.3.7 ExternalName 类型的 Service ExternalName 类型的 Service 用于引入集群外部的服务，它通过externalName属性指定外部一个服务的地址，然后在集群内部访问此 service 就可以访问到外部的服务了。\napiVersion: v1 kind: Service metadata: name: service-externalname namespace: dev spec: type: ExternalName # service类型 externalName: www.baidu.com #改成ip地址也可以 # 创建service [root@k8s-master01 ~]# kubectl create -f service-externalname.yaml service/service-externalname created # 域名解析 [root@k8s-master01 ~]# dig @10.96.0.10 service-externalname.dev.svc.cluster.local service-externalname.dev.svc.cluster.local. 30 IN CNAME www.baidu.com. www.baidu.com. 30 IN CNAME www.a.shifen.com. www.a.shifen.com. 30 IN A 39.156.66.18 www.a.shifen.com. 30 IN A 39.156.66.14 7.4 Ingress 介绍 在前面课程中已经提到，Service 对集群之外暴露服务的主要方式有两种：NotePort 和 LoadBalancer，但是这两种方式，都有一定的缺点：\nNodePort 方式的缺点是会占用很多集群机器的端口，那么当集群服务变多的时候，这个缺点就愈发明显 LB 方式的缺点是每个 service 需要一个 LB，浪费、麻烦，并且需要 kubernetes 之外设备的支持 基于这种现状，kubernetes 提供了 Ingress 资源对象，Ingress 只需要一个 NodePort 或者一个 LB 就可以满足暴露多个 Service 的需求。工作机制大致如下图表示：\n实际上，Ingress 相当于一个 7 层的负载均衡器，是 kubernetes 对反向代理的一个抽象，它的工作原理类似于 Nginx，可以理解成在 Ingress 里建立诸多映射规则，Ingress Controller 通过监听这些配置规则并转化成 Nginx 的反向代理配置 , 然后对外部提供服务。在这里有两个核心概念：\ningress：kubernetes 中的一个对象，作用是定义请求如何转发到 service 的规则 ingress controller：具体实现反向代理及负载均衡的程序，对 ingress 定义的规则进行解析，根据配置的规则来实现请求转发，实现方式有很多，比如 Nginx, Contour, Haproxy 等等 Ingress（以 Nginx 为例）的工作原理如下：\n用户编写 Ingress 规则，说明哪个域名对应 kubernetes 集群中的哪个 Service Ingress 控制器动态感知 Ingress 服务规则的变化，然后生成一段对应的 Nginx 反向代理配置 Ingress 控制器会将生成的 Nginx 配置写入到一个运行着的 Nginx 服务中，并动态更新 到此为止，其实真正在工作的就是一个 Nginx 了，内部配置了用户定义的请求转发规则 7.5 Ingress 使用 7.5.1 环境准备 搭建 ingress 环境 # 创建文件夹 [root@k8s-master01 ~]# mkdir ingress-controller [root@k8s-master01 ~]# cd ingress-controller/ # 获取ingress-nginx，本次案例使用的是0.30版本 [root@k8s-master01 ingress-controller]# wget https:/raw.githubusercontent.com/kubernetes/ingress-nginx/nginx-0.30.0/deploy/static/mandatory.yaml [root@k8s-master01 ingress-controller]# wget https:/raw.githubusercontent.com/kubernetes/ingress-nginx/nginx-0.30.0/deploy/static/provider/baremetal/service-nodeport.yaml # 修改mandatory.yaml文件中的仓库 # 修改quay.io/kubernetes-ingress-controller/nginx-ingress-controller:0.30.0 # 为quay-mirror.qiniu.com/kubernetes-ingress-controller/nginx-ingress-controller:0.30.0 # 创建ingress-nginx [root@k8s-master01 ingress-controller]# kubectl apply -f ./ # 查看ingress-nginx [root@k8s-master01 ingress-controller]# kubectl get pod -n ingress-nginx NAME READY STATUS RESTARTS AGE pod/nginx-ingress-controller-fbf967dd5-4qpbp 1/1 Running 0 12h # 查看service [root@k8s-master01 ingress-controller]# kubectl get svc -n ingress-nginx NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE ingress-nginx NodePort 10.98.75.163 \u0026lt;none\u0026gt; 80:32240/TCP,443:31335/TCP 11h 7.5.2 准备 service 和 pod 为了后面的实验比较方便，创建如下图所示的模型\n创建 tomcat-nginx.yaml\napiVersion: apps/v1 kind: Deployment metadata: name: nginx-deployment namespace: dev spec: replicas: 3 selector: matchLabels: app: nginx-pod template: metadata: labels: app: nginx-pod spec: containers: - name: nginx image: nginx:1.17.1 ports: - containerPort: 80 --- apiVersion: apps/v1 kind: Deployment metadata: name: tomcat-deployment namespace: dev spec: replicas: 3 selector: matchLabels: app: tomcat-pod template: metadata: labels: app: tomcat-pod spec: containers: - name: tomcat image: tomcat:8.5-jre10-slim ports: - containerPort: 8080 --- apiVersion: v1 kind: Service metadata: name: nginx-service namespace: dev spec: selector: app: nginx-pod clusterIP: None type: ClusterIP ports: - port: 80 targetPort: 80 --- apiVersion: v1 kind: Service metadata: name: tomcat-service namespace: dev spec: selector: app: tomcat-pod clusterIP: None type: ClusterIP ports: - port: 8080 targetPort: 8080 # 创建 [root@k8s-master01 ~]# kubectl create -f tomcat-nginx.yaml # 查看 [root@k8s-master01 ~]# kubectl get svc -n dev NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE nginx-service ClusterIP None \u0026lt;none\u0026gt; 80/TCP 48s tomcat-service ClusterIP None \u0026lt;none\u0026gt; 8080/TCP 48s 7.5.3 Http 代理 创建 ingress-http.yaml\napiVersion: extensions/v1beta1 kind: Ingress metadata: name: ingress-http namespace: dev spec: rules: - host: nginx.itheima.com http: paths: - path: / backend: serviceName: nginx-service servicePort: 80 - host: tomcat.itheima.com http: paths: - path: / backend: serviceName: tomcat-service servicePort: 8080 # 创建 [root@k8s-master01 ~]# kubectl create -f ingress-http.yaml ingress.extensions/ingress-http created # 查看 [root@k8s-master01 ~]# kubectl get ing ingress-http -n dev NAME HOSTS ADDRESS PORTS AGE ingress-http nginx.itheima.com,tomcat.itheima.com 80 22s # 查看详情 [root@k8s-master01 ~]# kubectl describe ing ingress-http -n dev ... Rules: Host Path Backends ---- ---- -------- nginx.itheima.com / nginx-service:80 (10.244.1.96:80,10.244.1.97:80,10.244.2.112:80) tomcat.itheima.com / tomcat-service:8080(10.244.1.94:8080,10.244.1.95:8080,10.244.2.111:8080) ... # 接下来,在本地电脑上配置host文件,解析上面的两个域名到192.168.109.100(master)上 # 然后,就可以分别访问tomcat.itheima.com:32240 和 nginx.itheima.com:32240 查看效果了 7.5.4 Https 代理 创建证书\n# 生成证书 openssl req -x509 -sha256 -nodes -days 365 -newkey rsa:2048 -keyout tls.key -out tls.crt -subj \u0026#34;/C=CN/ST=BJ/L=BJ/O=nginx/CN=itheima.com\u0026#34; # 创建密钥 kubectl create secret tls tls-secret --key tls.key --cert tls.crt 创建 ingress-https.yaml\napiVersion: extensions/v1beta1 kind: Ingress metadata: name: ingress-https namespace: dev spec: tls: - hosts: - nginx.itheima.com - tomcat.itheima.com secretName: tls-secret # 指定秘钥 rules: - host: nginx.itheima.com http: paths: - path: / backend: serviceName: nginx-service servicePort: 80 - host: tomcat.itheima.com http: paths: - path: / backend: serviceName: tomcat-service servicePort: 8080 # 创建 [root@k8s-master01 ~]# kubectl create -f ingress-https.yaml ingress.extensions/ingress-https created # 查看 [root@k8s-master01 ~]# kubectl get ing ingress-https -n dev NAME HOSTS ADDRESS PORTS AGE ingress-https nginx.itheima.com,tomcat.itheima.com 10.104.184.38 80, 443 2m42s # 查看详情 [root@k8s-master01 ~]# kubectl describe ing ingress-https -n dev ... TLS: tls-secret terminates nginx.itheima.com,tomcat.itheima.com Rules: Host Path Backends ---- ---- -------- nginx.itheima.com / nginx-service:80 (10.244.1.97:80,10.244.1.98:80,10.244.2.119:80) tomcat.itheima.com / tomcat-service:8080(10.244.1.99:8080,10.244.2.117:8080,10.244.2.120:8080) ... # 下面可以通过浏览器访问https:/nginx.itheima.com:31335 和 https:/tomcat.itheima.com:31335来查看了 8. 数据存储 在前面已经提到，容器的生命周期可能很短，会被频繁地创建和销毁。那么容器在销毁时，保存在容器中的数据也会被清除。这种结果对用户来说，在某些情况下是不乐意看到的。为了持久化保存容器的数据，kubernetes 引入了 Volume 的概念。\nVolume 是 Pod 中能够被多个容器访问的共享目录，它被定义在 Pod 上，然后被一个 Pod 里的多个容器挂载到具体的文件目录下，kubernetes 通过 Volume 实现同一个 Pod 中不同容器之间的数据共享以及数据的持久化存储。Volume 的生命容器不与 Pod 中单个容器的生命周期相关，当容器终止或者重启时，Volume 中的数据也不会丢失。\nkubernetes 的 Volume 支持多种类型，比较常见的有下面几个：\n简单存储：EmptyDir、HostPath、NFS 高级存储：PV、PVC 配置存储：ConfigMap、Secret 8.1 基本存储 8.1.1 EmptyDir EmptyDir 是最基础的 Volume 类型，一个 EmptyDir 就是 Host 上的一个空目录。\nEmptyDir 是在 Pod 被分配到 Node 时创建的，它的初始内容为空，并且无须指定宿主机上对应的目录文件，因为 kubernetes 会自动分配一个目录，当 Pod 销毁时， EmptyDir 中的数据也会被永久删除。 EmptyDir 用途如下：\n临时空间，例如用于某些应用程序运行时所需的临时目录，且无须永久保留 一个容器需要从另一个容器中获取数据的目录（多容器共享目录） 接下来，通过一个容器之间文件共享的案例来使用一下 EmptyDir。\n在一个 Pod 中准备两个容器 nginx 和 busybox，然后声明一个 Volume 分别挂在到两个容器的目录中，然后 nginx 容器负责向 Volume 中写日志，busybox 中通过命令将日志内容读到控制台。\n创建一个 volume-emptydir.yaml\napiVersion: v1 kind: Pod metadata: name: volume-emptydir namespace: dev spec: containers: - name: nginx image: nginx:1.17.1 ports: - containerPort: 80 volumeMounts: # 将logs-volume挂在到nginx容器中，对应的目录为 /var/log/nginx - name: logs-volume mountPath: /var/log/nginx - name: busybox image: busybox:1.30 command: [\u0026#34;/bin/sh\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;tail -f /logs/access.log\u0026#34;] # 初始命令，动态读取指定文件中内容 volumeMounts: # 将logs-volume 挂在到busybox容器中，对应的目录为 /logs - name: logs-volume mountPath: /logs volumes: # 声明volume， name为logs-volume，类型为emptyDir - name: logs-volume emptyDir: {} # 创建Pod [root@k8s-master01 ~]# kubectl create -f volume-emptydir.yaml pod/volume-emptydir created # 查看pod [root@k8s-master01 ~]# kubectl get pods volume-emptydir -n dev -o wide NAME READY STATUS RESTARTS AGE IP NODE ...... volume-emptydir 2/2 Running 0 97s 10.42.2.9 node1 ...... # 通过podIp访问nginx [root@k8s-master01 ~]# curl 10.42.2.9 ...... # 通过kubectl logs命令查看指定容器的标准输出 [root@k8s-master01 ~]# kubectl logs -f volume-emptydir -n dev -c busybox 10.42.1.0 - - [27/Jun/2021:15:08:54 +0000] \u0026#34;GET / HTTP/1.1\u0026#34; 200 612 \u0026#34;-\u0026#34; \u0026#34;curl/7.29.0\u0026#34; \u0026#34;-\u0026#34; 8.1.2 HostPath 上节课提到，EmptyDir 中数据不会被持久化，它会随着 Pod 的结束而销毁，如果想简单的将数据持久化到主机中，可以选择 HostPath。\nHostPath 就是将 Node 主机中一个实际目录挂在到 Pod 中，以供容器使用，这样的设计就可以保证 Pod 销毁了，但是数据依据可以存在于 Node 主机上。\n创建一个 volume-hostpath.yaml：\napiVersion: v1 kind: Pod metadata: name: volume-hostpath namespace: dev spec: containers: - name: nginx image: nginx:1.17.1 ports: - containerPort: 80 volumeMounts: - name: logs-volume mountPath: /var/log/nginx - name: busybox image: busybox:1.30 command: [\u0026#34;/bin/sh\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;tail -f /logs/access.log\u0026#34;] volumeMounts: - name: logs-volume mountPath: /logs volumes: - name: logs-volume hostPath: path: /root/logs type: DirectoryOrCreate # 目录存在就使用，不存在就先创建后使用 关于type的值的一点说明： DirectoryOrCreate 目录存在就使用，不存在就先创建后使用 Directory 目录必须存在 FileOrCreate 文件存在就使用，不存在就先创建后使用 File 文件必须存在 Socket unix套接字必须存在 CharDevice 字符设备必须存在 BlockDevice 块设备必须存在 # 创建Pod [root@k8s-master01 ~]# kubectl create -f volume-hostpath.yaml pod/volume-hostpath created # 查看Pod [root@k8s-master01 ~]# kubectl get pods volume-hostpath -n dev -o wide NAME READY STATUS RESTARTS AGE IP NODE ...... pod-volume-hostpath 2/2 Running 0 16s 10.42.2.10 node1 ...... #访问nginx [root@k8s-master01 ~]# curl 10.42.2.10 [root@k8s-master01 ~]# kubectl logs -f volume-emptydir -n dev -c busybox # 接下来就可以去host的/root/logs目录下查看存储的文件了 ### 注意: 下面的操作需要到Pod所在的节点运行（案例中是node1） [root@node1 ~]# ls /root/logs/ access.log error.log # 同样的道理，如果在此目录下创建一个文件，到容器中也是可以看到的 8.1.3 NFS HostPath 可以解决数据持久化的问题，但是一旦 Node 节点故障了，Pod 如果转移到了别的节点，又会出现问题了，此时需要准备单独的网络存储系统，比较常用的用 NFS、CIFS。\nNFS 是一个网络文件存储系统，可以搭建一台 NFS 服务器，然后将 Pod 中的存储直接连接到 NFS 系统上，这样的话，无论 Pod 在节点上怎么转移，只要 Node 跟 NFS 的对接没问题，数据就可以成功访问。\n1）首先要准备 nfs 的服务器，这里为了简单，直接是 master 节点做 nfs 服务器\n# 在nfs上安装nfs服务 [root@nfs ~]# yum install nfs-utils -y # 准备一个共享目录 [root@nfs ~]# mkdir /root/data/nfs -pv # 将共享目录以读写权限暴露给192.168.5.0/24网段中的所有主机 [root@nfs ~]# vim /etc/exports [root@nfs ~]# more /etc/exports /root/data/nfs 192.168.5.0/24(rw,no_root_squash) # 启动nfs服务 [root@nfs ~]# systemctl restart nfs 2）接下来，要在的每个 node 节点上都安装下 nfs，这样的目的是为了 node 节点可以驱动 nfs 设备\n# 在node上安装nfs服务，注意不需要启动 [root@k8s-master01 ~]# yum install nfs-utils -y 3）接下来，就可以编写 pod 的配置文件了，创建 volume-nfs.yaml\napiVersion: v1 kind: Pod metadata: name: volume-nfs namespace: dev spec: containers: - name: nginx image: nginx:1.17.1 ports: - containerPort: 80 volumeMounts: - name: logs-volume mountPath: /var/log/nginx - name: busybox image: busybox:1.30 command: [\u0026#34;/bin/sh\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;tail -f /logs/access.log\u0026#34;] volumeMounts: - name: logs-volume mountPath: /logs volumes: - name: logs-volume nfs: server: 192.168.5.6 #nfs服务器地址 path: /root/data/nfs #共享文件路径 4）最后，运行下 pod，观察结果\n# 创建pod [root@k8s-master01 ~]# kubectl create -f volume-nfs.yaml pod/volume-nfs created # 查看pod [root@k8s-master01 ~]# kubectl get pods volume-nfs -n dev NAME READY STATUS RESTARTS AGE volume-nfs 2/2 Running 0 2m9s # 查看nfs服务器上的共享目录，发现已经有文件了 [root@k8s-master01 ~]# ls /root/data/ access.log error.log 8.2 高级存储 前面已经学习了使用 NFS 提供存储，此时就要求用户会搭建 NFS 系统，并且会在 yaml 配置 nfs。由于 kubernetes 支持的存储系统有很多，要求客户全都掌握，显然不现实。为了能够屏蔽底层存储实现的细节，方便用户使用， kubernetes 引入 PV 和 PVC 两种资源对象。\nPV（Persistent Volume）是持久化卷的意思，是对底层的共享存储的一种抽象。一般情况下 PV 由 kubernetes 管理员进行创建和配置，它与底层具体的共享存储技术有关，并通过插件完成与共享存储的对接。\nPVC（Persistent Volume Claim）是持久卷声明的意思，是用户对于存储需求的一种声明。换句话说，PVC 其实就是用户向 kubernetes 系统发出的一种资源需求申请。\n使用了 PV 和 PVC 之后，工作可以得到进一步的细分：\n存储：存储工程师维护 PV： kubernetes 管理员维护 PVC：kubernetes 用户维护 8.2.1 PV PV 是存储资源的抽象，下面是资源清单文件:\napiVersion: v1 kind: PersistentVolume metadata: name: pv2 spec: nfs: # 存储类型，与底层真正存储对应 capacity: # 存储能力，目前只支持存储空间的设置 storage: 2Gi accessModes: # 访问模式 storageClassName: # 存储类别 persistentVolumeReclaimPolicy: # 回收策略 PV 的关键配置参数说明：\n存储类型\n底层实际存储的类型，kubernetes 支持多种存储类型，每种存储类型的配置都有所差异\n存储能力（capacity）\n目前只支持存储空间的设置( storage=1Gi )，不过未来可能会加入 IOPS、吞吐量等指标的配置\n访问模式（accessModes）\n用于描述用户应用对存储资源的访问权限，访问权限包括下面几种方式：\nReadWriteOnce（RWO）：读写权限，但是只能被单个节点挂载 ReadOnlyMany（ROX）： 只读权限，可以被多个节点挂载 ReadWriteMany（RWX）：读写权限，可以被多个节点挂载 需要注意的是，底层不同的存储类型可能支持的访问模式不同\n回收策略（persistentVolumeReclaimPolicy）\n当 PV 不再被使用了之后，对其的处理方式。目前支持三种策略：\nRetain （保留） 保留数据，需要管理员手工清理数据 Recycle（回收） 清除 PV 中的数据，效果相当于执行 rm -rf /thevolume/* Delete （删除） 与 PV 相连的后端存储完成 volume 的删除操作，当然这常见于云服务商的存储服务 需要注意的是，底层不同的存储类型可能支持的回收策略不同\n存储类别\nPV 可以通过 storageClassName 参数指定一个存储类别\n具有特定类别的 PV 只能与请求了该类别的 PVC 进行绑定 未设定类别的 PV 则只能与不请求任何类别的 PVC 进行绑定 状态（status）\n一个 PV 的生命周期中，可能会处于 4 中不同的阶段：\nAvailable（可用）： 表示可用状态，还未被任何 PVC 绑定 Bound（已绑定）： 表示 PV 已经被 PVC 绑定 Released（已释放）： 表示 PVC 被删除，但是资源还未被集群重新声明 Failed（失败）： 表示该 PV 的自动回收失败 实验\n使用 NFS 作为存储，来演示 PV 的使用，创建 3 个 PV，对应 NFS 中的 3 个暴露的路径。\n准备 NFS 环境 # 创建目录 [root@nfs ~]# mkdir /root/data/{pv1,pv2,pv3} -pv # 暴露服务 [root@nfs ~]# more /etc/exports /root/data/pv1 192.168.5.0/24(rw,no_root_squash) /root/data/pv2 192.168.5.0/24(rw,no_root_squash) /root/data/pv3 192.168.5.0/24(rw,no_root_squash) # 重启服务 [root@nfs ~]# systemctl restart nfs 创建 pv.yaml\napiVersion: v1 kind: PersistentVolume metadata: name: pv1 spec: capacity: storage: 1Gi accessModes: - ReadWriteMany persistentVolumeReclaimPolicy: Retain nfs: path: /root/data/pv1 server: 192.168.5.6 --- apiVersion: v1 kind: PersistentVolume metadata: name: pv2 spec: capacity: storage: 2Gi accessModes: - ReadWriteMany persistentVolumeReclaimPolicy: Retain nfs: path: /root/data/pv2 server: 192.168.5.6 --- apiVersion: v1 kind: PersistentVolume metadata: name: pv3 spec: capacity: storage: 3Gi accessModes: - ReadWriteMany persistentVolumeReclaimPolicy: Retain nfs: path: /root/data/pv3 server: 192.168.5.6 # 创建 pv [root@k8s-master01 ~]# kubectl create -f pv.yaml persistentvolume/pv1 created persistentvolume/pv2 created persistentvolume/pv3 created # 查看pv [root@k8s-master01 ~]# kubectl get pv -o wide NAME CAPACITY ACCESS MODES RECLAIM POLICY STATUS AGE VOLUMEMODE pv1 1Gi RWX Retain Available 10s Filesystem pv2 2Gi RWX Retain Available 10s Filesystem pv3 3Gi RWX Retain Available 9s Filesystem 8.2.2 PVC PVC 是资源的申请，用来声明对存储空间、访问模式、存储类别需求信息。下面是资源清单文件:\napiVersion: v1 kind: PersistentVolumeClaim metadata: name: pvc namespace: dev spec: accessModes: # 访问模式 selector: # 采用标签对PV选择 storageClassName: # 存储类别 resources: # 请求空间 requests: storage: 5Gi PVC 的关键配置参数说明：\n访问模式（accessModes） 用于描述用户应用对存储资源的访问权限\n选择条件（selector）\n通过 Label Selector 的设置，可使 PVC 对于系统中己存在的 PV 进行筛选\n存储类别（storageClassName）\nPVC 在定义时可以设定需要的后端存储的类别，只有设置了该 class 的 pv 才能被系统选出\n资源请求（Resources ）\n描述对存储资源的请求\n实验\n创建 pvc.yaml，申请 pv apiVersion: v1 kind: PersistentVolumeClaim metadata: name: pvc1 namespace: dev spec: accessModes: - ReadWriteMany resources: requests: storage: 1Gi --- apiVersion: v1 kind: PersistentVolumeClaim metadata: name: pvc2 namespace: dev spec: accessModes: - ReadWriteMany resources: requests: storage: 1Gi --- apiVersion: v1 kind: PersistentVolumeClaim metadata: name: pvc3 namespace: dev spec: accessModes: - ReadWriteMany resources: requests: storage: 1Gi # 创建pvc [root@k8s-master01 ~]# kubectl create -f pvc.yaml persistentvolumeclaim/pvc1 created persistentvolumeclaim/pvc2 created persistentvolumeclaim/pvc3 created # 查看pvc [root@k8s-master01 ~]# kubectl get pvc -n dev -o wide NAME STATUS VOLUME CAPACITY ACCESS MODES STORAGECLASS AGE VOLUMEMODE pvc1 Bound pv1 1Gi RWX 15s Filesystem pvc2 Bound pv2 2Gi RWX 15s Filesystem pvc3 Bound pv3 3Gi RWX 15s Filesystem # 查看pv [root@k8s-master01 ~]# kubectl get pv -o wide NAME CAPACITY ACCESS MODES RECLAIM POLICY STATUS CLAIM AGE VOLUMEMODE pv1 1Gi RWx Retain Bound dev/pvc1 3h37m Filesystem pv2 2Gi RWX Retain Bound dev/pvc2 3h37m Filesystem pv3 3Gi RWX Retain Bound dev/pvc3 3h37m Filesystem 创建 pods.yaml, 使用 pv\napiVersion: v1 kind: Pod metadata: name: pod1 namespace: dev spec: containers: - name: busybox image: busybox:1.30 command: [ \u0026#34;/bin/sh\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;while true;do echo pod1 \u0026gt;\u0026gt; /root/out.txt; sleep 10; done;\u0026#34;, ] volumeMounts: - name: volume mountPath: /root/ volumes: - name: volume persistentVolumeClaim: claimName: pvc1 readOnly: false --- apiVersion: v1 kind: Pod metadata: name: pod2 namespace: dev spec: containers: - name: busybox image: busybox:1.30 command: [ \u0026#34;/bin/sh\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;while true;do echo pod2 \u0026gt;\u0026gt; /root/out.txt; sleep 10; done;\u0026#34;, ] volumeMounts: - name: volume mountPath: /root/ volumes: - name: volume persistentVolumeClaim: claimName: pvc2 readOnly: false # 创建pod [root@k8s-master01 ~]# kubectl create -f pods.yaml pod/pod1 created pod/pod2 created # 查看pod [root@k8s-master01 ~]# kubectl get pods -n dev -o wide NAME READY STATUS RESTARTS AGE IP NODE pod1 1/1 Running 0 14s 10.244.1.69 node1 pod2 1/1 Running 0 14s 10.244.1.70 node1 # 查看pvc [root@k8s-master01 ~]# kubectl get pvc -n dev -o wide NAME STATUS VOLUME CAPACITY ACCESS MODES AGE VOLUMEMODE pvc1 Bound pv1 1Gi RWX 94m Filesystem pvc2 Bound pv2 2Gi RWX 94m Filesystem pvc3 Bound pv3 3Gi RWX 94m Filesystem # 查看pv [root@k8s-master01 ~]# kubectl get pv -n dev -o wide NAME CAPACITY ACCESS MODES RECLAIM POLICY STATUS CLAIM AGE VOLUMEMODE pv1 1Gi RWX Retain Bound dev/pvc1 5h11m Filesystem pv2 2Gi RWX Retain Bound dev/pvc2 5h11m Filesystem pv3 3Gi RWX Retain Bound dev/pvc3 5h11m Filesystem # 查看nfs中的文件存储 [root@nfs ~]# more /root/data/pv1/out.txt node1 node1 [root@nfs ~]# more /root/data/pv2/out.txt node2 node2 8.2.3 生命周期 PVC 和 PV 是一一对应的，PV 和 PVC 之间的相互作用遵循以下生命周期：\n资源供应：管理员手动创建底层存储和 PV\n资源绑定：用户创建 PVC，kubernetes 负责根据 PVC 的声明去寻找 PV，并绑定\n在用户定义好 PVC 之后，系统将根据 PVC 对存储资源的请求在已存在的 PV 中选择一个满足条件的\n一旦找到，就将该 PV 与用户定义的 PVC 进行绑定，用户的应用就可以使用这个 PVC 了 如果找不到，PVC 则会无限期处于 Pending 状态，直到等到系统管理员创建了一个符合其要求的 PV PV 一旦绑定到某个 PVC 上，就会被这个 PVC 独占，不能再与其他 PVC 进行绑定了\n资源使用：用户可在 pod 中像 volume 一样使用 pvc\nPod 使用 Volume 的定义，将 PVC 挂载到容器内的某个路径进行使用。\n资源释放：用户删除 pvc 来释放 pv\n当存储资源使用完毕后，用户可以删除 PVC，与该 PVC 绑定的 PV 将会被标记为“已释放”，但还不能立刻与其他 PVC 进行绑定。通过之前 PVC 写入的数据可能还被留在存储设备上，只有在清除之后该 PV 才能再次使用。\n资源回收：kubernetes 根据 pv 设置的回收策略进行资源的回收\n对于 PV，管理员可以设定回收策略，用于设置与之绑定的 PVC 释放资源之后如何处理遗留数据的问题。只有 PV 的存储空间完成回收，才能供新的 PVC 绑定和使用\n8.3 配置存储 8.3.1 ConfigMap ConfigMap 是一种比较特殊的存储卷，它的主要作用是用来存储配置信息的。\n创建 configmap.yaml，内容如下：\napiVersion: v1 kind: ConfigMap metadata: name: configmap namespace: dev data: info: | username:admin password:123456 接下来，使用此配置文件创建 configmap\n# 创建configmap [root@k8s-master01 ~]# kubectl create -f configmap.yaml configmap/configmap created # 查看configmap详情 [root@k8s-master01 ~]# kubectl describe cm configmap -n dev Name: configmap Namespace: dev Labels: \u0026lt;none\u0026gt; Annotations: \u0026lt;none\u0026gt; Data ==== info: ---- username:admin password:123456 Events: \u0026lt;none\u0026gt; 接下来创建一个 pod-configmap.yaml，将上面创建的 configmap 挂载进去\napiVersion: v1 kind: Pod metadata: name: pod-configmap namespace: dev spec: containers: - name: nginx image: nginx:1.17.1 volumeMounts: # 将configmap挂载到目录 - name: config mountPath: /configmap/config volumes: # 引用configmap - name: config configMap: name: configmap # 创建pod [root@k8s-master01 ~]# kubectl create -f pod-configmap.yaml pod/pod-configmap created # 查看pod [root@k8s-master01 ~]# kubectl get pod pod-configmap -n dev NAME READY STATUS RESTARTS AGE pod-configmap 1/1 Running 0 6s #进入容器 [root@k8s-master01 ~]# kubectl exec -it pod-configmap -n dev /bin/sh # cd /configmap/config/ # ls info # more info username:admin password:123456 # 可以看到映射已经成功，每个configmap都映射成了一个目录 # key---\u0026gt;文件 value----\u0026gt;文件中的内容 # 此时如果更新configmap的内容, 容器中的值也会动态更新 8.3.2 Secret 在 kubernetes 中，还存在一种和 ConfigMap 非常类似的对象，称为 Secret 对象。它主要用于存储敏感信息，例如密码、秘钥、证书等等。\n首先使用 base64 对数据进行编码 [root@k8s-master01 ~]# echo -n \u0026#39;admin\u0026#39; | base64 #准备username YWRtaW4= [root@k8s-master01 ~]# echo -n \u0026#39;123456\u0026#39; | base64 #准备password MTIzNDU2 接下来编写 secret.yaml，并创建 Secret\napiVersion: v1 kind: Secret metadata: name: secret namespace: dev type: Opaque data: username: YWRtaW4= password: MTIzNDU2 # 创建secret [root@k8s-master01 ~]# kubectl create -f secret.yaml secret/secret created # 查看secret详情 [root@k8s-master01 ~]# kubectl describe secret secret -n dev Name: secret Namespace: dev Labels: \u0026lt;none\u0026gt; Annotations: \u0026lt;none\u0026gt; Type: Opaque Data ==== password: 6 bytes username: 5 bytes 创建 pod-secret.yaml，将上面创建的 secret 挂载进去：\napiVersion: v1 kind: Pod metadata: name: pod-secret namespace: dev spec: containers: - name: nginx image: nginx:1.17.1 volumeMounts: # 将secret挂载到目录 - name: config mountPath: /secret/config volumes: - name: config secret: secretName: secret # 创建pod [root@k8s-master01 ~]# kubectl create -f pod-secret.yaml pod/pod-secret created # 查看pod [root@k8s-master01 ~]# kubectl get pod pod-secret -n dev NAME READY STATUS RESTARTS AGE pod-secret 1/1 Running 0 2m28s # 进入容器，查看secret信息，发现已经自动解码了 [root@k8s-master01 ~]# kubectl exec -it pod-secret /bin/sh -n dev / # ls /secret/config/ password username / # more /secret/config/username admin / # more /secret/config/password 123456 至此，已经实现了利用 secret 实现了信息的编码。\n9. 安全认证 9.1 访问控制概述 Kubernetes 作为一个分布式集群的管理工具，保证集群的安全性是其一个重要的任务。所谓的安全性其实就是保证对 Kubernetes 的各种客户端进行认证和鉴权操作。\n客户端\n在 Kubernetes 集群中，客户端通常有两类：\nUser Account：一般是独立于 kubernetes 之外的其他服务管理的用户账号。 Service Account：kubernetes 管理的账号，用于为 Pod 中的服务进程在访问 Kubernetes 时提供身份标识。 认证、授权与准入控制\nApiServer 是访问及管理资源对象的唯一入口。任何一个请求访问 ApiServer，都要经过下面三个流程：\nAuthentication（认证）：身份鉴别，只有正确的账号才能够通过认证 Authorization（授权）： 判断用户是否有权限对访问的资源执行特定的动作 Admission Control（准入控制）：用于补充授权机制以实现更加精细的访问控制功能。 9.2 认证管理 Kubernetes 集群安全的最关键点在于如何识别并认证客户端身份，它提供了 3 种客户端身份认证方式：\nHTTP Base 认证：通过用户名+密码的方式认证\n这种认证方式是把“用户名:密码”用BASE64算法进行编码后的字符串放在HTTP请求中的Header Authorization域里发送给服务端。服务端收到后进行解码，获取用户名及密码，然后进行用户身份认证的过程。 HTTP Token 认证：通过一个 Token 来识别合法用户\n这种认证方式是用一个很长的难以被模仿的字符串--Token来表明客户身份的一种方式。每个Token对应一个用户名，当客户端发起API调用请求时，需要在HTTP Header里放入Token，API Server接到Token后会跟服务器中保存的token进行比对，然后进行用户身份认证的过程。 HTTPS 证书认证：基于 CA 根证书签名的双向数字证书认证方式\n这种认证方式是安全性最高的一种方式，但是同时也是操作起来最麻烦的一种方式。 HTTPS 认证大体分为 3 个过程：\n证书申请和下发\nHTTPS通信双方的服务器向CA机构申请证书，CA机构下发根证书、服务端证书及私钥给申请者 客户端和服务端的双向认证\n1\u0026gt; 客户端向服务器端发起请求，服务端下发自己的证书给客户端， 客户端接收到证书后，通过私钥解密证书，在证书中获得服务端的公钥， 客户端利用服务器端的公钥认证证书中的信息，如果一致，则认可这个服务器 2\u0026gt; 客户端发送自己的证书给服务器端，服务端接收到证书后，通过私钥解密证书， 在证书中获得客户端的公钥，并用该公钥认证证书信息，确认客户端是否合法 服务器端和客户端进行通信\n服务器端和客户端协商好加密方案后，客户端会产生一个随机的秘钥并加密，然后发送到服务器端。 服务器端接收这个秘钥后，双方接下来通信的所有内容都通过该随机秘钥加密 注意: Kubernetes 允许同时配置多种认证方式，只要其中任意一个方式认证通过即可\n9.3 授权管理 授权发生在认证成功之后，通过认证就可以知道请求用户是谁， 然后 Kubernetes 会根据事先定义的授权策略来决定用户是否有权限访问，这个过程就称为授权。\n每个发送到 ApiServer 的请求都带上了用户和资源的信息：比如发送请求的用户、请求的路径、请求的动作等，授权就是根据这些信息和授权策略进行比较，如果符合策略，则认为授权通过，否则会返回错误。\nAPI Server 目前支持以下几种授权策略：\nAlwaysDeny：表示拒绝所有请求，一般用于测试 AlwaysAllow：允许接收所有请求，相当于集群不需要授权流程（Kubernetes 默认的策略） ABAC：基于属性的访问控制，表示使用用户配置的授权规则对用户请求进行匹配和控制 Webhook：通过调用外部 REST 服务对用户进行授权 Node：是一种专用模式，用于对 kubelet 发出的请求进行访问控制 RBAC：基于角色的访问控制（kubeadm 安装方式下的默认选项） RBAC(Role-Based Access Control) 基于角色的访问控制，主要是在描述一件事情：给哪些对象授予了哪些权限\n其中涉及到了下面几个概念：\n对象：User、Groups、ServiceAccount 角色：代表着一组定义在资源上的可操作动作(权限)的集合 绑定：将定义好的角色跟用户绑定在一起 RBAC 引入了 4 个顶级资源对象：\nRole、ClusterRole：角色，用于指定一组权限 RoleBinding、ClusterRoleBinding：角色绑定，用于将角色（权限）赋予给对象 Role、ClusterRole\n一个角色就是一组权限的集合，这里的权限都是许可形式的（白名单）。\n# Role只能对命名空间内的资源进行授权，需要指定nameapce kind: Role apiVersion: rbac.authorization.k8s.io/v1beta1 metadata: namespace: dev name: authorization-role rules: - apiGroups: [\u0026#34;\u0026#34;] # 支持的API组列表,\u0026#34;\u0026#34; 空字符串，表示核心API群 resources: [\u0026#34;pods\u0026#34;] # 支持的资源对象列表 verbs: [\u0026#34;get\u0026#34;, \u0026#34;watch\u0026#34;, \u0026#34;list\u0026#34;] # 允许的对资源对象的操作方法列表 # ClusterRole可以对集群范围内资源、跨namespaces的范围资源、非资源类型进行授权 kind: ClusterRole apiVersion: rbac.authorization.k8s.io/v1beta1 metadata: name: authorization-clusterrole rules: - apiGroups: [\u0026#34;\u0026#34;] resources: [\u0026#34;pods\u0026#34;] verbs: [\u0026#34;get\u0026#34;, \u0026#34;watch\u0026#34;, \u0026#34;list\u0026#34;] 需要详细说明的是，rules 中的参数：\napiGroups: 支持的 API 组列表\n\u0026#34;\u0026#34;,\u0026#34;apps\u0026#34;, \u0026#34;autoscaling\u0026#34;, \u0026#34;batch\u0026#34; resources：支持的资源对象列表\n\u0026#34;services\u0026#34;, \u0026#34;endpoints\u0026#34;, \u0026#34;pods\u0026#34;,\u0026#34;secrets\u0026#34;,\u0026#34;configmaps\u0026#34;,\u0026#34;crontabs\u0026#34;,\u0026#34;deployments\u0026#34;,\u0026#34;jobs\u0026#34;, \u0026#34;nodes\u0026#34;,\u0026#34;rolebindings\u0026#34;,\u0026#34;clusterroles\u0026#34;,\u0026#34;daemonsets\u0026#34;,\u0026#34;replicasets\u0026#34;,\u0026#34;statefulsets\u0026#34;, \u0026#34;horizontalpodautoscalers\u0026#34;,\u0026#34;replicationcontrollers\u0026#34;,\u0026#34;cronjobs\u0026#34; verbs：对资源对象的操作方法列表\n\u0026#34;get\u0026#34;, \u0026#34;list\u0026#34;, \u0026#34;watch\u0026#34;, \u0026#34;create\u0026#34;, \u0026#34;update\u0026#34;, \u0026#34;patch\u0026#34;, \u0026#34;delete\u0026#34;, \u0026#34;exec\u0026#34; RoleBinding、ClusterRoleBinding\n角色绑定用来把一个角色绑定到一个目标对象上，绑定目标可以是 User、Group 或者 ServiceAccount。\n# RoleBinding可以将同一namespace中的subject绑定到某个Role下，则此subject即具有该Role定义的权限 kind: RoleBinding apiVersion: rbac.authorization.k8s.io/v1beta1 metadata: name: authorization-role-binding namespace: dev subjects: - kind: User name: heima apiGroup: rbac.authorization.k8s.io roleRef: kind: Role name: authorization-role apiGroup: rbac.authorization.k8s.io # ClusterRoleBinding在整个集群级别和所有namespaces将特定的subject与ClusterRole绑定，授予权限 kind: ClusterRoleBinding apiVersion: rbac.authorization.k8s.io/v1beta1 metadata: name: authorization-clusterrole-binding subjects: - kind: User name: heima apiGroup: rbac.authorization.k8s.io roleRef: kind: ClusterRole name: authorization-clusterrole apiGroup: rbac.authorization.k8s.io RoleBinding 引用 ClusterRole 进行授权\nRoleBinding 可以引用 ClusterRole，对属于同一命名空间内 ClusterRole 定义的资源主体进行授权。\n一种很常用的做法就是，集群管理员为集群范围预定义好一组角色（ClusterRole），然后在多个命名空间中重复使用这些ClusterRole。这样可以大幅提高授权管理工作效率，也使得各个命名空间下的基础性授权规则与使用体验保持一致。 # 虽然authorization-clusterrole是一个集群角色，但是因为使用了RoleBinding # 所以heima只能读取dev命名空间中的资源 kind: RoleBinding apiVersion: rbac.authorization.k8s.io/v1beta1 metadata: name: authorization-role-binding-ns namespace: dev subjects: - kind: User name: heima apiGroup: rbac.authorization.k8s.io roleRef: kind: ClusterRole name: authorization-clusterrole apiGroup: rbac.authorization.k8s.io 实战：创建一个只能管理 dev 空间下 Pods 资源的账号\n创建账号 # 1) 创建证书 [root@k8s-master01 pki]# cd /etc/kubernetes/pki/ [root@k8s-master01 pki]# (umask 077;openssl genrsa -out devman.key 2048) # 2) 用apiserver的证书去签署 # 2-1) 签名申请，申请的用户是devman,组是devgroup [root@k8s-master01 pki]# openssl req -new -key devman.key -out devman.csr -subj \u0026#34;/CN=devman/O=devgroup\u0026#34; # 2-2) 签署证书 [root@k8s-master01 pki]# openssl x509 -req -in devman.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out devman.crt -days 3650 # 3) 设置集群、用户、上下文信息 [root@k8s-master01 pki]# kubectl config set-cluster kubernetes --embed-certs=true --certificate-authority=/etc/kubernetes/pki/ca.crt --server=https:/192.168.109.100:6443 [root@k8s-master01 pki]# kubectl config set-credentials devman --embed-certs=true --client-certificate=/etc/kubernetes/pki/devman.crt --client-key=/etc/kubernetes/pki/devman.key [root@k8s-master01 pki]# kubectl config set-context devman@kubernetes --cluster=kubernetes --user=devman # 切换账户到devman [root@k8s-master01 pki]# kubectl config use-context devman@kubernetes Switched to context \u0026#34;devman@kubernetes\u0026#34;. # 查看dev下pod，发现没有权限 [root@k8s-master01 pki]# kubectl get pods -n dev Error from server (Forbidden): pods is forbidden: User \u0026#34;devman\u0026#34; cannot list resource \u0026#34;pods\u0026#34; in API group \u0026#34;\u0026#34; in the namespace \u0026#34;dev\u0026#34; # 切换到admin账户 [root@k8s-master01 pki]# kubectl config use-context kubernetes-admin@kubernetes Switched to context \u0026#34;kubernetes-admin@kubernetes\u0026#34;. 2） 创建 Role 和 RoleBinding，为 devman 用户授权\nkind: Role apiVersion: rbac.authorization.k8s.io/v1beta1 metadata: namespace: dev name: dev-role rules: - apiGroups: [\u0026#34;\u0026#34;] resources: [\u0026#34;pods\u0026#34;] verbs: [\u0026#34;get\u0026#34;, \u0026#34;watch\u0026#34;, \u0026#34;list\u0026#34;] --- kind: RoleBinding apiVersion: rbac.authorization.k8s.io/v1beta1 metadata: name: authorization-role-binding namespace: dev subjects: - kind: User name: devman apiGroup: rbac.authorization.k8s.io roleRef: kind: Role name: dev-role apiGroup: rbac.authorization.k8s.io [root@k8s-master01 pki]# kubectl create -f dev-role.yaml role.rbac.authorization.k8s.io/dev-role created rolebinding.rbac.authorization.k8s.io/authorization-role-binding created 切换账户，再次验证\n# 切换账户到devman [root@k8s-master01 pki]# kubectl config use-context devman@kubernetes Switched to context \u0026#34;devman@kubernetes\u0026#34;. # 再次查看 [root@k8s-master01 pki]# kubectl get pods -n dev NAME READY STATUS RESTARTS AGE nginx-deployment-66cb59b984-8wp2k 1/1 Running 0 4d1h nginx-deployment-66cb59b984-dc46j 1/1 Running 0 4d1h nginx-deployment-66cb59b984-thfck 1/1 Running 0 4d1h # 为了不影响后面的学习,切回admin账户 [root@k8s-master01 pki]# kubectl config use-context kubernetes-admin@kubernetes Switched to context \u0026#34;kubernetes-admin@kubernetes\u0026#34;. 9.4 准入控制 通过了前面的认证和授权之后，还需要经过准入控制处理通过之后，apiserver 才会处理这个请求。\n准入控制是一个可配置的控制器列表，可以通过在 Api-Server 上通过命令行设置选择执行哪些准入控制器：\n--admission-control=NamespaceLifecycle,LimitRanger,ServiceAccount,PersistentVolumeLabel, DefaultStorageClass,ResourceQuota,DefaultTolerationSeconds 只有当所有的准入控制器都检查通过之后，apiserver 才执行该请求，否则返回拒绝。\n当前可配置的 Admission Control 准入控制如下：\nAlwaysAdmit：允许所有请求 AlwaysDeny：禁止所有请求，一般用于测试 AlwaysPullImages：在启动容器之前总去下载镜像 DenyExecOnPrivileged：它会拦截所有想在 Privileged Container 上执行命令的请求 ImagePolicyWebhook：这个插件将允许后端的一个 Webhook 程序来完成 admission controller 的功能。 Service Account：实现 ServiceAccount 实现了自动化 SecurityContextDeny：这个插件将使用 SecurityContext 的 Pod 中的定义全部失效 ResourceQuota：用于资源配额管理目的，观察所有请求，确保在 namespace 上的配额不会超标 LimitRanger：用于资源限制管理，作用于 namespace 上，确保对 Pod 进行资源限制 InitialResources：为未设置资源请求与限制的 Pod，根据其镜像的历史资源的使用情况进行设置 NamespaceLifecycle：如果尝试在一个不存在的 namespace 中创建资源对象，则该创建请求将被拒绝。当删除一个 namespace 时，系统将会删除该 namespace 中所有对象。 DefaultStorageClass：为了实现共享存储的动态供应，为未指定 StorageClass 或 PV 的 PVC 尝试匹配默认的 StorageClass，尽可能减少用户在申请 PVC 时所需了解的后端存储细节 DefaultTolerationSeconds：这个插件为那些没有设置 forgiveness tolerations 并具有 notready:NoExecute 和 unreachable:NoExecute 两种 taints 的 Pod 设置默认的“容忍”时间，为 5min PodSecurityPolicy：这个插件用于在创建或修改 Pod 时决定是否根据 Pod 的 security context 和可用的 PodSecurityPolicy 对 Pod 的安全策略进行控制 10. DashBoard 之前在 kubernetes 中完成的所有操作都是通过命令行工具 kubectl 完成的。其实，为了提供更丰富的用户体验，kubernetes 还开发了一个基于 web 的用户界面（Dashboard）。用户可以使用 Dashboard 部署容器化的应用，还可以监控应用的状态，执行故障排查以及管理 kubernetes 中各种资源。\n10.1 部署 Dashboard 下载 yaml，并运行 Dashboard # 下载yaml [root@k8s-master01 ~]# wget https:/raw.githubusercontent.com/kubernetes/dashboard/v2.0.0/aio/deploy/recommended.yaml # 修改kubernetes-dashboard的Service类型 kind: Service apiVersion: v1 metadata: labels: k8s-app: kubernetes-dashboard name: kubernetes-dashboard namespace: kubernetes-dashboard spec: type: NodePort # 新增 ports: - port: 443 targetPort: 8443 nodePort: 30009 # 新增 selector: k8s-app: kubernetes-dashboard # 部署 [root@k8s-master01 ~]# kubectl create -f recommended.yaml # 查看namespace下的kubernetes-dashboard下的资源 [root@k8s-master01 ~]# kubectl get pod,svc -n kubernetes-dashboard NAME READY STATUS RESTARTS AGE pod/dashboard-metrics-scraper-c79c65bb7-zwfvw 1/1 Running 0 111s pod/kubernetes-dashboard-56484d4c5-z95z5 1/1 Running 0 111s NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE service/dashboard-metrics-scraper ClusterIP 10.96.89.218 \u0026lt;none\u0026gt; 8000/TCP 111s service/kubernetes-dashboard NodePort 10.104.178.171 \u0026lt;none\u0026gt; 443:30009/TCP 111s 2）创建访问账户，获取 token\n# 创建账号 [root@k8s-master01-1 ~]# kubectl create serviceaccount dashboard-admin -n kubernetes-dashboard # 授权 [root@k8s-master01-1 ~]# kubectl create clusterrolebinding dashboard-admin-rb --clusterrole=cluster-admin --serviceaccount=kubernetes-dashboard:dashboard-admin # 获取账号token [root@k8s-master01 ~]# kubectl get secrets -n kubernetes-dashboard | grep dashboard-admin dashboard-admin-token-xbqhh kubernetes.io/service-account-token 3 2m35s [root@k8s-master01 ~]# kubectl describe secrets dashboard-admin-token-xbqhh -n kubernetes-dashboard Name: dashboard-admin-token-xbqhh Namespace: kubernetes-dashboard Labels: \u0026lt;none\u0026gt; Annotations: kubernetes.io/service-account.name: dashboard-admin kubernetes.io/service-account.uid: 95d84d80-be7a-4d10-a2e0-68f90222d039 Type: kubernetes.io/service-account-token Data ==== namespace: 20 bytes token: eyJhbGciOiJSUzI1NiIsImtpZCI6ImJrYkF4bW5XcDhWcmNGUGJtek5NODFuSXl1aWptMmU2M3o4LTY5a2FKS2cifQ.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJrdWJlcm5ldGVzLWRhc2hib2FyZCIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VjcmV0Lm5hbWUiOiJkYXNoYm9hcmQtYWRtaW4tdG9rZW4teGJxaGgiLCJrdWJlcm5ldGVzLmlvL3NlcnZpY2VhY2NvdW50L3NlcnZpY2UtYWNjb3VudC5uYW1lIjoiZGFzaGJvYXJkLWFkbWluIiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9zZXJ2aWNlLWFjY291bnQudWlkIjoiOTVkODRkODAtYmU3YS00ZDEwLWEyZTAtNjhmOTAyMjJkMDM5Iiwic3ViIjoic3lzdGVtOnNlcnZpY2VhY2NvdW50Omt1YmVybmV0ZXMtZGFzaGJvYXJkOmRhc2hib2FyZC1hZG1pbiJ9.NAl7e8ZfWWdDoPxkqzJzTB46sK9E8iuJYnUI9vnBaY3Jts7T1g1msjsBnbxzQSYgAG--cV0WYxjndzJY_UWCwaGPrQrt_GunxmOK9AUnzURqm55GR2RXIZtjsWVP2EBatsDgHRmuUbQvTFOvdJB4x3nXcYLN2opAaMqg3rnU2rr-A8zCrIuX_eca12wIp_QiuP3SF-tzpdLpsyRfegTJZl6YnSGyaVkC9id-cxZRb307qdCfXPfCHR_2rt5FVfxARgg_C0e3eFHaaYQO7CitxsnIoIXpOFNAR8aUrmopJyODQIPqBWUehb7FhlU1DCduHnIIXVC_UICZ-MKYewBDLw ca.crt: 1025 bytes 3）通过浏览器访问 Dashboard 的 UI\n在登录页面上输入上面的 token\n出现下面的页面代表成功\n10.2 使用 DashBoard 本章节以 Deployment 为例演示 DashBoard 的使用\n查看\n选择指定的命名空间dev，然后点击Deployments，查看 dev 空间下的所有 deployment\n扩缩容\n在Deployment上点击规模，然后指定目标副本数量，点击确定\n编辑\n在Deployment上点击编辑，然后修改yaml文件，点击确定\n查看 Pod\n点击Pods, 查看 pods 列表\n操作 Pod\n选中某个 Pod，可以对其执行日志（logs）、进入执行（exec）、编辑、删除操作\nDashboard 提供了 kubectl 的绝大部分功能，这里不再一一演示\n","date":"2024-12-23T00:00:00Z","image":"https://www.colorfulgz.com/p/2024122601/cloud_hu26b4ff2c5f4e80c16b83cdd5c401a19e_26382_120x120_fill_box_smart1_3.png","permalink":"https://www.colorfulgz.com/p/2024122601/","title":"Kubernetes详细教程"},{"content":"部署 nfs centos yum install nfs-utils ubuntu apt install -y nfs-kernel-server 编辑配置文件/etc/exports 来配置我们的 NFS 服务的访问和同步策略\nro 只读 rw 可读写 sync 同步写数据，保证数据不丢失 async 异步写数据，在写入持久化存储之前进行请求响应，如果服务器重启可能会导致文件丢失或者损坏 root_squash 将 root 用户（uid/gid 0）的请求映射为匿名用户（anonymous uid/gid） no_root_squash 禁用 root_squash 规则 all_squash 将所有用户都映射为匿名用户 no_all_squash 禁用 all_squash 规则，默认选项 anonuid 指定要映射为匿名用户的 uid，例如：anonuid=150 anongid 指定要映射为匿名用户的 gid，例如：anongid=100 创建共享目录\nmkdir /data/nfs /data/nfs *(rw,sync,no_subtree_check) 重新共享目录\nexportfs -r 安装 NFS CSI driver git clone https://gitee.com/xyenvy/study-notes.git cd kubernetes/jenkins_deploy/csi-nfs kubectl apply -f . check pods status: kubectl -n kube-system get pod -o wide -l app=csi-nfs-controller kubectl -n kube-system get pod -o wide -l app=csi-nfs-node 创建 StorageClass --- apiVersion: storage.k8s.io/v1 kind: StorageClass metadata: name: nfs-csi annotations: storageclass.kubernetes.io/is-default-class: \u0026#34;true\u0026#34; provisioner: nfs.csi.k8s.io parameters: server: # nfs服务器IP share: /data/nfs/ # nfs服务共享目录 reclaimPolicy: Retain volumeBindingMode: Immediate 创建 namespace --- apiVersion: v1 kind: Namespace metadata: name: jenkins 创建 PVC --- apiVersion: v1 kind: PersistentVolumeClaim metadata: name: jenkins-pvc namespace: jenkins spec: accessModes: - ReadWriteMany resources: requests: storage: 200Gi storageClassName: nfs-csi 创建 rbac apiVersion: v1 kind: ServiceAccount metadata: name: jenkins-master namespace: jenkins --- apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata: name: jenkins-master rules: - apiGroups: [\u0026#34;extensions\u0026#34;, \u0026#34;apps\u0026#34;] resources: [\u0026#34;deployments\u0026#34;] verbs: [\u0026#34;create\u0026#34;, \u0026#34;delete\u0026#34;, \u0026#34;get\u0026#34;, \u0026#34;list\u0026#34;, \u0026#34;watch\u0026#34;, \u0026#34;patch\u0026#34;, \u0026#34;update\u0026#34;] - apiGroups: [\u0026#34;\u0026#34;] resources: [\u0026#34;services\u0026#34;] verbs: [\u0026#34;create\u0026#34;, \u0026#34;delete\u0026#34;, \u0026#34;get\u0026#34;, \u0026#34;list\u0026#34;, \u0026#34;watch\u0026#34;, \u0026#34;patch\u0026#34;, \u0026#34;update\u0026#34;] - apiGroups: [\u0026#34;\u0026#34;] resources: [\u0026#34;pods\u0026#34;] verbs: [\u0026#34;create\u0026#34;, \u0026#34;delete\u0026#34;, \u0026#34;get\u0026#34;, \u0026#34;list\u0026#34;, \u0026#34;patch\u0026#34;, \u0026#34;update\u0026#34;, \u0026#34;watch\u0026#34;] - apiGroups: [\u0026#34;\u0026#34;] resources: [\u0026#34;pods/exec\u0026#34;] verbs: [\u0026#34;create\u0026#34;, \u0026#34;delete\u0026#34;, \u0026#34;get\u0026#34;, \u0026#34;list\u0026#34;, \u0026#34;patch\u0026#34;, \u0026#34;update\u0026#34;, \u0026#34;watch\u0026#34;] - apiGroups: [\u0026#34;\u0026#34;] resources: [\u0026#34;pods/log\u0026#34;] verbs: [\u0026#34;get\u0026#34;, \u0026#34;list\u0026#34;, \u0026#34;watch\u0026#34;] - apiGroups: [\u0026#34;\u0026#34;] resources: [\u0026#34;secrets\u0026#34;] verbs: [\u0026#34;get\u0026#34;] --- apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRoleBinding metadata: name: jenkins-master roleRef: kind: ClusterRole name: jenkins-master apiGroup: rbac.authorization.k8s.io subjects: - kind: ServiceAccount name: jenkins-master namespace: jenkins 创建 deployment --- --- apiVersion: apps/v1 kind: Deployment metadata: name: jenkins namespace: jenkins spec: replicas: 1 selector: matchLabels: app: jenkins template: metadata: labels: app: jenkins spec: serviceAccountName: jenkins-master volumes: - name: jenkins-store persistentVolumeClaim: claimName: jenkins-pvc containers: - name: jenkins image: jenkins/jenkins:jdk17 volumeMounts: - name: jenkins-store mountPath: /var/jenkins_home/ imagePullPolicy: IfNotPresent env: - name: JAVA_OPTS value: -XshowSettings:vm -Dhudson.slaves.NodeProvisioner.initialDelay=0 -Dhudson.slaves.NodeProvisioner.MARGIN=50 -Dhudson.slaves.NodeProvisioner.MARGIN0=0.85 -Duser.timezone=Asia/Shanghai -Djenkins.install.runSetupWizard=true ports: - containerPort: 8080 name: web protocol: TCP - containerPort: 50000 name: agent protocol: TCP resources: requests: cpu: \u0026#34;2\u0026#34; memory: 4G limits: cpu: \u0026#34;2\u0026#34; memory: 4G 创建 service --- apiVersion: v1 kind: Service metadata: name: jenkins namespace: jenkins labels: app: jenkins spec: selector: app: jenkins type: ClusterIP ports: - name: http port: 8080 targetPort: 8080 --- apiVersion: v1 kind: Service metadata: name: jenkins-jnlp namespace: jenkins labels: app: jenkins spec: selector: app: jenkins ports: - name: agent port: 50000 targetPort: 50000 --- apiVersion: v1 kind: Service metadata: name: jenkins-node namespace: jenkins labels: app: jenkins spec: selector: app: jenkins type: NodePort ports: - name: http port: 8080 targetPort: 8080 nodePort: 31080 创建 ingress apiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: jenkins namespace: jenkins spec: ingressClassName: nginx rules: - host: cicd.example.com http: paths: - backend: service: name: jenkins port: number: 8080 path: / pathType: Prefix - host: jnlp.example.com http: paths: - backend: service: name: jenkins port: number: 8080 path: / pathType: Prefix 以下内容需要使用 istio 服务网格才需创建\n创建 gateway apiVersion: networking.istio.io/v1 kind: Gateway metadata: name: example-com-gateway namespace: jenkins spec: selector: istio: ingressgateway servers: - hosts: - cicd.example.com port: name: http number: 80 protocol: HTTP 创建 VirtualService 使用 istio 服务网格\napiVersion: networking.istio.io/v1 kind: VirtualService metadata: name: jenkins-www namespace: jenkins spec: hosts: - \u0026#34;cicd-example.com\u0026#34; gateways: - example-com-gateway http: - match: - uri: prefix: / # rewrite: # uri: / route: - destination: host: jenkins port: number: 8080 初始化 nodeip:31080\n查找登录密码\ncat /var/jenkins_home/secrets/initialAdminPassword 安装中文插件 修改密码 修改插件下载地址\ndefault.json 为插件源地址配置 将国外官方地址替换为国内阿里 jenkins 插件地址 阿里下载地址\nhttps://mirrors.aliyun.com/jenkins/plugins/ sed -i.bak \u0026#39;s#updates.jenkins.io/download#mirrors.aliyun.com/jenkins#g\u0026#39; default.json sed -i \u0026#39;s#www.google.com#www.baidu.com#g\u0026#39; default.json 修改升级站点 url https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json https://mirrors.aliyun.com/jenkins/updates/update-center.json https://jenkins-zh.gitee.io/update-center-mirror/tsinghua/update-center.json 重启 jenkins 即可\n","date":"2024-08-24T00:00:00Z","image":"https://www.colorfulgz.com/p/240824/index_hu861124b96ba3977267ff32a0c417b886_194624_120x120_fill_box_smart1_3.png","permalink":"https://www.colorfulgz.com/p/240824/","title":"kubernetes部署Jenkins"},{"content":" Docker sudo mkdir -p /etc/systemd/system/docker.service.d sudo tee /etc/systemd/system/docker.service.d/proxy.conf \u0026lt;\u0026lt;-\u0026#39;EOF\u0026#39; [Service] Environment=\u0026#34;HTTP_PROXY=http://proxy.example.com:8080/\u0026#34; Environment=\u0026#34;HTTPS_PROXY=http://proxy.example.com:8080/\u0026#34; # dockerd 绕过代理服务器直连 Environment=\u0026#34;NO_PROXY=localhost,127.0.0.1,.example.com\u0026#34; EOF # 重新加载配置文件，重启 dockerd sudo systemctl daemon-reload sudo systemctl restart docker Containerd\n新增 /etc/systemd/system/containerd.service.d/http-proxy.conf 配置文件\nmkdir -p /etc/systemd/system/containerd.service.d touch /etc/systemd/system/containerd.service.d/http-proxy.conf tee /etc/systemd/system/containerd.service.d/http-proxy.conf \u0026lt;\u0026lt; EOF [Service] Environment=\u0026#34;HTTP_PROXY=http://IP:Port\u0026#34; Environment=\u0026#34;HTTPS_PROXY=http://IP:Port\u0026#34; Environment=\u0026#34;NO_PROXY=localhost,127.0.0.1,containerd\u0026#34; EOF systemctl daemon-reload systemctl restart containerd ","date":"2024-06-29T00:00:00Z","image":"https://www.colorfulgz.com/p/2024062901/index_huba1e8d6364f7e1052bfdec59926dce45_350607_120x120_fill_box_smart1_3.png","permalink":"https://www.colorfulgz.com/p/2024062901/","title":"Docker、Containerd使用代理拉取镜像"},{"content":"部署结构 类型 IP 主机名 备注 master01 192.168.3.100 master1 master1 etcd1 master02 192.168.3.101 master2 master2 etcd2 master03 192.168.3.104 master3 master3 etcd3 node01 192.168.3.102 node01 工作节点 node02 192.168.3.103 node02 工作节点 kubeasz 192.168.3.26 kubeasz 部署机器 软件清单 操作系统: Ubuntu server 20.04 k8s版本 1.30.1 calico 3.26.4 etcd 3.5.12 kubeasz 3.6.4 kubeasz 部署高可用 kubernetes 部署节点基本配置 此处部署节点是：192.168.3.26，部署节点的功能如下：\n1从互联⽹下载安装资源 2可选将部分镜像修改tag后上传到公司内部镜像仓库服务器 3对master进⾏初始化 4对node进⾏初始化 5后期集群维护，包括：添加及删除master节点;添加就删除node节点;etcd数据备份及恢复 安装 ansible 并进行 ssh 免密登录：\napt 安装 ansieble，并将部署节点的公钥拷贝至 master、node、etcd 节点\n注： 在部署节点执行\nroot@kuspary:~# apt update \u0026amp;\u0026amp;　apt install ansible -y # 生成密钥对，一路回车即可 root@kuspary:~# ssh-keygen root@kuspary:~# apt install sshpass -y # 如果已经安装不需要执行 #!/bin/bash #目标主机列表 IP=\u0026#34; 192.168.3.100 192.168.3.101 192.168.3.102 192.168.3.103 192.168.3.104 \u0026#34; REMOTE_PORT=\u0026#34;22\u0026#34; REMOTE_USER=\u0026#34;root\u0026#34; REMOTE_PASS=\u0026#34;root\u0026#34; for REMOTE_HOST in ${IP};do REMOTE_CMD=\u0026#34;echo ${REMOTE_HOST} is successfully!\u0026#34; ssh-keyscan -p \u0026#34;${REMOTE_PORT}\u0026#34; \u0026#34;${REMOTE_HOST}\u0026#34; \u0026gt;\u0026gt; ~/.ssh/known_hosts #在本地添加远程主机的公钥信息，避免交互式应答 sshpass -p \u0026#34;${REMOTE_PASS}\u0026#34; ssh-copy-id \u0026#34;${REMOTE_USER}@${REMOTE_HOST}\u0026#34; if [ $? -eq 0 ];then echo ${REMOTE_HOST} 免秘钥配置完成! ssh ${REMOTE_HOST} ln -sv /usr/bin/python3 /usr/bin/python else echo \u0026#34;免密钥配置失败!\u0026#34; fi done # 验证免密登录 ssh 192.168.3.100 下载 kubeasz 项⽬及组件 root@kubeasz:/data/kubeasz# wget https://github.com/easzlab/kubeasz/releases/download/3.6.4/ezdown root@kubeasz:/data/kubeasz# chmod +x ezdown #下载kubeasz代码、二进制、默认容器镜像,会运行一个redistry镜像仓库，将下载的镜像push到仓库 root@kubeasz:/data/kubeasz# ./ezdown -D root@kubeasz:/data/kubeasz# ll /etc/kubeasz/ #kubeasz所有文件和配置路径 total 140 drwxrwxr-x 12 root root 4096 Jun 28 07:35 ./ drwxr-xr-x 108 root root 4096 Jun 28 07:40 ../ -rw-rw-r-- 1 root root 20304 May 22 15:09 ansible.cfg drwxr-xr-x 5 root root 4096 Jun 28 07:35 bin/ drwxrwxr-x 8 root root 4096 Jun 23 15:08 docs/ drwxr-xr-x 3 root root 4096 Jun 28 07:45 down/ drwxrwxr-x 2 root root 4096 Jun 23 15:08 example/ -rwxrwxr-x 1 root root 26507 May 22 15:09 ezctl* -rwxrwxr-x 1 root root 32390 May 22 15:09 ezdown* drwxrwxr-x 4 root root 4096 Jun 23 15:08 .github/ -rw-rw-r-- 1 root root 301 May 22 15:09 .gitignore drwxrwxr-x 10 root root 4096 Jun 23 15:08 manifests/ drwxrwxr-x 2 root root 4096 Jun 23 15:08 pics/ drwxrwxr-x 2 root root 4096 Jun 23 15:08 playbooks/ -rw-rw-r-- 1 root root 6349 May 22 15:09 README.md drwxrwxr-x 22 root root 4096 Jun 23 15:08 roles/ drwxrwxr-x 2 root root 4096 Jun 23 15:08 tools/ 部署集群 root@kubeasz:/data/kubeasz# cd /etc/kubeasz/ root@kubeasz:/etc/kubeasz# ./ezctl new k8s-cluster01 # 新建管理集群 2024-06-28 07:58:21 DEBUG generate custom cluster files in /etc/kubeasz/clusters/k8s-cluster01 #集群使用相关配置路径 2024-06-28 07:58:21 DEBUG set versions 2024-06-28 07:58:21 DEBUG cluster k8s-cluster01: files successfully created. 2024-06-28 07:58:21 INFO next steps 1: to config \u0026#39;/etc/kubeasz/clusters/k8s-cluster01/hosts\u0026#39; #ansible hosts文件 2024-06-28 07:58:21 INFO next steps 2: to config \u0026#39;/etc/kubeasz/clusters/k8s-cluster01/config.yml\u0026#39; #ansible yaml文件 配置用于集群管理的 ansible hosts 文件\nroot@kubeasz:/etc/kubeasz/clusters/k8s-cluster01# pwd /etc/kubeasz/clusters/k8s-cluster01 root@kubeasz:/etc/kubeasz/clusters/k8s-cluster01# ll #注意，这两个文件至关重要，任何小错误都会导致集群有问题 total 20 drwxr-xr-x 2 root root 4096 Jun 28 07:58 ./ drwxr-xr-x 3 root root 4096 Jun 28 07:58 ../ -rw-r--r-- 1 root root 7615 Jun 28 07:58 config.yml -rw-r--r-- 1 root root 2381 Jun 28 07:58 hosts root@kubeasz:/etc/kubeasz/clusters/k8s-cluster01# # 修改hosts文件 vim /etc/kubeasz/clusters/k8s-cluster01/hosts # \u0026#39;etcd\u0026#39; cluster should have odd member(s) (1,3,5,...) [etcd] 192.168.3.100 192.168.3.101 192.168.3.104 # master node(s), set unique \u0026#39;k8s_nodename\u0026#39; for each node # CAUTION: \u0026#39;k8s_nodename\u0026#39; must consist of lower case alphanumeric characters, \u0026#39;-\u0026#39; or \u0026#39;.\u0026#39;, # and must start and end with an alphanumeric character [kube_master] 192.168.3.100 k8s_nodename=\u0026#39;master01\u0026#39; 192.168.3.101 k8s_nodename=\u0026#39;master02\u0026#39; 192.168.3.104 k8s_nodename=\u0026#39;master03\u0026#39; # work node(s), set unique \u0026#39;k8s_nodename\u0026#39; for each node # CAUTION: \u0026#39;k8s_nodename\u0026#39; must consist of lower case alphanumeric characters, \u0026#39;-\u0026#39; or \u0026#39;.\u0026#39;, # and must start and end with an alphanumeric character [kube_node] 192.168.3.102 k8s_nodename=\u0026#39;node01\u0026#39; 192.168.3.103 k8s_nodename=\u0026#39;node02\u0026#39; # [optional] harbor server, a private docker registry # \u0026#39;NEW_INSTALL\u0026#39;: \u0026#39;true\u0026#39; to install a harbor server; \u0026#39;false\u0026#39; to integrate with existed one [harbor] #192.168.1.8 NEW_INSTALL=false # [optional] loadbalance for accessing k8s from outside [ex_lb] #192.168.1.6 LB_ROLE=backup EX_APISERVER_VIP=192.168.1.250 EX_APISERVER_PORT=8443 #192.168.1.7 LB_ROLE=master EX_APISERVER_VIP=192.168.1.250 EX_APISERVER_PORT=8443 # [optional] ntp server for the cluster [chrony] #192.168.1.1 [all:vars] # --------- Main Variables --------------- # Secure port for apiservers SECURE_PORT=\u0026#34;6443\u0026#34; # Cluster container-runtime supported: docker, containerd # if k8s version \u0026gt;= 1.24, docker is not supported CONTAINER_RUNTIME=\u0026#34;containerd\u0026#34; # Network plugins supported: calico, flannel, kube-router, cilium, kube-ovn CLUSTER_NETWORK=\u0026#34;calico\u0026#34; # Service proxy mode of kube-proxy: \u0026#39;iptables\u0026#39; or \u0026#39;ipvs\u0026#39; PROXY_MODE=\u0026#34;ipvs\u0026#34; # K8S Service CIDR, not overlap with node(host) networking SERVICE_CIDR=\u0026#34;10.68.0.0/16\u0026#34; # Cluster CIDR (Pod CIDR), not overlap with node(host) networking CLUSTER_CIDR=\u0026#34;172.20.0.0/16\u0026#34; # NodePort Range NODE_PORT_RANGE=\u0026#34;30000-32767\u0026#34; # Cluster DNS Domain CLUSTER_DNS_DOMAIN=\u0026#34;cluster.local\u0026#34; # -------- Additional Variables (don\u0026#39;t change the default value right now) --- # Binaries Directory bin_dir=\u0026#34;/opt/kube/bin\u0026#34; # Deploy Directory (kubeasz workspace) base_dir=\u0026#34;/etc/kubeasz\u0026#34; # Directory for a specific cluster cluster_dir=\u0026#34;{{ base_dir }}/clusters/k8s-cluster01\u0026#34; # CA and other components cert/key Directory ca_dir=\u0026#34;/etc/kubernetes/ssl\u0026#34; # Default \u0026#39;k8s_nodename\u0026#39; is empty k8s_nodename=\u0026#39;\u0026#39; # Default python interpreter ansible_python_interpreter=/usr/bin/python config.yml 是用于配置 K8S 集群的具体配置\nvim /etc/kubeasz/clusters/k8s-cluster01/config.yml #修改为以下配置，注意修改master的IP以及DNS相关配置、images配置等 ############################ # prepare ############################ # 可选离线安装系统软件包 (offline|online) INSTALL_SOURCE: \u0026#34;online\u0026#34; # 可选进行系统安全加固 github.com/dev-sec/ansible-collection-hardening # (deprecated) 未更新上游项目，未验证最新k8s集群安装，不建议启用 OS_HARDEN: false ############################ # role:deploy ############################ # default: ca will expire in 100 years # default: certs issued by the ca will expire in 50 years CA_EXPIRY: \u0026#34;876000h\u0026#34; CERT_EXPIRY: \u0026#34;876000h\u0026#34; # force to recreate CA and other certs, not suggested to set \u0026#39;true\u0026#39; CHANGE_CA: false # kubeconfig 配置参数 CLUSTER_NAME: \u0026#34;cluster1\u0026#34; CONTEXT_NAME: \u0026#34;context-{{ CLUSTER_NAME }}\u0026#34; # k8s version K8S_VER: \u0026#34;1.30.1\u0026#34; # set unique \u0026#39;k8s_nodename\u0026#39; for each node, if not set(default:\u0026#39;\u0026#39;) ip add will be used # CAUTION: \u0026#39;k8s_nodename\u0026#39; must consist of lower case alphanumeric characters, \u0026#39;-\u0026#39; or \u0026#39;.\u0026#39;, # and must start and end with an alphanumeric character (e.g. \u0026#39;example.com\u0026#39;), # regex used for validation is \u0026#39;[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*\u0026#39; K8S_NODENAME: \u0026#34;{%- if k8s_nodename != \u0026#39;\u0026#39; -%} \\ {{ k8s_nodename|replace(\u0026#39;_\u0026#39;, \u0026#39;-\u0026#39;)|lower }} \\ {%- else -%} \\ k8s-{{ inventory_hostname|replace(\u0026#39;.\u0026#39;, \u0026#39;-\u0026#39;) }} \\ {%- endif -%}\u0026#34; # use \u0026#39;K8S_NODENAME\u0026#39; to set hostname ENABLE_SETTING_HOSTNAME: true ############################ # role:etcd ############################ # 设置不同的wal目录，可以避免磁盘io竞争，提高性能 ETCD_DATA_DIR: \u0026#34;/var/lib/etcd\u0026#34; ETCD_WAL_DIR: \u0026#34;\u0026#34; ############################ # role:runtime [containerd,docker] ############################ # [.]启用拉取加速镜像仓库 ENABLE_MIRROR_REGISTRY: true # [.]添加信任的私有仓库 # 必须按照如下示例格式，协议头\u0026#39;http://\u0026#39;和\u0026#39;https://\u0026#39;不能省略 INSECURE_REG: - \u0026#34;http://easzlab.io.local:5000\u0026#34; # [.]基础容器镜像 SANDBOX_IMAGE: \u0026#34;easzlab.io.local:5000/easzlab/pause:3.9\u0026#34; # [containerd]容器持久化存储目录 CONTAINERD_STORAGE_DIR: \u0026#34;/var/lib/containerd\u0026#34; # [docker]容器存储目录 DOCKER_STORAGE_DIR: \u0026#34;/var/lib/docker\u0026#34; # [docker]开启Restful API DOCKER_ENABLE_REMOTE_API: false ############################ # role:kube-master ############################ # k8s 集群 master 节点证书配置，可以添加多个ip和域名（比如增加公网ip和域名） MASTER_CERT_HOSTS: - \u0026#34;192.168.3.100\u0026#34; - \u0026#34;192.168.3.101\u0026#34; - \u0026#34;192.168.3.104\u0026#34; - \u0026#34;master1\u0026#34; - \u0026#34;master2\u0026#34; - \u0026#34;master3\u0026#34; #- \u0026#34;www.test.com\u0026#34; # node 节点上 pod 网段掩码长度（决定每个节点最多能分配的pod ip地址） # 如果flannel 使用 --kube-subnet-mgr 参数，那么它将读取该设置为每个节点分配pod网段 # https://github.com/coreos/flannel/issues/847 NODE_CIDR_LEN: 24 ############################ # role:kube-node ############################ # Kubelet 根目录 KUBELET_ROOT_DIR: \u0026#34;/var/lib/kubelet\u0026#34; # node节点最大pod 数 MAX_PODS: 110 # 配置为kube组件（kubelet,kube-proxy,dockerd等）预留的资源量 # 数值设置详见templates/kubelet-config.yaml.j2 KUBE_RESERVED_ENABLED: \u0026#34;no\u0026#34; # k8s 官方不建议草率开启 system-reserved, 除非你基于长期监控，了解系统的资源占用状况； # 并且随着系统运行时间，需要适当增加资源预留，数值设置详见templates/kubelet-config.yaml.j2 # 系统预留设置基于 4c/8g 虚机，最小化安装系统服务，如果使用高性能物理机可以适当增加预留 # 另外，集群安装时候apiserver等资源占用会短时较大，建议至少预留1g内存 SYS_RESERVED_ENABLED: \u0026#34;no\u0026#34; ############################ # role:network [flannel,calico,cilium,kube-ovn,kube-router] ############################ # ------------------------------------------- flannel # [flannel]设置flannel 后端\u0026#34;host-gw\u0026#34;,\u0026#34;vxlan\u0026#34;等 FLANNEL_BACKEND: \u0026#34;vxlan\u0026#34; DIRECT_ROUTING: false # [flannel] flannel_ver: \u0026#34;v0.22.2\u0026#34; # ------------------------------------------- calico # [calico] IPIP隧道模式可选项有: [Always, CrossSubnet, Never],跨子网可以配置为Always与CrossSubnet(公有云建议使用always比较省事，其他的话需要修改各自公有云的网络配置，具体可以参考各个公有云说明) # 其次CrossSubnet为隧道+BGP路由混合模式可以提升网络性能，同子网配置为Never即可. CALICO_IPV4POOL_IPIP: \u0026#34;Always\u0026#34; # [calico]设置 calico-node使用的host IP，bgp邻居通过该地址建立，可手工指定也可以自动发现 IP_AUTODETECTION_METHOD: \u0026#34;can-reach={{ groups[\u0026#39;kube_master\u0026#39;][0] }}\u0026#34; # [calico]设置calico 网络 backend: bird, vxlan, none CALICO_NETWORKING_BACKEND: \u0026#34;bird\u0026#34; # [calico]设置calico 是否使用route reflectors # 如果集群规模超过50个节点，建议启用该特性 CALICO_RR_ENABLED: false # CALICO_RR_NODES 配置route reflectors的节点，如果未设置默认使用集群master节点 # CALICO_RR_NODES: [\u0026#34;192.168.1.1\u0026#34;, \u0026#34;192.168.1.2\u0026#34;] CALICO_RR_NODES: [] # [calico]更新支持calico 版本: [\u0026#34;3.19\u0026#34;, \u0026#34;3.23\u0026#34;] calico_ver: \u0026#34;v3.26.4\u0026#34; # [calico]calico 主版本 calico_ver_main: \u0026#34;{{ calico_ver.split(\u0026#39;.\u0026#39;)[0] }}.{{ calico_ver.split(\u0026#39;.\u0026#39;)[1] }}\u0026#34; # ------------------------------------------- cilium # [cilium]镜像版本 cilium_ver: \u0026#34;1.15.5\u0026#34; cilium_connectivity_check: true cilium_hubble_enabled: false cilium_hubble_ui_enabled: false # ------------------------------------------- kube-ovn # [kube-ovn]离线镜像tar包 kube_ovn_ver: \u0026#34;v1.11.5\u0026#34; # ------------------------------------------- kube-router # [kube-router]公有云上存在限制，一般需要始终开启 ipinip；自有环境可以设置为 \u0026#34;subnet\u0026#34; OVERLAY_TYPE: \u0026#34;full\u0026#34; # [kube-router]NetworkPolicy 支持开关 FIREWALL_ENABLE: true # [kube-router]kube-router 镜像版本 kube_router_ver: \u0026#34;v1.5.4\u0026#34; ############################ # role:cluster-addon ############################ # coredns 自动安装 dns_install: \u0026#34;yes\u0026#34; corednsVer: \u0026#34;1.11.1\u0026#34; ENABLE_LOCAL_DNS_CACHE: true dnsNodeCacheVer: \u0026#34;1.22.28\u0026#34; # 设置 local dns cache 地址 LOCAL_DNS_CACHE: \u0026#34;169.254.20.10\u0026#34; # metric server 自动安装 metricsserver_install: \u0026#34;yes\u0026#34; metricsVer: \u0026#34;v0.7.1\u0026#34; # dashboard 自动安装 dashboard_install: \u0026#34;yes\u0026#34; dashboardVer: \u0026#34;v2.7.0\u0026#34; dashboardMetricsScraperVer: \u0026#34;v1.0.8\u0026#34; # prometheus 自动安装 prom_install: \u0026#34;no\u0026#34; prom_namespace: \u0026#34;monitor\u0026#34; prom_chart_ver: \u0026#34;45.23.0\u0026#34; # kubeapps 自动安装，如果选择安装，默认同时安装local-storage（提供storageClass: \u0026#34;local-path\u0026#34;） kubeapps_install: \u0026#34;no\u0026#34; kubeapps_install_namespace: \u0026#34;kubeapps\u0026#34; kubeapps_working_namespace: \u0026#34;default\u0026#34; kubeapps_storage_class: \u0026#34;local-path\u0026#34; kubeapps_chart_ver: \u0026#34;12.4.3\u0026#34; # local-storage (local-path-provisioner) 自动安装 local_path_provisioner_install: \u0026#34;no\u0026#34; local_path_provisioner_ver: \u0026#34;v0.0.26\u0026#34; # 设置默认本地存储路径 local_path_provisioner_dir: \u0026#34;/opt/local-path-provisioner\u0026#34; # nfs-provisioner 自动安装 nfs_provisioner_install: \u0026#34;no\u0026#34; nfs_provisioner_namespace: \u0026#34;kube-system\u0026#34; nfs_provisioner_ver: \u0026#34;v4.0.2\u0026#34; nfs_storage_class: \u0026#34;managed-nfs-storage\u0026#34; nfs_server: \u0026#34;192.168.1.10\u0026#34; nfs_path: \u0026#34;/data/nfs\u0026#34; # network-check 自动安装 network_check_enabled: false network_check_schedule: \u0026#34;*/5 * * * *\u0026#34; ############################ # role:harbor ############################ # harbor version，完整版本号 HARBOR_VER: \u0026#34;v2.10.2\u0026#34; HARBOR_DOMAIN: \u0026#34;harbor.easzlab.io.local\u0026#34; HARBOR_PATH: /var/data HARBOR_TLS_PORT: 8443 HARBOR_REGISTRY: \u0026#34;{{ HARBOR_DOMAIN }}:{{ HARBOR_TLS_PORT }}\u0026#34; # if set \u0026#39;false\u0026#39;, you need to put certs named harbor.pem and harbor-key.pem in directory \u0026#39;down\u0026#39; HARBOR_SELF_SIGNED_CERT: true # install extra component HARBOR_WITH_TRIVY: false 部署 root@kubeasz:/etc/kubeasz# ./ezctl --help #查看具体安装步骤，依次按顺序执行来部署k8s各组件，具体每步含义可参考官网 Usage: ezctl COMMAND [args] ------------------------------------------------------------------------------------- Cluster setups: list to list all of the managed clusters checkout \u0026lt;cluster\u0026gt; to switch default kubeconfig of the cluster new \u0026lt;cluster\u0026gt; to start a new k8s deploy with name \u0026#39;cluster\u0026#39; setup \u0026lt;cluster\u0026gt; \u0026lt;step\u0026gt; to setup a cluster, also supporting a step-by-step way start \u0026lt;cluster\u0026gt; to start all of the k8s services stopped by \u0026#39;ezctl stop\u0026#39; stop \u0026lt;cluster\u0026gt; to stop all of the k8s services temporarily upgrade \u0026lt;cluster\u0026gt; to upgrade the k8s cluster destroy \u0026lt;cluster\u0026gt; to destroy the k8s cluster backup \u0026lt;cluster\u0026gt; to backup the cluster state (etcd snapshot) restore \u0026lt;cluster\u0026gt; to restore the cluster state from backups start-aio to quickly setup an all-in-one cluster with default settings Cluster ops: add-etcd \u0026lt;cluster\u0026gt; \u0026lt;ip\u0026gt; to add a etcd-node to the etcd cluster add-master \u0026lt;cluster\u0026gt; \u0026lt;ip\u0026gt; to add a master node to the k8s cluster add-node \u0026lt;cluster\u0026gt; \u0026lt;ip\u0026gt; to add a work node to the k8s cluster del-etcd \u0026lt;cluster\u0026gt; \u0026lt;ip\u0026gt; to delete a etcd-node from the etcd cluster del-master \u0026lt;cluster\u0026gt; \u0026lt;ip\u0026gt; to delete a master node from the k8s cluster del-node \u0026lt;cluster\u0026gt; \u0026lt;ip\u0026gt; to delete a work node from the k8s cluster Extra operation: kca-renew \u0026lt;cluster\u0026gt; to force renew CA certs and all the other certs (with caution) kcfg-adm \u0026lt;cluster\u0026gt; \u0026lt;args\u0026gt; to manage client kubeconfig of the k8s cluster Use \u0026#34;ezctl help \u0026lt;command\u0026gt;\u0026#34; for more information about a given command. ./ezctl setup k8s-cluster01 all # 安装第一步到第七步 等待安装完成。\n获取集群节点信息 # 部署节点执行 kubectl get nodes NAME STATUS ROLES AGE VERSION master01 Ready,SchedulingDisabled master 20m v1.30.1 master02 Ready,SchedulingDisabled master 20m v1.30.1 master03 Ready,SchedulingDisabled master 20m v1.30.1 node01 Ready node 20m v1.30.1 node02 Ready node 20m v1.30.1 将部署节点 ~/.kube 目录下的文件拷贝到 master1 master2 master3 的 ~/.kube 目录下，并验证.\nscp -r /root/.kube/* 192.168.3.100:/root/.kube scp -r /root/.kube/* 192.168.3.101:/root/.kube scp -r /root/.kube/* 192.168.3.104:/root/.kube master1 root@master01:~# kubectl get nodes NAME STATUS ROLES AGE VERSION master01 Ready,SchedulingDisabled master 9m37s v1.30.1 master02 Ready,SchedulingDisabled master 9m37s v1.30.1 master03 Ready,SchedulingDisabled master 9m37s v1.30.1 node01 Ready node 8m56s v1.30.1 node02 Ready node 8m56s v1.30.1 master2 root@master02:~# kubectl get nodes NAME STATUS ROLES AGE VERSION master01 Ready,SchedulingDisabled master 10m v1.30.1 master02 Ready,SchedulingDisabled master 10m v1.30.1 master03 Ready,SchedulingDisabled master 10m v1.30.1 node01 Ready node 9m45s v1.30.1 node02 Ready node 9m45s v1.30.1 master3 root@master03:~# kubectl get nodes NAME STATUS ROLES AGE VERSION master01 Ready,SchedulingDisabled master 11m v1.30.1 master02 Ready,SchedulingDisabled master 11m v1.30.1 master03 Ready,SchedulingDisabled master 11m v1.30.1 node01 Ready node 10m v1.30.1 node02 Ready node 10m v1.30.1 修改 config 配置文件 从部署节点拷贝的 config 配置文件中 server 字段的值指定了三个 master 节点之中的其中一个，保证高可用需要修改值，修改成\nhttps://127.0.0.1:6443 kubeasz 部署的集群会在每个节点部署一个 kube-lb，查看/etc/kube-lb/conf/kube-lb.conf\ncat /etc/kube-lb/conf/kube-lb.conf user root; worker_processes 1; error_log /etc/kube-lb/logs/error.log warn; events { worker_connections 3000; } stream { upstream backend { server 192.168.3.100:6443 max_fails=2 fail_timeout=3s; server 192.168.3.101:6443 max_fails=2 fail_timeout=3s; server 192.168.3.104:6443 max_fails=2 fail_timeout=3s; } server { listen 127.0.0.1:6443; proxy_connect_timeout 1s; proxy_pass backend; } } # 所有master节点都需要修改 # 修改前 server: https://192.168.3.100:6443 # 修改后 server: https://127.0.0.1:6443 # 验证是否能访问api root@master01:~/.kube# kubectl get nodes NAME STATUS ROLES AGE VERSION master01 Ready,SchedulingDisabled master 22m v1.30.1 master02 Ready,SchedulingDisabled master 22m v1.30.1 master03 Ready,SchedulingDisabled master 22m v1.30.1 node01 Ready node 22m v1.30.1 node02 Ready node 22m v1.30.1 增加 master 节点 操作步骤 执行如下 (假设待增加节点为 192.168.3.128, 集群名称 k8s-cluster01)： # 部署节点执行 # ssh 免密码登录 $ ssh-copy-id 192.168.3.128 # 新增节点 $ ezctl add-master k8s-cluster01 192.168.3.128 # 同理，重复上面步骤再新增节点并自定义nodename $ ezctl add-master k8s-cluster01 192.168.3.128 k8s_nodename=master-03 增加 kube_node 节点 操作步骤 执行如下 (假设待增加节点为 192.168.3.129，k8s集群名为 k8s-cluster01)： # ssh 免密码登录 # 部署节点执行 $ ssh-copy-id 192.168.3.129 # 新增节点 $ ezctl add-node test-k8s 192.168.3.129 # 同理，重复上面步骤再新增节点并自定义nodename $ ezctl add-node test-k8s 192.168.1.129 k8s_nodename=worker-03 ","date":"2024-06-28T00:00:00Z","image":"https://www.colorfulgz.com/p/24062801/index_hu84ea1062d50aaadcc8573c3c51d20f27_1044746_120x120_fill_box_smart1_3.png","permalink":"https://www.colorfulgz.com/p/24062801/","title":"kubeasz 部署高可用k8s 集群"},{"content":"主要步骤：\n本地 Centos8.2 环境下自建 mysql8.0.25 下载安装 qpress、Percona XtraBackup 下载数据库物理备份文件 执行备份恢复 一、本地安装 MySQL8.0.25 这里使用的是 docker 运行的 创建相关目录\nmkdir -pv /data/mysql/ {data,conf} 创建配置文件，可以运行一个 MySQL 容器，从容器中拷贝出来\n[mysqld] pid-file = /var/run/mysqld/mysqld.pid socket = /var/run/mysqld/mysqld.sock datadir = /var/lib/mysql secure-file-priv= NULL # Custom config should go here !includedir /etc/mysql/conf.d/ 运行容器\ndocker run --name mysql8 -e MYSQL_ROOT_PASSWORD=123456 -v /etc/localtime:/etc/localtime:ro -v /data/mysql/data:/var/lib/mysql -v /data/mysql/conf/my.cnf:/etc/mysql/my.cnf -p 3306:3306 -d mysql:8.0.25 二、 下载安装 qpress、Percona XtraBackup 安装 qpress yum install -y qpress 安装 Percona XtraBackup 对于 MySQL 5.7，需要下载及安装 Percona XtraBackup 2.4 及以上版本，MySQL8 需要安装 Percona XtraBackup8，本文使用的是 MySQL8，所以需要下载 Percona XtraBackup8 下载地址\r# 上传官网下载的二进制包 tar xf percona-xtrabackup-8.0.25-17-Linux-x86_64.glibc2.12.tar.gz cp percona-xtrabackup-8.0.25-17-Linux-x86_64.glibc2.12/bin/* /usr/bin/ 三、下载数据库备份物理文件 自行下载不做演示\n四、执行备份恢复 #创建存放数据目录 mkdir data # 将备份文件解包到data目录 xbstream -x -p 4 \u0026lt; 备份文件.qp -C data # 解压备份文件 xtrabackup --decompress --remove-original --parallel=4 --target-dir=./data/ # 应用日志 xtrabackup --prepare --target-dir=./data/ 注意：避免出现版本问题，需要修改解压后的 backup-my.cnf 文件，注释掉自建数据库不支持的参数\n# This MySQL options file was generated by innobackupex. # The MySQL server [mysqld] innodb_checksum_algorithm=crc32 innodb_log_checksums=1 innodb_data_file_path=ibdata1:128M:autoextend innodb_log_file_size=1048576000 innodb_page_size=16384 innodb_undo_directory=./ innodb_undo_tablespaces=2 server_id=2497588870 innodb_log_checksums=ON innodb_redo_log_encrypt=OFF innodb_undo_log_encrypt=OFF server_uuid=d28d00b3-250f-11ed-87d8-fa163e6bd119 master_key_id=0 rds_xa_crash_safe=ON 停止数据库容器，修改 MySQL 数据库配置文件，以及修改 root 账号密码与原数据库密码一致，并将 data 目录与容器内/var/lib/mysql 进行挂载，启动数据库，验证数据恢复\n","date":"2024-06-20T00:00:00Z","image":"https://www.colorfulgz.com/p/240620/index_hubcb3d1af62b1e994dd1701709cff740a_17576_120x120_fill_q75_box_smart1.jpg","permalink":"https://www.colorfulgz.com/p/240620/","title":"通过华为云数据库.qp备份文件恢复自建数据库"},{"content":" 软件版本 kubernetes 版本：V1.25.9\nkubernetes-Dashboard 版本：v2.7.0\n部署 Dashboard UI 默认情况下不会部署 Dashboard。可以通过以下命令部署：\nkubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.7.0/aio/deploy/recommended.yaml 为了集群外能够访问，需要将 service 类型修改为 NodePort，如下：\nkind: Service apiVersion: v1 metadata: labels: k8s-app: kubernetes-dashboard name: kubernetes-dashboard namespace: kubernetes-dashboard spec: type: NodePort # 新增 ports: - port: 443 targetPort: 8443 nodePort: 30009 #新增 selector: k8s-app: kubernetes-dashboard 访问 Dashboard 用户界面 使用集群任意 node 节点的 IP:port,port 为步骤\u0026quot;部署 Dashboard UI\u0026quot;新增的 nodePort 字段的值。\n为了保护集群数据，默认情况下，Dashboard 会使用最少的 RBAC 配置进行部署。 当前，Dashboard 仅支持使用 Bearer 令牌登录。\n创建服务帐户 首先使用命名空间中的名称创建服务帐户。admin-userkubernetes-dashboard\napiVersion: v1 kind: ServiceAccount metadata: name: admin-user namespace: kubernetes-dashboard 创建 ClusterRoleBinding 在大多数情况下，在使用 或任何其他常用工具预配集群后，集群中已存在 。我们可以使用它并只为我们的 . 如果该角色不存在，则需要先创建此角色并手动授予所需的权限。kopskubeadmClusterRolecluster-adminClusterRoleBindingServiceAccount\napiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRoleBinding metadata: name: admin-user roleRef: apiGroup: rbac.authorization.k8s.io kind: ClusterRole name: cluster-admin subjects: - kind: ServiceAccount name: admin-user namespace: kubernetes-dashboard 获取 ServiceAccount 的持有者令牌 现在我们需要找到可用于登录的令牌。执行以下命令：\nkubectl -n kubernetes-dashboard create token admin-user 它应该打印如下内容：\neyJhbGciOiJSUzI1NiIsImtpZCI6IiJ9.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJrdWJlcm5ldGVzLWRhc2hib2FyZCIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VjcmV0Lm5hbWUiOiJhZG1pbi11c2VyLXRva2VuLXY1N253Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9zZXJ2aWNlLWFjY291bnQubmFtZSI6ImFkbWluLXVzZXIiLCJrdWJlcm5ldGVzLmlvL3NlcnZpY2VhY2NvdW50L3NlcnZpY2UtYWNjb3VudC51aWQiOiIwMzAzMjQzYy00MDQwLTRhNTgtOGE0Ny04NDllZTliYTc5YzEiLCJzdWIiOiJzeXN0ZW06c2VydmljZWFjY291bnQ6a3ViZXJuZXRlcy1kYXNoYm9hcmQ6YWRtaW4tdXNlciJ9.Z2JrQlitASVwWbc-s6deLRFVk5DWD3P_vjUFXsqVSY10pbjFLG4njoZwh8p3tLxnX_VBsr7_6bwxhWSYChp9hwxznemD5x5HLtjb16kI9Z7yFWLtohzkTwuFbqmQaMoget_nYcQBUC5fDmBHRfFvNKePh_vSSb2h_aYXa8GV5AcfPQpY7r461itme1EXHQJqv-SN-zUnguDguCTjD80pFZ_CmnSE1z9QdMHPB8hoB4V68gtswR1VLa6mSYdgPwCHauuOobojALSaMc3RH7MmFUumAgguhqAkX3Omqd3rJbYOMRuMjhANqd08piDC3aIabINX6gP5-Tuuw2svnV6NYQ 获取 ServiceAccount 的长期持有者令牌 我们还可以创建一个带有 secret 的 token，该 token 绑定了服务帐户，该 token 将保存在 Secret 中：\napiVersion: v1 kind: Secret metadata: name: admin-user namespace: kubernetes-dashboard annotations: kubernetes.io/service-account.name: \u0026#34;admin-user\u0026#34; type: kubernetes.io/service-account-token 创建 Secret 后，我们可以执行以下命令来获取保存在 Secret 中的 Token：\nkubectl get secret admin-user -n kubernetes-dashboard -o jsonpath={\u0026#34;.data.token\u0026#34;} | base64 -d 访问仪表板 现在复制令牌并将其粘贴到登录屏幕上的字段中。Enter token 单击按钮，仅此而已。您现在以管理员身份登录。Sign in ","date":"2023-12-17T00:00:00Z","image":"https://www.colorfulgz.com/p/231227/index_hu1b49391640bf8c623406bc20c8d53a7d_200620_120x120_fill_box_smart1_3.png","permalink":"https://www.colorfulgz.com/p/231227/","title":"部署和访问 Kubernetes 仪表板（Dashboard）"},{"content":"POD 运行 POD # 命令格式： kubectl run (pod控制器名称) [参数] # --image 指定Pod的镜像 # --port 指定端口 # --namespace 指定namespace kubectl run nginx --image=nginx:latest --port=80 --namespace dev POD 环境变量 apiVersion: apps/v1 kind: Deployment metadata: creationTimestamp: null labels: app: mysql-env-pod name: mysql-env-pod namespace: app-dev spec: replicas: 1 selector: matchLabels: app: mysql-env-pod template: metadata: creationTimestamp: null labels: app: mysql-env-pod spec: containers: - image: images.io:5000/app/mysql name: mysql env: - name: MYSQL_ROOT_PASSWORD value: \u0026#34;123456\u0026#34; ports: - containerPort: 3306 查看 POD 信息 # 查看Pod基本信息 [root@master ~]# kubectl get pods -n dev NAME READY STATUS RESTARTS AGE nginx 1/1 Running 0 43s # 查看Pod的详细信息 [root@master ~]# kubectl describe pod nginx -n dev 删除 POD kubectl delete pod nginx -n dev 配置操作 创建一个 pod-nginx.yaml，内容如下：\napiVersion: v1 kind: Pod metadata: name: nginx namespace: dev spec: containers: - image: nginx:latest name: pod ports: - name: nginx-port containerPort: 80 protocol: TCP ConfigMap 创建 ConfigMap 对象的方法有两种\n命令式命令\n1.字面量：kubectl create configmap NAME --from-literal=key1=value1 2.从文件加载：kubectl create configmap NAME --from-file=[key=]/PATH/TO/FILE 3.从目录加载： kubectl create configmap NAME --from-file=[key=]/PATH/TO/DIR/ 配置文件\n1.命令式：kubectl create -f 2.声明式：kubectl apply -f 提示：基于文件内容生成时，可以使用命令式命令以 dry-run 模式生成并保存\n查看帮助\nkubectl create configmap -h 案例 1：\nkubectl create configmap my-cm --from-literal=\u0026#39;test.html\u0026#39;=\u0026#39;this is nignx\u0026#39; --dry-run=client -o yaml \u0026gt; my-cm.yaml 文件内容\napiVersion: v1 data: test.html: this is nignx kind: ConfigMap metadata: creationTimestamp: null name: my-cm 案例 2：\nkubectl create cm my-cm2 --from-file=./map.txt --dry-run=client -o yaml \u0026gt;my-cm2.yaml 文件内容\napiVersion: v1 data: map.txt: | configmap kind: ConfigMap metadata: creationTimestamp: null name: my-cm2 引用 ConfigMap 对象 ConfigMap 资源对象中以 key-value 保存的数据，在 Pod 中引用的方式通常有两种\n环境变量 1.引用ConfigMap对象上特定的key，以valueFrom赋值给Pod上指定的环境变量 2.在Pod上使用envFrom一次性导入ConfigMap对象上的所有key-value，key（也可以统一附加特定前缀）即为环境变量名，value自动成为相应的变量值 configMap 卷 1.在Pod上将ConfigMap对象引用为存储卷，而后整体由容器mount至某个目录下;key转为文件名，value即为相应的文件内容 2.在Pod上定义configMap卷时，仅引用其中的部分key，而后由容器mount至目录下 3.在容器上仅mount configMap卷上指定的key 在 Pod 上配置使用 ConfigMap 示例 1.通过存储卷引用\napiVersion: apps/v1 kind: Deployment metadata: labels: app: my-dep name: my-dep spec: replicas: 1 selector: matchLabels: app: my-dep template: metadata: labels: app: my-dep spec: containers: - image: nginx:latest name: nginx ports: - containerPort: 80 volumeMounts: - name: my-cm-configmap # 卷名称 mountPath: /usr/share/nginx/html/ # 容器内挂载路径 readOnly: true # 只读 否 volumes: - name: my-cm-configmap # 卷名称 configMap: name: my-cm # configmap名称 optional: false 2.通过环境变量引用\napiVersion: apps/v1 kind: Deployment metadata: labels: app: my-dep name: my-dep spec: replicas: 1 selector: matchLabels: app: my-dep template: metadata: labels: app: my-dep spec: containers: - image: nginx:latest name: nginx ports: - containerPort: 80 env: - name: PORT valueFrom: configMapKeyRef: name: my-cm key: \u0026#39;test.html\u0026#39; optional: false Secret secret 资源 1.Secret 主要用于存储密钥、OAuth 令牌和 SSH 密钥等敏感信息，这些敏感信息采用 base64 编码保存，略好于明文存储\n2.Secret 根据其用途等，还有类型上的区分\n创建 Secret 资源 支持类似于 ConfigMap 的创建方式，但 Secret 有类型子命令，而且不同类型在 data 或 stringData 字段中支持嵌套使用的 key 亦会有所有同\n命令式命令\n#generic 1.kubectl create secret generic NAME [--type=string] [--from-file=[key=]source] [--from-literal=key1=value1] 2.除了后面docker-registry和tls命令之外的其它类型，都可以使用该命令中的--type选项进行定义，但有些类型有key的特定要求 #tls 1.kubectl create secret tls NAME --cert=path/to/cert/file --key=path/to/key/file 2.通常，其保存cert文件内容的key为tls.crt，而保存private key的key为tls.key #docker-registry 1.kubectl create secret docker-registry NAME --docker-username=user --docker-password=password --docker-email=email [--docker-server=string] [--from-file=[key=]source] 2.通常，从已有的json格式的文件加载生成的就是dockerconfigjson类型，命令行直接量生成的也是该类型 资源示例 命令式 kubectl create secret generic mysql-root-auth --from-literal=username=root --from-literal=passwd=123456 --dry-run=client -o yaml kubectl create secret tls my-tls --cert=./itshare.crt --key=./itshare.key --dry-run=client -o yaml 配置文件 apiVersion: v1 data: passwd: MTIzNDU2 username: cm9vdA== kind: Secret metadata: name: mysql-root-auth apiVersion: v1 data: tls.crt: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSURFVENDQWZrQ0ZEVjRpUFhjNlNIelR4a2NzdEwzTFUxRFRzTmNNQTBHQ1NxR1NJYjNEUUVCQ3dVQU1FVXgKQ3pBSkJnTlZCQVlUQWtGVk1STXdFUVlEVlFRSURBcFRiMjFsTFZOMFlYUmxNU0V3SHdZRFZRUUtEQmhKYm5SbApjbTVsZENCWGFXUm5hWFJ6SUZCMGVTQk1kR1F3SGhjTk1qTXdOakl6TVRZeU1qQTJXaGNOTWpRd05qSXlNVFl5Ck1qQTJXakJGTVFzd0NRWURWUVFHRXdKQlZURVRNQkVHQTFVRUNBd0tVMjl0WlMxVGRHRjBaVEVoTUI4R0ExVUUKQ2d3WVNXNTBaWEp1WlhRZ1YybGtaMmwwY3lCUWRIa2dUSFJrTUlJQklqQU5CZ2txaGtpRzl3MEJBUUVGQUFPQwpBUThBTUlJQkNnS0NBUUVBelFPZEZodlNlejJVNEZVK3lIaU1qT3BCWHhVd0RiV1NScW5GaUFMenc3OFk0bmx1Cmw3MFFzeGlTNEdndFJKK1JwZlRuSEF5RTVmNUxnS2lCc0U1WS9IdlQ5NDZSWEZZYVEyOTBNYTNSbFY3b3V3ODMKUmVTZmg0ZWI2cmlKVW00eVBYaUxUZHRmNXF2K2FuZGtFdVZ1VlFaMUpOVUxoRFF0dzRFQ1J4eURvc0s1R1VHVApmYVpGczByVUdMQTV1Ui8zVHM2b1hxWnowUkZYVC9lU29JbEFnMVplckpHd0FlNTNhWllvdm9ERi9Ja2lubldOCjB3Y2dQSWl4R1RtdU9iQ0NPS3k1bk8xMnJ5NGtFa3djRWRkSkQ2S3JKYkdYNkg3VWNXV3VvQkxUUDhoVEgxTjEKNUtIVmtJZ0U2a3h4RHpVeUtNb3FhekZ3M0MrVUp5U0pEZHVnb3dJREFRQUJNQTBHQ1NxR1NJYjNEUUVCQ3dVQQpBNElCQVFBcE40OHlWTml3RnR4TEZ5V3ZVTmdQRWZLc0c1M3M2bGR4RjRLNk84Wm44ODAzR2tUR0o3MnkrSFVICjJTZkpPV3hyRnVzdysrZ2ZONjBPV0FZbnF5RzkvREttczJsUTFabmw1QU8wUWpxM0NqZkl2ODV4Q2VuQWVsdngKYktrZjFPR1lSNTBHZFl4TGYwMEFaVzhBSFBvOFkvRDBEL2phVXN1OEhsVnFhSWF6SmpTSldpZkFWcFh0cXpaeQp2ZDVWTWRST3diNWdhWWZhRjJVWDZLSlFpemF1K2hzV2ZWOGkzRnNMY2w1YWJmYnkyNUROTlUwVHZYU3V3ckVwCnZBSDNMU2hJeGtRQzU0REc3TDM0WFJ6Q1hkN3U4QkR3U1JaczQzSkxwQ1JKR1RGc0hvNnFPaFdEVFBSa0xDcTUKbGt4bG5FbUNTMFdPWHhRVGRGYUdpN0ZIMVBSLwotLS0tLUVORCBDRVJUSUZJQ0FURS0tLS0tCg== tls.key: LS0tLS1CRUdJTiBQUklWQVRFIEtFWS0tLS0tCk1JSUV2Z0lCQURBTkJna3Foa2lHOXcwQkFRRUZBQVNDQktnd2dnU2tBZ0VBQW9JQkFRRE5BNTBXRzlKN1BaVGcKVlQ3SWVJeU02a0ZmRlRBTnRaSkdxY1dJQXZQRHZ4amllVzZYdlJDekdKTGdhQzFFbjVHbDlPY2NESVRsL2t1QQpxSUd3VGxqOGU5UDNqcEZjVmhwRGIzUXhyZEdWWHVpN0R6ZEY1SitIaDV2cXVJbFNiakk5ZUl0TjIxL21xLzVxCmQyUVM1VzVWQm5VazFRdUVOQzNEZ1FKSEhJT2l3cmtaUVpOOXBrV3pTdFFZc0RtNUgvZE96cWhlcG5QUkVWZFAKOTVLZ2lVQ0RWbDZza2JBQjduZHBsaWkrZ01YOGlTS2VkWTNUQnlBOGlMRVpPYTQ1c0lJNHJMbWM3WGF2TGlRUwpUQndSMTBrUG9xc2xzWmZvZnRSeFphNmdFdE0veUZNZlUzWGtvZFdRaUFUcVRIRVBOVElveWlwck1YRGNMNVFuCkpJa04yNkNqQWdNQkFBRUNnZ0VCQU1kdUpIbEZSMU1yYkk5dFhVMldOdU05WGFvbzZqM3J5d2VDVHUwb01nalEKOUZ3YTFFSTNZTzlYa0VsTURmMGJYSXViMk5Xb04vK2poNzc0TEhCZFJxTVZzZlMzY3gvbmdsVG5McGpGQllQUQpkNFRBSUh5VkVicTlhQ2JFckpETE1ZUXFweGh0dHJTbHl5KzJSRnM5WkQ3QnNXTEsvQkQyMFMzRmFYblRleG52Cm94Tk42ZFhNMHhZU09MZ2pWNGdEd1VJUUlvNW02TmFadkVHbkNxck9hbDdad0FodmVFeFVpbUU3WUFldVF6dnMKYjE3NWZPOTdLT1hjblAyQm0zUm5SenYwNlNSVmJSdURTdlovamtGUTVJUG9uMUZ6TlJBWm5nYVZ6UldkTUVYbQoySnZPUmptQ3BCbTNvNVpjbUFIaitIQWoxa3l3Qy9SMkhyTU1FeG82Y1lFQ2dZRUE5L2VjZGJKem4zd0pZK0dBCnQ0WS9wRFhnUitpQkNwQnVYTkxubU5VZDJycnJJTXNYWnoyMGlUeVAxL0gwRWl2Q3pLSm9nYnljK2lXUFE2LzIKRVFrcXVIaXoyOGVpaU1DYmUyQVdYUUpTQnpoSy9YM0hWc2V5ckRsRnJyTmZ4SzVxYzVhTUZRbzNGM2tRMVRVUgpyZDczSFkrcWZWMHRHVVhYVlZRd0JkZ2Q3ZmtDZ1lFQTA2ZksrSE0vRS9FQ201TDdKYUoycVgwbmFVMDJzbmxqCjZCbUhDenNVY3EwQUMvdVFrMkJkTFJXbHBlSnU2VXRFU0dIWm1hZ0Fua3VpNTVxdFhTeG1VdGdjOURnTWtleHoKZU9OQkFNQnUrTFRpYVRqeWE0VG5GYjh4YmJaZUtRN2hiYzJQMDdMMjhZRmxxRDg4VDV4VFRpNUs2L3dJclNZWAo2MlJmRytlSEduc0NnWUVBd0JzWUh1TDZ5c01ZcjBYa0o4cWRBWVl2MU9YZkd5VWNLMVBGMDFUQWhWV3NsY0poCnhqMDY0ZHVHZ1VGVTJzTUdidTBmMCtzaEhuYjh6KzdCeng3djl1eWtReEFkN3A1eGxwcXhtS3NVaTcxajg1Ri8KWHM3bHNLSEtSM2QyS1hVS3liUUhvTUZDUHpBdkIwN08vSW94bnJoUDJFSFlqNnpaRDZWaWN4U2swMWtDZ1lBTgo4czNtaDduTmQ2R2pYUkZlRHBIaFk1VVlWSFZaVjdTazFDSFpOS0NKV2l0Wm5zK05WdGx0SWpNVGRwTzJualkyCnl2UUxNMDR2SUc3dzhubWdYVSswLy9jUWhTMFc1TTFMVnphdWRRQWJOZGlCOUxYTkxpb0lmZHdsRGRLd3hBRkoKT2pYVFRzVUZiM0Npb09BNW91UytqMEJ5d3Q1VGd1SXFxaWUyY0JDd1J3S0JnRTM3dWpSN0JHYVI2ZU4xLzh4QwpHUlZ3K2MrSU9yV044YmhONHBGYjNHYU1ELytiaUZmK1BVaXZNMzZzUDAzNnphSno1QnF6NXJILzhKSjZwUmthClUzYzlwKzg2Rk5PU2YrU09KaVhHdko5dkc2Wk5kKzBsUkJXTHRkUUVhZE0va29Sd0c2c3d1bWsyRUROWE9Jd1cKZHV4bFZtdUpENEdhNDU2WDFTejRTMGFiCi0tLS0tRU5EIFBSSVZBVEUgS0VZLS0tLS0K kind: Secret metadata: creationTimestamp: null name: my-tls type: kubernetes.io/tls 引用 Secret 对象 Secret 资源在 Pod 中引用的方式同样有两种\n环境变量 1.引用Secret对象上特定的key，以valueFrom赋值给Pod上指定的环境变量 2.在Pod上使用envFrom一次性导入Secret对象上的所有key-value，key（也可以统一附加特定前缀）即为环境变量名，value自动成为相应的变量值 secret 卷 1.在Pod上将Secret对象引用为存储卷，而后整体由容器mount至某个目录下key转为文件名，value即为相应的文件内容 2.在Pod上定义Secret卷时，仅引用其中的部分key，而后由容器mount至目录下 3.在容器上仅mount Secret卷上指定的key 注意：容器很可能会将环境变量打印到日志中，因而不建议以环境变量方式引用 Secret 中的数据\n在 Pod 上引用 Secret 的示例 在 Pod 上引用 Secret 资源 apiVersion: apps/v1 kind: Deployment metadata: labels: app: my-dep name: my-dep spec: replicas: 1 selector: matchLabels: app: my-dep template: metadata: labels: app: my-dep spec: containers: - image: nginx:latest name: nginx ports: - containerPort: 80 volumeMounts: - name: my-secret mountPath: /etc/nginx/certs/ readOnly: true volumes: - name: my-secret secret: secretName: my-tls # secret 名称 ","date":"2023-12-06T00:00:00Z","image":"https://www.colorfulgz.com/p/20231206/20231210210356_huf82f5319c81c2335d855e5033f51ea01_464670_120x120_fill_box_smart1_3.png","permalink":"https://www.colorfulgz.com/p/20231206/","title":"Kubernetes实战"}]